<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="https://www.javierpzh.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.javierpzh.com/" rel="alternate" type="text/html" /><updated>2023-04-11T15:48:03+02:00</updated><id>https://www.javierpzh.com/feed.xml</id><title type="html">javierpzh</title><subtitle></subtitle><entry><title type="html">Como Actualizar Addons Del Repositorio Luar En Kodi</title><link href="https://www.javierpzh.com/blog/Como-actualizar-AddOns-del-repositorio-Luar-en-Kodi" rel="alternate" type="text/html" title="Como Actualizar Addons Del Repositorio Luar En Kodi" /><published>2022-10-15T00:00:00+02:00</published><updated>2022-10-15T00:00:00+02:00</updated><id>https://www.javierpzh.com/blog/Como-actualizar-AddOns-del-repositorio-Luar-en-Kodi</id><content type="html" xml:base="https://www.javierpzh.com/blog/Como-actualizar-AddOns-del-repositorio-Luar-en-Kodi">&lt;p&gt;En este breve artículo, vamos a ver como actualizar de manera sencilla los &lt;em&gt;AddOns&lt;/em&gt; del repositorio &lt;strong&gt;Luar&lt;/strong&gt; en &lt;strong&gt;Kodi&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;En este blog no encontráreis ningún tipo de tutorial sobre como añadir este repositorio a &lt;em&gt;Kodi&lt;/em&gt;, ya que hay cientos de tutoriales en internet de cómo hacerlo, por lo que no aportaría nada relevante, simplemente voy a explicar como actualizar cualquier &lt;em&gt;AddOn&lt;/em&gt; de &lt;em&gt;Luar&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;-cómo-actualizar-un-addon-&quot;&gt;¿ Cómo actualizar un AddOn ?&lt;/h2&gt;

&lt;p&gt;Lo primero que debemos hacer es acceder al menú de &lt;strong&gt;Luar&lt;/strong&gt;, simplemente navegamos por nuestra interfaz hasta llegar a la sección llamada &lt;strong&gt;Add-Ons&lt;/strong&gt;, aquí tenemos que buscar este repo llamado &lt;strong&gt;Luar&lt;/strong&gt; y hacer &lt;em&gt;click&lt;/em&gt; en él.&lt;/p&gt;

&lt;p&gt;Una vez dentro, tendremos que descender hasta el apartado &lt;strong&gt;Herramientas&lt;/strong&gt;, donde aparece la opción &lt;strong&gt;Buscar Actualizaciones&lt;/strong&gt;. Esta funcionalidad lo que hace es, a raíz de los &lt;em&gt;AddOns&lt;/em&gt; de &lt;em&gt;Luar&lt;/em&gt; instalados en nuestro equipo, revisar de cada uno de ellos, cuál es la versión más reciente, y en caso de no coincidir con la versión instalada, nos facilita la actualización, de modo que podamos obtener las novedades de manera muy sencilla.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/como_actualizar_addons_del_repositorio_luar_en_kodi/repositorio_luar.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;En mi caso, al acceder a dicha funcionalidad, me indica y recomienda actualizar el &lt;em&gt;AddOn Winner 2&lt;/em&gt;. Si estamos de acuerdo en instalar la actualización, debemos hacer &lt;em&gt;click&lt;/em&gt; en ella.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/como_actualizar_addons_del_repositorio_luar_en_kodi/actualizaciones_luar.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Como último paso, nos abre una ventana en la que nos indica algunos detalles de la nueva versión del &lt;em&gt;AddOn&lt;/em&gt; en cuestión, y es en ésta, donde daremos la última orden de actualizar.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/como_actualizar_addons_del_repositorio_luar_en_kodi/actualización_luar.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Tras esto, comenzará el proceso de actualización, que normalmente no llevará mucho tiempo. Al finalizar nos indicará en un &lt;em&gt;banner&lt;/em&gt; un mensaje informativo en el que nos informará que el proceso ha terminado de manera exitosa.&lt;/p&gt;

&lt;p&gt;Como recomendación personal, tras llevar a cabo una actualización, reiniciar el programa para que el propio se inicie con las últimas configuraciones.&lt;/p&gt;

&lt;p&gt;Con estos breves y simples pasos ya podremos actualizar cualquier &lt;em&gt;AddOn&lt;/em&gt; del repositorio &lt;em&gt;Luar&lt;/em&gt; que nos interese.&lt;/p&gt;</content><author><name></name></author><summary type="html">En este breve artículo, vamos a ver como actualizar de manera sencilla los AddOns del repositorio Luar en Kodi.</summary></entry><entry><title type="html">Introducción Y Desarrollo De Vpn Con Wireguard</title><link href="https://www.javierpzh.com/blog/introducci%C3%B3n-y-desarrollo-de-VPN-con-WireGuard" rel="alternate" type="text/html" title="Introducción Y Desarrollo De Vpn Con Wireguard" /><published>2021-07-01T00:00:00+02:00</published><updated>2021-07-01T00:00:00+02:00</updated><id>https://www.javierpzh.com/blog/introducci%C3%B3n-y-desarrollo-de-VPN-con-WireGuard</id><content type="html" xml:base="https://www.javierpzh.com/blog/introducci%C3%B3n-y-desarrollo-de-VPN-con-WireGuard">&lt;p&gt;A día de hoy, nos encontramos con una situación de monopolio absoluto en el mundo de las VPN, liderado por &lt;strong&gt;OpenVPN&lt;/strong&gt;, que ya todos conoceréis, o incluso habréis trabajado con él.
He mencionado el término VPN, pero ¿qué es una VPN?&lt;/p&gt;

&lt;h2 id=&quot;-qué-es-una-vpn-&quot;&gt;¿ Qué es una VPN ?&lt;/h2&gt;

&lt;p&gt;El término &lt;strong&gt;VPN&lt;/strong&gt; viene de las siglas de &lt;em&gt;“Virtual Private Network”&lt;/em&gt;, es una tecnología que permite a través de una conexión a internet, una conexión segura a otra red privada.&lt;/p&gt;

&lt;p&gt;Permite, además, enviar y recibir datos como si se formase parte de la red local o privada, obteniendo así las funcionalidades que dicha red ofrece.&lt;/p&gt;

&lt;p&gt;También se puede hacer referencia a una red privada virtual como un túnel, pues realmente lo que hace es crear un canal para el tráfico entre el cliente y el servidor VPN en el que su contenido corre independientemente del resto y de manera cifrada.&lt;/p&gt;

&lt;p&gt;Básicamente, lo que te permite es crear una red local sin necesidad que sus integrantes estén físicamente conectados entre sí. Esto nos proporciona una flexibilidad absoluta, ya que, por ejemplo, podríamos crear una red privada con clientes de una punta del mundo, y clientes de la otra.&lt;/p&gt;

&lt;p&gt;Bien, una vez conocemos lo que es una VPN y las ventajas que nos ofrece, es el momento de preguntarnos, ¿necesitamos las VPNs?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/introducción_y_desarrollo_de_VPN_con_WireGuard/gráficoVPN.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-son-necesarias-las-vpns-&quot;&gt;¿ Son necesarias las VPNs ?&lt;/h2&gt;

&lt;p&gt;Habitualmente, cuando navegamos por internet tan solo hacemos uso de nuestra conexión mediante el proveedor contratado, de manera que todo el tráfico de datos, es posible que sea consultado por este proveedor de internet.&lt;/p&gt;

&lt;p&gt;¿Esto quiere decir que al usar una VPN nuestro tráfico no pasa por el proveedor?
La respuesta es, no. Al usar una conexión VPN, el tráfico de red sigue yendo del dispositivo al proveedor, pero de este, se dirige directo al servidor VPN, desde donde partirá al destino. Normalmente la conexión está cifrada, de modo que el proveedor realmente no sabe a qué estás accediendo.&lt;/p&gt;

&lt;p&gt;Respondiendo a la primera pregunta, sí, son muy necesarias, desde la seguridad que aportan, hasta la posibilidad que nos ofrece al permitirnos el acceso a contenido restringido en una localización, pasando por el teletrabajo, que tan necesario se ha vuelto actualmente, y la posibilidad de ofrecernos confidencialidad que muchos buscamos.&lt;/p&gt;

&lt;p&gt;A efectos prácticos, al hacer uso de una VPN, tu dirección IP de cara a internet, es la del servidor VPN.
Otra de sus ventajas es que al utilizar una conexión VPN, no tenemos ningún tipo de limitación, ya que funciona en todas las aplicaciones además de en un navegador.&lt;/p&gt;

&lt;p&gt;Vistas las ventajas y utilidades de las VPNs, vamos a retomar un poco el contenido en sí de este proyecto.
Como he dicho al principio, hoy en día nos encontramos con una gran monopolización en el ámbito de las VPNs de código abierto, donde lidera &lt;em&gt;OpenVPN&lt;/em&gt;. He experimentado la creación de un servidor y sus respectivos clientes, con dicho software, y siempre me ha parecido un proceso algo complejo y bastante lento de realizar.&lt;/p&gt;

&lt;p&gt;Teniendo en cuenta estos aspectos, me interesé por &lt;strong&gt;WireGuard&lt;/strong&gt;, y empecé a investigar un poco, dándome cuenta rápidamente y quedando gratamente sorprendido al ver sus sencillos procesos de configuración.&lt;/p&gt;

&lt;h2 id=&quot;-qué-es-wireguard-&quot;&gt;¿ Qué es WireGuard ?&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;WireGuard&lt;/em&gt; es un protocolo de comunicación de software libre que implementa técnicas de VPN para crear conexiones seguras punto a punto en configuraciones enrutadas o puenteadas.&lt;/p&gt;

&lt;p&gt;Es una aplicación &lt;strong&gt;multiplataforma&lt;/strong&gt; (Linux, Windows, macOS, Android e iOS). Se presenta como una solución más rápida y sencilla que las existentes hasta la fecha, para aquellos usuarios que necesiten o deseen hacer uso de una VPN.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/introducción_y_desarrollo_de_VPN_con_WireGuard/wireguard.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nació en el año 2016, por lo que es una tecnología muy reciente, aún en desarrollo y no conocida por muchos. Está escrita por Jason A. Donenfeld en &lt;strong&gt;C++&lt;/strong&gt; y en &lt;strong&gt;Go&lt;/strong&gt;, y publicada bajo GPL.&lt;/p&gt;

&lt;p&gt;Su objetivo es convertirse en un estándar en usuarios domésticos y en empresas, en lugar de &lt;em&gt;IPsec&lt;/em&gt; u &lt;em&gt;OpenVPN&lt;/em&gt;, que son más difíciles y más lentos, esto a consecuencia de que &lt;em&gt;WireGuard&lt;/em&gt; consume muy pocos recursos del sistema.&lt;/p&gt;

&lt;p&gt;Es compatible con redes IPv4 y con redes IPv6, además de poder encapsular paquetes IPv4 en IPv6 y viceversa.&lt;/p&gt;

&lt;p&gt;Uno de los puntos fuertes de este software es que la configuración del cliente y servidor es exactamente igual en los diferentes sistemas operativos que soporta, lo que lo hace muy manejable y adaptable.&lt;/p&gt;

&lt;p&gt;Sus creadores, aseguran una gran superioridad frente a &lt;em&gt;OpenVPN&lt;/em&gt;, en aspectos como la velocidad de transmisión y la incorporación de un cifrado de siguiente nivel.&lt;/p&gt;

&lt;p&gt;Hace uso del protocolo &lt;strong&gt;UDP&lt;/strong&gt;, normalmente se utiliza el puerto 51820, aunque por defecto WireGuard utiliza puertos dinámicos. En mi caso, recomiendo asignar de manera estática el puerto &lt;strong&gt;51820&lt;/strong&gt;, ya que es bastante más recomendable si vamos a implantar la aplicación detrás de un cortafuegos.&lt;/p&gt;

&lt;h3 id=&quot;principales-diferencias-con-openvpn&quot;&gt;Principales diferencias con OpenVPN&lt;/h3&gt;

&lt;p&gt;Para combatir a su principal rival e incitar al cambio a los clientes, &lt;em&gt;WireGuard&lt;/em&gt; se ha visto en la obligación de tener que incorporar una serie de mejoras.&lt;/p&gt;

&lt;p&gt;Entre las más significativas, se encuentran las siguientes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Notables mejoras de rendimiento:&lt;/strong&gt; &lt;em&gt;WireGuard&lt;/em&gt; casi toca el rendimiento del 100% de una conexión de 1 Gbps, y lo hace sin maximizar la CPU del servidor, esto, gracias a que su código está formado por unas 4 000 líneas de código, frente a las más de 100 000 que forman &lt;em&gt;OpenVPN&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Mejoras de ping:&lt;/strong&gt; &lt;em&gt;WireGuard&lt;/em&gt; registra un tiempo de ping que es menos de la mitad del de &lt;em&gt;OpenVPN&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/introducción_y_desarrollo_de_VPN_con_WireGuard/gráficospinglatencia.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Configuraciones:&lt;/strong&gt; Las configuraciones de &lt;em&gt;WireGuard&lt;/em&gt; son bastante más sencillas y rápidas de realizar que las de &lt;em&gt;OpenVPN&lt;/em&gt;. Esto es debido a que en &lt;em&gt;WireGuard&lt;/em&gt; las conexiones se realizan mediante pares de claves públicas-privadas, no mediante nodos centrales, como es el caso de &lt;em&gt;OpenVPN&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Más seguro:&lt;/strong&gt; &lt;em&gt;WireGuard&lt;/em&gt; utiliza métodos criptográficos más recientes, mientras que el cifrado de &lt;em&gt;OpenVPN&lt;/em&gt; está un poco des-actualizado, lo que afirma su lugar como el protocolo más seguro de los dos.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Compatibilidad con roaming:&lt;/strong&gt; &lt;em&gt;WireGuard&lt;/em&gt; está diseñado para poder realizar &lt;em&gt;roaming&lt;/em&gt; de manera fácil y rápida, es decir, si nuestro dispositivo cambia de red, y lógicamente cambia de IP pública, la conexión VPN seguirá levantada porque se volverán a autenticar rápidamente con el servidor VPN, de tal forma que siempre estaremos conectados a la VPN.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Kill-Switch:&lt;/strong&gt; En &lt;em&gt;WireGuard&lt;/em&gt; podremos habilitar el &lt;em&gt;Kill-Switch&lt;/em&gt; en los dispositivos, de esta forma, si la conexión VPN se interrumpe, el propio software también se encargará de interrumpir todo el tráfico de red hasta que se vuelva a restablecer la conexión VPN, con el objetivo de que no naveguemos sin la protección que nos brinda esta VPN.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En este punto, podemos hacernos una idea de todo el potencial de &lt;em&gt;WireGuard&lt;/em&gt;, y de lo que promete llegar a ser en un futuro no muy lejano. Para verlo con un poco más de profundidad, y como no podía faltar, vamos a ver algunos ejemplos prácticos de este software.&lt;/p&gt;

&lt;h3 id=&quot;conexión-site-to-site&quot;&gt;Conexión Site to Site&lt;/h3&gt;

&lt;p&gt;En primer lugar, para mostrar el funcionamiento de &lt;em&gt;WireGuard&lt;/em&gt;, voy a mostrar cómo se realiza una conexión &lt;strong&gt;“Site to Site”&lt;/strong&gt; mediante comandos. Esto nos servirá para comprender mejor la comodidad que nos brinda &lt;em&gt;WireGuard&lt;/em&gt;, aunque no es lo recomendable para una puesta en producción.&lt;/p&gt;

&lt;p&gt;Para ello he grabado el siguiente vídeo donde se puede apreciar con todo detalle el proceso:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=tRnnk_P8cyA&quot;&gt;Demo Site to Site - WireGuard&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;escenario-real-para-producción&quot;&gt;Escenario real para producción&lt;/h3&gt;

&lt;p&gt;Además del ejemplo visto en el apartado anterior, he preparado un escenario más elaborado y que simularía una puesta en producción mucho más real.&lt;/p&gt;

&lt;p&gt;Este escenario está liderado por un servidor que se encontrará en una máquina virtual con un sistema &lt;strong&gt;Debian 11&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Como clientes voy a incorporar uno con un sistema &lt;strong&gt;Debian 11&lt;/strong&gt; y un cliente &lt;strong&gt;Windows&lt;/strong&gt;. Adicionalmente, &lt;em&gt;WireGuard&lt;/em&gt; posee una app tanto en &lt;em&gt;Play Store&lt;/em&gt; para usuarios de &lt;strong&gt;Android&lt;/strong&gt;, como en &lt;em&gt;App Store&lt;/em&gt; para los usuarios de &lt;strong&gt;iOS&lt;/strong&gt;. Dada esta posibilidad, también incorporaré un cliente de cada uno de estos tipos. Además, en todos estos dispositivos, las configuraciones las realizaré mediante ficheros, es decir, lo idóneo para una puesta en producción. Hecha esta pequeña introducción vamos a pasar con las propias configuraciones en sí.&lt;/p&gt;

&lt;h4 id=&quot;configuración-servidor-debian-11-primera-parte&quot;&gt;Configuración servidor Debian 11 (primera parte)&lt;/h4&gt;

&lt;p&gt;En primer lugar, empezaremos viendo la configuración del servidor &lt;em&gt;WireGuard&lt;/em&gt;, recordemos en una máquina &lt;em&gt;Debian 11&lt;/em&gt;. Comenzaremos instalando el paquete en sí. Este paquete estará disponible en repositorios a partir de &lt;em&gt;Debian 11&lt;/em&gt;, para versiones anteriores lo podremos encontrar en repositorios &lt;em&gt;backports&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
root@server:~# apt install wireguard –y
&lt;/pre&gt;

&lt;p&gt;Una vez instalado deberemos habilitar el &lt;strong&gt;bit de forward&lt;/strong&gt;, para permitir el reenvío de paquetes:&lt;/p&gt;

&lt;pre&gt;
root@server:~# nano /etc/sysctl.conf
...
net.ipv4.ip_forward = 1
...

root@server:~# sysctl -p /etc/sysctl.conf
net.ipv4.ip_forward = 1
&lt;/pre&gt;

&lt;p&gt;Hecho esto podremos dirigirnos al directorio de trabajo de &lt;em&gt;WireGuard&lt;/em&gt;, que se encuentra en esta ruta:&lt;/p&gt;

&lt;pre&gt;
root@server:~# cd /etc/wireguard/
&lt;/pre&gt;

&lt;p&gt;Modificaremos la política de permisos en este directorio para que los ficheros que vamos a crear en los pasos posteriores, se creen de manera predeterminada con los permisos adecuados:&lt;/p&gt;

&lt;pre&gt;
root@server:/etc/wireguard# umask 077
&lt;/pre&gt;

&lt;p&gt;Ahora es el paso de generar nuestro par de claves públicas privadas mediante el siguiente comando que nos facilita &lt;em&gt;WireGuard&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
root@server:/etc/wireguard# wg genkey | tee serverprivatekey | wg pubkey &amp;gt; serverpublickey

root@server:/etc/wireguard# ls -l
total 8
-rw------- 1 root root 45 May 26 11:09 serverprivatekey
-rw------- 1 root root 45 May 26 11:09 serverpublickey

root@server:/etc/wireguard# cat serverprivatekey
wOENVR47BOYbfHFUUiYLq2H3xKOSZAe0oNNUXoHXVGk=

root@server:/etc/wireguard# cat serverpublickey
cgJ6GfgX1x+YCDzW7TyrmuPzxfkJf5798h+NWwmVlmk=
&lt;/pre&gt;

&lt;p&gt;Generados dichas claves, podremos crear nuestro fichero de configuración en el servidor, lo que va a definir su comportamiento/funcionamiento. El nombre que le asignemos, será el nombre que recibirá la interfaz de red de este túnel VPN, normalmente se le asigna el nombre &lt;strong&gt;“wg0”&lt;/strong&gt; seguido de la terminación &lt;strong&gt;“.conf”&lt;/strong&gt; . Dicho archivo poseerá inicialmente el siguiente aspecto:&lt;/p&gt;

&lt;pre&gt;
root@server:/etc/wireguard# nano wg0.conf

root@server:/etc/wireguard# cat wg0.conf
# Server config
[Interface]
Address = 10.0.100.1
PrivateKey = wOENVR47BOYbfHFUUiYLq2H3xKOSZAe0oNNUXoHXVGk=
ListenPort = 51820
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar que he añadido una nueva sección llamada &lt;strong&gt;Interface&lt;/strong&gt; y dentro de ella disponemos de varios campos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Address:&lt;/strong&gt; define la dirección IP que tendrá nuestro servidor.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PrivateKey:&lt;/strong&gt; especificamos la clave privada que generamos anteriormente.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ListenPort:&lt;/strong&gt; este campo no es obligatorio, pero sí es recomendable añadirlo para asignar un puerto estático. En mi caso defino el &lt;em&gt;51820&lt;/em&gt; que es el que normalmente se utiliza en &lt;em&gt;WireGuard&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PostUp / PostDown:&lt;/strong&gt; definen las reglas de &lt;em&gt;iptables&lt;/em&gt; que se levantarán y se eliminarán al iniciar o detener el servicio del servidor, de manera que podremos automatizar el proceso y será mucho más eficiente.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Es el momento de activar el servidor y ponerlo en funcionamiento. Para ello, algo que aún no he comentado, se utiliza el comando &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wg-quick up/down (interfaz)&lt;/code&gt; que sirve para manejar la actividad del servidor:&lt;/p&gt;

&lt;pre&gt;
root@server:/etc/wireguard# wg-quick up wg0
[#] ip link add wg0 type wireguard
[#] wg setconf wg0 /dev/fd/63
[#] ip -4 address add 10.0.100.1 dev wg0
[#] ip link set mtu 1420 up dev wg0
[#] iptables -A FORWARD -i wg0 -j ACCEPT; iptables -A FORWARD -o wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
&lt;/pre&gt;

&lt;p&gt;Podemos ver cómo nos ha levantado el túnel, además, de haber aplicado las reglas especificadas, por lo que ahora mismo el servidor se encontraría activo. Esto se puede comprobar con el comando &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wg&lt;/code&gt;, que nos da un resumen del estado actual del servicio de &lt;em&gt;WireGuard&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
root@server:/etc/wireguard# wg
interface: wg0
  public key: cgJ6GfgX1x+YCDzW7TyrmuPzxfkJf5798h+NWwmVlmk=
  private key: (hidden)
  listening port: 51820
&lt;/pre&gt;

&lt;p&gt;Vamos a comprobar la nueva interfaz de red, en la podemos ver que le ha asignado la IP correctamente. Como último paso, voy a activar el inicio del servicio de &lt;em&gt;WireGuard&lt;/em&gt; en cada arranque del sistema. Esto lo podemos hacer porque &lt;em&gt;WireGuard&lt;/em&gt; posee una unidad de &lt;em&gt;systemd&lt;/em&gt;, por lo que también podríamos manejar nuestro servidor a través de ella:&lt;/p&gt;

&lt;pre&gt;
root@server:/etc/wireguard# ip a show wg0
4: wg0: &amp;lt;POINTOPOINT,NOARP,UP,LOWER_UP&amp;gt; mtu 1420 qdisc noqueue state UNKNOWN group default qlen 1000
    link/none
    inet 10.0.100.1/32 scope global wg0
       valid_lft forever preferred_lft forever

root@server:/etc/wireguard# systemctl enable wg-quick@wg0
Created symlink /etc/systemd/system/multi-user.target.wants/wg-quick@wg0.service → /lib/systemd/system/wg-quick@.service.
&lt;/pre&gt;

&lt;h4 id=&quot;configuración-cliente-debian-11&quot;&gt;Configuración cliente Debian 11&lt;/h4&gt;

&lt;p&gt;En este punto vamos a pasar con la configuración del primer cliente. Se trata del cliente &lt;em&gt;Linux&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;El inicio del proceso es exactamente el mismo que el que hemos llevado a cabo en el servidor, por lo que omitiré las explicaciones realizadas anteriormente:&lt;/p&gt;

&lt;pre&gt;
root@client:~# apt install wireguard -y

root@client:~# cd /etc/wireguard/

root@client:/etc/wireguard# umask 077

root@client:/etc/wireguard# wg genkey | tee clientprivatekey | wg pubkey &amp;gt; clientpublickey

root@client:/etc/wireguard# ls -l
total 8
-rw------- 1 root root 45 May 26 11:12 clientprivatekey
-rw------- 1 root root 45 May 26 11:12 clientpublickey

root@client:/etc/wireguard# cat clientprivatekey
qEFD2evf0hEr/oAWCTReK7BCuRjZ+zeCu45WgSV1QlQ=

root@client:/etc/wireguard# cat clientpublickey
MVD+I0Q7Y4F8dZK6Nl5Lx7C5IDIv1h+Olnf9dBmJNns=
&lt;/pre&gt;

&lt;p&gt;De nuevo, crearemos un fichero de configuración, esta vez obviamente para el cliente.&lt;/p&gt;

&lt;p&gt;En él, vamos a volver a establecer la sección &lt;strong&gt;Interface&lt;/strong&gt; que ya vimos en el servidor, y también añadiremos una nueva, llamada &lt;strong&gt;Peer&lt;/strong&gt;. En esta sección es donde aparecerán los datos relativos al servidor:&lt;/p&gt;

&lt;pre&gt;
root@client:/etc/wireguard# nano wg0.conf

root@client:/etc/wireguard# cat wg0.conf
[Interface]
Address = 10.0.100.2/32
PrivateKey = qEFD2evf0hEr/oAWCTReK7BCuRjZ+zeCu45WgSV1QlQ=
ListenPort = 51820

[Peer]
PublicKey = cgJ6GfgX1x+YCDzW7TyrmuPzxfkJf5798h+NWwmVlmk=
AllowedIPs = 0.0.0.0/0
Endpoint = 192.168.0.49:51820
&lt;/pre&gt;

&lt;p&gt;Podemos ver como en la sección &lt;em&gt;Interface&lt;/em&gt; los campos son iguales que en el fichero del servidor, por lo que me centraré y trataré de explicar ahora la sección &lt;em&gt;Peer&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PublicKey:&lt;/strong&gt; especificamos la clave pública del servidor.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;AllowedIPs:&lt;/strong&gt; especificamos el rango de IPs que vamos a permitir que se nos asigne.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Endpoint:&lt;/strong&gt; define la dirección del servidor al que nos conectaremos.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Con esto habríamos terminado la configuración del cliente &lt;em&gt;Linux&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Como podemos ver es un proceso totalmente rápido y sencillo, así que tan solo faltaría iniciar el servicio y esperar a la conexión.&lt;/p&gt;

&lt;h4 id=&quot;configuración-servidor-debian-11-añadiendo-cliente-linux&quot;&gt;Configuración servidor Debian 11 (añadiendo cliente Linux)&lt;/h4&gt;

&lt;p&gt;Como he comentado, el cliente Linux ya se encontraría listo para poder navegar a través de nuestro servidor VPN, pero el servidor aún no lo hemos configurado para que sea capaz de tratar a este cliente, por lo que vamos a llevar a cabo dicho proceso.&lt;/p&gt;

&lt;p&gt;De nuevo editaremos el fichero de configuración &lt;strong&gt;“wg0.conf”&lt;/strong&gt; y en él, ahora sí, añadiremos la sección &lt;strong&gt;Peer&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Como ya hemos visto, en la parte de los clientes, tan solo vamos a tener que añadir una sección &lt;em&gt;Peer&lt;/em&gt; que definirá al propio servidor al que deseemos conectarnos, pero en el caso de los servidores es distinto, ya que tendremos que crear una sección &lt;em&gt;Peer&lt;/em&gt; por cada cliente que deseamos que se conecte.&lt;/p&gt;

&lt;p&gt;Explicado esto, voy a enseñar el contenido del fichero del servidor tras realizar las modificaciones y añadir a este nuevo cliente &lt;em&gt;Linux&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
root@server:/etc/wireguard# nano wg0.conf

root@server:/etc/wireguard# cat wg0.conf
# Server config
[Interface]
Address = 10.0.100.1
PrivateKey = wOENVR47BOYbfHFUUiYLq2H3xKOSZAe0oNNUXoHXVGk=
ListenPort = 51820
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

# Clients configs

# Debian Client
[Peer]
Publickey = MVD+I0Q7Y4F8dZK6Nl5Lx7C5IDIv1h+Olnf9dBmJNns=
AllowedIPs = 10.0.100.2/32
PersistentKeepAlive = 25
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar que en esta nueva sección volvemos a tener 3 campos.&lt;/p&gt;

&lt;p&gt;Nos encontramos con la clave pública esta vez del cliente, nos encontramos con el campo que definirá la dirección IP que se le va a asignar dentro de nuestro de nuestra red privada a este cliente, y nos encontramos con un nuevo campo llamado &lt;strong&gt;“PersistenKeepAlive”&lt;/strong&gt; qué es opcional y se encargará de, si en más de 25 segundos no se realiza ninguna transmisión de datos entre el cliente/servidor, enviar un pequeño paquete que verificará que la conexión sigue activa, pero como digo no es obligatorio.&lt;/p&gt;

&lt;p&gt;Hecho esto, aplicaremos los cambios a nuestro servidor reiniciando el servicio:&lt;/p&gt;

&lt;pre&gt;
root@server:/etc/wireguard# wg-quick down wg0
[#] ip link delete dev wg0
[#] iptables -D FORWARD -i wg0 -j ACCEPT; iptables -D FORWARD -o wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

root@server:/etc/wireguard# wg-quick up wg0
[#] ip link add wg0 type wireguard
[#] wg setconf wg0 /dev/fd/63
[#] ip -4 address add 10.0.100.1 dev wg0
[#] ip link set mtu 1420 up dev wg0
[#] ip -4 route add 10.0.100.2/32 dev wg0
[#] iptables -A FORWARD -i wg0 -j ACCEPT; iptables -A FORWARD -o wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

root@server:/etc/wireguard# wg
interface: wg0
  public key: cgJ6GfgX1x+YCDzW7TyrmuPzxfkJf5798h+NWwmVlmk=
  private key: (hidden)
  listening port: 51820

peer: MVD+I0Q7Y4F8dZK6Nl5Lx7C5IDIv1h+Olnf9dBmJNns=
  allowed ips: 10.0.100.2/32
  persistent keepalive: every 25 seconds
&lt;/pre&gt;

&lt;p&gt;Podemos ver como ahora, en el estado del servidor nos aparece una nueva sección que hace referencia a nuestro cliente. Irán apareciendo más secciones a medida que añadamos más clientes a nuestra red privada.&lt;/p&gt;

&lt;p&gt;Ahora sí, nuestro servidor estaría preparado para permitir que el cliente &lt;em&gt;Linux&lt;/em&gt; navegue a través de él, por lo que vamos a iniciar el servicio en dicho cliente y comprobar que realmente podemos navegar y tenemos acceso a internet:&lt;/p&gt;

&lt;pre&gt;
root@client:/etc/wireguard# wg-quick up wg0
[#] ip link add wg0 type wireguard
[#] wg setconf wg0 /dev/fd/63
[#] ip -4 address add 10.0.100.2/32 dev wg0
[#] ip link set mtu 1420 up dev wg0
[#] wg set wg0 fwmark 51820
[#] ip -4 route add 0.0.0.0/0 dev wg0 table 51820
[#] ip -4 rule add not fwmark 51820 table 51820
[#] ip -4 rule add table main suppress_prefixlength 0
[#] sysctl -q net.ipv4.conf.all.src_valid_mark=1
[#] nft -f /dev/fd/63

root@client:/etc/wireguard# wg
interface: wg0
  public key: MVD+I0Q7Y4F8dZK6Nl5Lx7C5IDIv1h+Olnf9dBmJNns=
  private key: (hidden)
  listening port: 51820
  fwmark: 0xca6c

peer: cgJ6GfgX1x+YCDzW7TyrmuPzxfkJf5798h+NWwmVlmk=
  endpoint: 192.168.0.49:51820
  allowed ips: 0.0.0.0/0
  latest handshake: 34 seconds ago
  transfer: 156 B received, 260 B sent
&lt;/pre&gt;

&lt;p&gt;Se puede apreciar cómo el cliente ya se ha conectado al servidor. Esto se debe a que han aparecido en los campos &lt;strong&gt;“latest handshake”&lt;/strong&gt; y &lt;strong&gt;“transfer”&lt;/strong&gt;. El primero define el tiempo que lleva en curso la conexión y el segundo la cantidad de datos que se han recibido/enviado.&lt;/p&gt;

&lt;p&gt;Si visualizamos la nueva interfaz de red, podemos ver cómo nos la ha creado con la dirección IP especificada, además de comprobar que realmente poseemos conexión a internet:&lt;/p&gt;

&lt;pre&gt;
root@client:/etc/wireguard# ip a show wg0
4: wg0: &amp;lt;POINTOPOINT,NOARP,UP,LOWER_UP&amp;gt; mtu 1420 qdisc noqueue state UNKNOWN group default qlen 1000
    link/none
    inet 10.0.100.2/32 scope global wg0
       valid_lft forever preferred_lft forever

root@client:/etc/wireguard# ping -c 3 www.google.es
PING www.google.es (172.217.17.3) 56(84) bytes of data.
64 bytes from mad07s09-in-f3.1e100.net (172.217.17.3): icmp_seq=1 ttl=61 time=18.9 ms
64 bytes from mad07s09-in-f3.1e100.net (172.217.17.3): icmp_seq=2 ttl=61 time=20.3 ms
64 bytes from mad07s09-in-f3.1e100.net (172.217.17.3): icmp_seq=3 ttl=61 time=22.0 ms

--- www.google.es ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2087ms
rtt min/avg/max/mdev = 18.946/20.402/21.957/1.231 ms
&lt;/pre&gt;

&lt;p&gt;En este momento, ya habríamos terminado el proceso de añadir el cliente &lt;em&gt;Linux&lt;/em&gt;, así que vamos a pasar con un nuevo cliente, es el turno de &lt;em&gt;Windows&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;configuración-cliente-windows&quot;&gt;Configuración cliente Windows&lt;/h4&gt;

&lt;p&gt;Bien, una vez hemos visto cómo se realiza una configuración cliente-servidor, hemos podido darnos cuenta de que consta de 2 partes diferenciadas, la primera llevada a cabo en el cliente, donde realizamos su configuración, y la segunda llevada a cabo en el servidor, donde es necesario añadir a este nuevo cliente. Esto es siempre así, independientemente del sistema operativo que estemos utilizando, algo que ya he comentado como una de las ventajas de &lt;em&gt;WireGuard&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Una vez conocemos el proceso, seremos capaces de realizarlo en todos los clientes necesarios, así que esta parte la voy a tratar un poco más por encima, dando por hecho que ya hemos aprendido los conocimientos vistos en los apartados anteriores.&lt;/p&gt;

&lt;p&gt;Para los usuarios de &lt;em&gt;Windows&lt;/em&gt;, &lt;em&gt;WireGuard&lt;/em&gt; tiene disponible una aplicación de escritorio que podremos descargar desde su página oficial, en la cual realizaremos de manera gráfica su configuración, además de administrar todo lo relacionado con nuestro túnel.&lt;/p&gt;

&lt;p&gt;A continuación, voy a mostrar una captura de pantalla en la que visualizaremos la configuración de este nuevo cliente:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/introducción_y_desarrollo_de_VPN_con_WireGuard/1-W10-config.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Antes de activar la conexión, añadiremos a nuestro servidor esta nueva sección &lt;em&gt;Peer&lt;/em&gt; y lo reiniciaremos para aplicar cambios:&lt;/p&gt;

&lt;pre&gt;
# W10 Client
[Peer]
PublicKey = 7HopGKOY2C8f6jBfEkc8whKUSoNSDvsqgI0ZMzPQ8Bg=
AllowedIPs = 10.0.100.3/32
PersistentKeepAlive = 25
&lt;/pre&gt;

&lt;p&gt;Con el servidor listo, podremos activar el túnel desde nuestro cliente y automáticamente podremos visualizar la nueva interfaz con nuestra IP dentro de la red privada, además de poseer conexión a internet:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/introducción_y_desarrollo_de_VPN_con_WireGuard/2-W10-activate.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/introducción_y_desarrollo_de_VPN_con_WireGuard/3-W10-direcciónIP.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/introducción_y_desarrollo_de_VPN_con_WireGuard/4-W10-ping.jpeg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Además de esto, he preparado una pequeña demo en la que podremos ver en tiempo real tanto el servidor como el cliente, cuando estamos navegando y realizando transmisiones de datos.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=oocdNpCSJy8&quot;&gt;Demo Windows 10 - WireGuard&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;configuración-cliente-android-y-cliente-ios&quot;&gt;Configuración cliente Android y cliente iOS&lt;/h4&gt;

&lt;p&gt;Como ya sabemos perfectamente cómo crear y conectar clientes a nuestro servidor, sería una tontería volver a realizar los mismos procesos, aunque sean para clientes de otros sistemas por lo que, tanto para el cliente &lt;em&gt;Android&lt;/em&gt;, como para el cliente &lt;em&gt;iOS&lt;/em&gt;, he incorporado una pequeña modificación.&lt;/p&gt;

&lt;p&gt;En ambas aplicaciones, disponemos de 2 métodos a la hora de realizar las configuraciones. La primera sería el método tradicional que hemos visto hasta ahora, y la segunda, trata de escanear un código QR que directamente nos importe la configuración al dispositivo.&lt;/p&gt;

&lt;p&gt;Lógicamente vamos a ver este nuevo método. Lo voy a explicar por encima ya que en realidad es exactamente lo mismo, pero con la diferencia de que el proceso se realiza entero en la máquina servidor. Básicamente lo que vamos a hacer es, crear en el servidor, el fichero de configuración que deseemos obtener en nuestro cliente, y luego generar a partir de él, un &lt;strong&gt;código QR&lt;/strong&gt; que al escanearlo en nuestros dispositivos nos importe la configuración. Una cosa que he omitido, aunque obviamente hay que tenerla en cuenta es que, será necesario volver a generar para cada cliente un nuevo par de claves.&lt;/p&gt;

&lt;p&gt;A continuación, voy a dejar tanto el fichero para el dispositivo &lt;em&gt;Android&lt;/em&gt;, como el fichero para el dispositivo &lt;em&gt;iOS&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
root@server:/etc/wireguard/client_android# cat clientAndroid.conf
[Interface]
Address = 10.0.100.4/32
PrivateKey = qF49LZiAUzPDqMSN5CJja4rH/ljkxOosdycicEa4YkE=
ListenPort = 51820

[Peer]
Publickey = cgJ6GfgX1x+YCDzW7TyrmuPzxfkJf5798h+NWwmVlmk=
AllowedIPs = 0.0.0.0/0
Endpoint = 192.168.0.49:51820
&lt;/pre&gt;

&lt;p&gt;Una vez lo tenemos nos bastaría con instalar en nuestro sistema el paquete &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;qrencode&lt;/code&gt; y generar mediante el siguiente comando, el código QR a escanear en nuestro dispositivo &lt;em&gt;Android&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
root@server:/etc/wireguard/client_android# qrencode -t ansiutf8 &amp;lt; clientAndroid.conf
&lt;/pre&gt;

&lt;pre&gt;
root@server:/etc/wireguard/client_iOS# cat clientiOS.conf
[Interface]
Address = 10.0.100.5/32
PrivateKey = kEmpljarBs76OA9woqrX/wzKzgVn7jWIAvABblkbzmU=
ListenPort = 51820
DNS = 8.8.8.8

[Peer]
Publickey = cgJ6GfgX1x+YCDzW7TyrmuPzxfkJf5798h+NWwmVlmk=
AllowedIPs = 0.0.0.0/0
Endpoint = 192.168.0.49:51820
&lt;/pre&gt;

&lt;p&gt;Generamos mediante el siguiente comando, el código QR a escanear en nuestro dispositivo &lt;em&gt;iOS&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
root@server:/etc/wireguard/client_iOS# qrencode -t ansiutf8 &amp;lt; clientiOS.conf
&lt;/pre&gt;

&lt;p&gt;En ambos casos, únicamente nos faltaría añadir las secciones pertinentes en nuestro servidor y disfrutar de la conexión. Para ello, en el fichero &lt;strong&gt;“wg0.conf”&lt;/strong&gt;, añadimos las siguientes secciones:&lt;/p&gt;

&lt;pre&gt;
# Android Client
[Peer]
Publickey = MWNcn3OkGswxkQslf5MfImbidehNL8K/FnEHmTbnglE=
AllowedIPs = 10.0.100.4/32
PersistentKeepAlive = 25

# iOS Client
[Peer]
Publickey = 539i52F6p08kK/wKkNW5Wi20fTQWigpJbXfoWNZASks=
AllowedIPs = 10.0.100.5/32
PersistentKeepAlive = 25
&lt;/pre&gt;

&lt;p&gt;Reiniciado el servidor y activadas las conexiones en ambos clientes, ya podríamos disfrutar de todas las ventajas de nuestra red privada. Para mostrar el funcionamiento de ambos dispositivos, he preparado al igual que anteriormente, dos vídeos en los que muestro a tiempo real el servidor y el cliente en cuestión.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=yrL_ZS1-xGQ&quot;&gt;Demo Android - WireGuard&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=Z4zdkleJfKg&quot;&gt;Demo iOS - WireGuard&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusión&quot;&gt;Conclusión&lt;/h2&gt;

&lt;p&gt;Espero que a través de este proyecto hayáis podido aprender y comprender todas las facilidades y ventajas que nos aporta este software, al igual que he aprendido yo.&lt;/p&gt;

&lt;p&gt;También comentar que no hay que olvidar que se trata de una tecnología aún en desarrollo y que no posee todas las funcionalidades que seguramente incorporará más adelante.&lt;/p&gt;

&lt;p&gt;Por mi parte, no tengo ninguna duda de que en el futuro se convertirá en una gran alternativa y un software utilizado por muchos usuarios.&lt;/p&gt;</content><author><name></name></author><summary type="html">A día de hoy, nos encontramos con una situación de monopolio absoluto en el mundo de las VPN, liderado por OpenVPN, que ya todos conoceréis, o incluso habréis trabajado con él. He mencionado el término VPN, pero ¿qué es una VPN?</summary></entry><entry><title type="html">Implantación De Aplicaciones Web Php En Docker</title><link href="https://www.javierpzh.com/blog/implantaci%C3%B3n-de-aplicaciones-web-PHP-en-Docker" rel="alternate" type="text/html" title="Implantación De Aplicaciones Web Php En Docker" /><published>2021-03-07T00:00:00+01:00</published><updated>2021-03-07T00:00:00+01:00</updated><id>https://www.javierpzh.com/blog/implantaci%C3%B3n-de-aplicaciones-web-PHP-en-Docker</id><content type="html" xml:base="https://www.javierpzh.com/blog/implantaci%C3%B3n-de-aplicaciones-web-PHP-en-Docker">&lt;p&gt;En este artículo voy a realizar el despliegue de varias aplicaciones web escritas en &lt;strong&gt;PHP&lt;/strong&gt; en contenedores &lt;strong&gt;Docker&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Todos los ficheros necesarios y utilizados, se pueden encontrar en &lt;a href=&quot;https://github.com/javierpzh/Implantacion-de-aplicaciones-web-PHP-en-Docker&quot;&gt;este repositorio&lt;/a&gt; de &lt;em&gt;GitHub&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;En todos los apartados utilizaremos dos directorios, el llamado &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build&lt;/code&gt;, destinado a la construcción, y el segundo directorio, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deploy&lt;/code&gt;, utilizado para el despliegue.&lt;/p&gt;

&lt;h4 id=&quot;ejecución-de-la-aplicación-bookmedik&quot;&gt;Ejecución de la aplicación BookMedik&lt;/h4&gt;

&lt;p&gt;En este primer apartado, vamos a ver como sería el proceso para ejecutar la aplicación &lt;strong&gt;BookMedik&lt;/strong&gt; en contenedores &lt;em&gt;Docker&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;En primer lugar, nos situamos en el directorio &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build&lt;/code&gt; y en él, clonaremos el siguiente &lt;a href=&quot;https://github.com/evilnapsis/bookmedik&quot;&gt;repositorio&lt;/a&gt; que contiene la aplicación &lt;strong&gt;BookMedik&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Hecho esto, nos dirigiremos a nuestro directorio de despliegue, y en él crearemos nuestro fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose.yaml&lt;/code&gt;, que inicialmente va a poseer este contenido:&lt;/p&gt;

&lt;pre&gt;
version: &quot;3.1&quot;

services:

  db:
    container_name: bookmedik-mysql
    image: mariadb
    restart: always
    environment:
      MYSQL_DATABASE: bookmedik
      MYSQL_USER: bookmedik
      MYSQL_PASSWORD: bookmedik
      MYSQL_ROOT_PASSWORD: javier
    volumes:
      - /home/javier/Docker/Volumes:/var/lib/mysql
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar como hemos definido el despliegue de un contenedor llamado &lt;strong&gt;bookmedik-mysql&lt;/strong&gt; basado en una imagen &lt;strong&gt;mariadb&lt;/strong&gt;. Como podremos imaginar, este contenedor será el encargado de ejecutar nuestra base de datos. Vamos a crearlo ejecutando el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea1/deploy$ docker-compose up -d
Creating bookmedik-mysql ... done
&lt;/pre&gt;

&lt;p&gt;Bien, ya habríamos generado nuestro primer contenedor, ahora, necesitaremos ejecutar el siguiente &lt;em&gt;script&lt;/em&gt; que se encargará de crear las tablas/datos imprescindibles para nuestra aplicación. Este &lt;em&gt;script&lt;/em&gt; se encuentra dentro del repositorio clonado anteriormente y recibe el nombre &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;schema.sql&lt;/code&gt;. Antes de volcar las instrucciones en nuestra base de datos, debemos comentar la siguiente línea que se encuentra al inicio de este &lt;em&gt;script&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
create database bookmedik;
&lt;/pre&gt;

&lt;p&gt;Esto debemos hacerlo, ya que, al crear el primer contenedor que ejecuta &lt;em&gt;MySQL&lt;/em&gt;, ya hemos creado una base de datos con este nombre.&lt;/p&gt;

&lt;p&gt;Hecho esto, podríamos ejecutar el &lt;em&gt;script&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea1/deploy$ cat ../build/bookmedik/schema.sql | docker exec -i bookmedik-mysql /usr/bin/mysql -u bookmedik --password=bookmedik bookmedik
&lt;/pre&gt;

&lt;p&gt;En este punto, ya disponemos de nuestra base de datos totalmente operativa, por lo que tan sólo nos faltaría crear el contenedor que ejecutará la aplicación. Para ello, crearemos en el directorio &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build&lt;/code&gt;, el siguiente fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;
FROM debian
MAINTAINER Javier Pérez &quot;javierperezhidalgo01@gmail.com&quot;

EXPOSE 80

ADD bookmedik /var/www/html/
ADD script.sh /usr/local/bin/

RUN apt-get update &amp;amp;&amp;amp; apt-get install -y apache2 \
libapache2-mod-php7.3 \
php7.3 \
php7.3-mysql \
&amp;amp;&amp;amp; apt-get clean \
&amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/* \
&amp;amp;&amp;amp; chmod +x /usr/local/bin/script.sh

ENV DATABASE_USER bookmedik
ENV DATABASE_PASSWORD bookmedik
ENV DATABASE_HOST db

ENTRYPOINT [&quot;script.sh&quot;]
&lt;/pre&gt;

&lt;p&gt;Por último, en la misma ruta, crearemos un fichero llamado &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;script.sh&lt;/code&gt; con las siguientes líneas:&lt;/p&gt;

&lt;pre&gt;
#!/bin/bash

sed -i 's/$this-&amp;gt;user=&quot;root&quot;;/$this-&amp;gt;user=&quot;'${DATABASE_USER}'&quot;;/g' /var/www/html/core/controller/Database.php
sed -i 's/$this-&amp;gt;pass=&quot;&quot;;/$this-&amp;gt;pass=&quot;'${DATABASE_PASSWORD}'&quot;;/g' /var/www/html/core/controller/Database.php
sed -i 's/$this-&amp;gt;host=&quot;localhost&quot;;/$this-&amp;gt;host=&quot;'${DATABASE_HOST}'&quot;;/g' /var/www/html/core/controller/Database.php

apache2ctl -D FOREGROUND
&lt;/pre&gt;

&lt;p&gt;Esto nos ayudará a la hora de la asignación de variables.&lt;/p&gt;

&lt;p&gt;Pues ya estaría todo listo, por lo que procederíamos a crear la imagen que posteriormente ejecutará el contenedor de la aplicación:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea1/build$ docker build -t javierpzh/bookmedik:v1 .
Sending build context to Docker daemon  5.774MB
Step 1/10 : FROM debian
 ---&amp;gt; 5890f8ba95f6
Step 2/10 : MAINTAINER Javier Pérez &quot;javierperezhidalgo01@gmail.com&quot;
 ---&amp;gt; Running in 597b0e74a1af
Removing intermediate container 597b0e74a1af
 ---&amp;gt; 2bd74e1c46ca
Step 3/10 : EXPOSE 80
 ---&amp;gt; Running in a626d30acc3a
Removing intermediate container a626d30acc3a
 ---&amp;gt; d5e3b4c5a31a
Step 4/10 : ADD bookmedik /var/www/html/
 ---&amp;gt; e3d721661a67
Step 5/10 : ADD script.sh /usr/local/bin/
 ---&amp;gt; 77688c1696ce
Step 6/10 : RUN apt-get update &amp;amp;&amp;amp; apt-get install -y apache2 libapache2-mod-php7.3 php7.3 php7.3-mysql &amp;amp;&amp;amp; apt-get clean &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/* &amp;amp;&amp;amp; chmod +x /usr/local/bin/script.sh
 ---&amp;gt; Running in 5c9ea292ceb8

 ...

 ---&amp;gt; 217f10aad8e5
Step 7/10 : ENV DATABASE_USER bookmedik
 ---&amp;gt; Running in 33177718555b
Removing intermediate container 33177718555b
 ---&amp;gt; 5c1d72d0d8f7
Step 8/10 : ENV DATABASE_PASSWORD bookmedik
 ---&amp;gt; Running in a81a444faa65
Removing intermediate container a81a444faa65
 ---&amp;gt; e50d8477e7ae
Step 9/10 : ENV DATABASE_HOST db
 ---&amp;gt; Running in 6d5caa1033d8
Removing intermediate container 6d5caa1033d8
 ---&amp;gt; 7a385cbb8132
Step 10/10 : ENTRYPOINT [&quot;script.sh&quot;]
 ---&amp;gt; Running in 4b6348f07a94
Removing intermediate container 4b6348f07a94
 ---&amp;gt; 58e4b5c7dcee
Successfully built 58e4b5c7dcee
Successfully tagged javierpzh/bookmedik:v1
&lt;/pre&gt;

&lt;p&gt;Finalizado el proceso, vamos a ver que efectivamente nos ha creado la nueva imagen:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea1/build$ docker images
REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE
javierpzh/bookmedik   v1                  58e4b5c7dcee        33 seconds ago      251MB
&lt;/pre&gt;

&lt;p&gt;¡Bien! Disponemos de la nueva imagen, por lo que tan sólo nos quedaría crear el contenedor que ejecutará &lt;em&gt;BookMedik&lt;/em&gt;. Para ello, añadiremos al fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose.yaml&lt;/code&gt;, que creamos anteriormente en el directorio &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deploy&lt;/code&gt;, el siguiente bloque:&lt;/p&gt;

&lt;pre&gt;
  bookmedik:
    container_name: bookmedik
    image: javierpzh/bookmedik:v1
    restart: always
    ports:
      - 8080:80
    volumes:
      - /home/javier/Docker/Volumes:/var/log/apache2
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar como hemos definido un nuevo despliegue, en este caso, se trata de un contenedor llamado &lt;strong&gt;bookmedik&lt;/strong&gt; basado en la imagen creada, y que va a &lt;em&gt;mapear&lt;/em&gt; puertos para que podamos acceder desde nuestro navegador en el puerto 8080. Vamos a crearlo ejecutando el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea1/deploy$ docker-compose up -d
Creating bookmedik ...
Creating bookmedik ... done
&lt;/pre&gt;

&lt;p&gt;Bien, ya habríamos generado nuestro segundo contenedor, por lo que, en teoría, ya dispondríamos de nuestra aplicación. Antes de dirigirnos a nuestro navegador, vamos a listar los contenedores que poseemos activos:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea1/deploy$ docker ps
CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                  NAMES
5dc207e7d56a        javierpzh/bookmedik:v1   &quot;script.sh&quot;              35 seconds ago      Up 33 seconds       0.0.0.0:8080-&amp;gt;80/tcp   bookmedik
aef84a1160f0        mariadb                  &quot;docker-entrypoint.s…&quot;   5 minutes ago       Up 5 minutes        3306/tcp               bookmedik-mysql
&lt;/pre&gt;

&lt;p&gt;Efectivamente se están ejecutando los dos contenedores, por lo que es el momento de a acceder a la dirección &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1:8080&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/iaw_implantación_de_aplicaciones_web_PHP_en_Docker/bookmedik1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Vamos a &lt;em&gt;loguearnos&lt;/em&gt; mediante las credenciales por defecto: &lt;strong&gt;admin/admin&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/iaw_implantación_de_aplicaciones_web_PHP_en_Docker/bookmedik2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;¡Bien! Vemos como nos muestra la aplicación &lt;em&gt;BookMedik&lt;/em&gt; por lo que habríamos finalizado este apartado.&lt;/p&gt;

&lt;h4 id=&quot;creando-la-imagen-de-bookmedik-a-partir-de-la-imagen-php&quot;&gt;Creando la imagen de BookMedik a partir de la imagen PHP&lt;/h4&gt;

&lt;p&gt;En este apartado, vamos a realizar un proceso parecido al anterior, pero en este caso, la imagen del contenedor que ejecutará la aplicación, estará creada a partir de la imagen oficial &lt;strong&gt;PHP&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Para llevar a cabo este ejercicio, podemos copiar las carpetas &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build&lt;/code&gt; y &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deploy&lt;/code&gt; que hemos utilizado en el apartado anterior, ya que vamos a hacer unas pequeñas modificaciones, pero gran parte será reutilizada.&lt;/p&gt;

&lt;p&gt;En primer lugar, editaremos el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;, y quedará de esta manera:&lt;/p&gt;

&lt;pre&gt;
FROM php:7.4-apache
MAINTAINER Javier Pérez &quot;javierperezhidalgo01@gmail.com&quot;

EXPOSE 80

ADD bookmedik /var/www/html/
ADD script.sh /usr/local/bin/

RUN docker-php-ext-install mysqli \
&amp;amp;&amp;amp; chmod +x /usr/local/bin/script.sh

ENV DATABASE_USER bookmedik
ENV DATABASE_PASSWORD bookmedik
ENV DATABASE_HOST db

ENTRYPOINT [&quot;script.sh&quot;]
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar como ahora utilizaremos como imagen base la oficial PHP. Hecho esto, construiremos la nueva imagen. En mi caso, le establezco como nombre la versión 2 (&lt;strong&gt;v2&lt;/strong&gt;):&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea2/build$ docker build -t javierpzh/bookmedik:v2 .
Sending build context to Docker daemon  5.774MB
Step 1/10 : FROM php:7.4-apache
7.4-apache: Pulling from library/php
45b42c59be33: Already exists
366d949cba16: Already exists
4c65628244f3: Already exists
79a8e4ec25c6: Already exists
3512b0c25baf: Already exists
a983b5b9a384: Already exists
0def93a72fb4: Already exists
b463e75d679a: Already exists
86780b697834: Already exists
7df64f4812c2: Already exists
59f175c32a30: Already exists
5363b603851d: Already exists
93fcdb189245: Already exists
Digest: sha256:e12c1c85cb4b5cd1f656368502be1f927b3d5e4c8a55960b6c0b5795a491aa6a
Status: Downloaded newer image for php:7.4-apache
 ---&amp;gt; 82e6dd286f92
Step 2/10 : MAINTAINER Javier Pérez &quot;javierperezhidalgo01@gmail.com&quot;
 ---&amp;gt; Running in d13aaa14c768
Removing intermediate container d13aaa14c768
 ---&amp;gt; af250719abe4
Step 3/10 : EXPOSE 80
 ---&amp;gt; Running in c2c5bcfa655d
Removing intermediate container c2c5bcfa655d
 ---&amp;gt; 131de1a87b20
Step 4/10 : ADD bookmedik /var/www/html/
 ---&amp;gt; 13cdcb0d4150
Step 5/10 : ADD script.sh /usr/local/bin/
 ---&amp;gt; 62204ccc0568
Step 6/10 : RUN docker-php-ext-install mysqli &amp;amp;&amp;amp; chmod +x /usr/local/bin/script.sh
 ---&amp;gt; Running in feb5c30cd507

 ...

 ---&amp;gt; 9400396eb037
Step 7/10 : ENV DATABASE_USER bookmedik
 ---&amp;gt; Running in 6d12571c3783
Removing intermediate container 6d12571c3783
 ---&amp;gt; 4f1c9ea1b416
Step 8/10 : ENV DATABASE_PASSWORD bookmedik
 ---&amp;gt; Running in 23fb39232674
Removing intermediate container 23fb39232674
 ---&amp;gt; bc299d3eacac
Step 9/10 : ENV DATABASE_HOST db
 ---&amp;gt; Running in 8828925c295b
Removing intermediate container 8828925c295b
 ---&amp;gt; 19f8b95c983d
Step 10/10 : ENTRYPOINT [&quot;script.sh&quot;]
 ---&amp;gt; Running in f9db3c9cbc9c
Removing intermediate container f9db3c9cbc9c
 ---&amp;gt; cbf2c1f07b02
Successfully built cbf2c1f07b02
Successfully tagged javierpzh/bookmedik:v2
&lt;/pre&gt;

&lt;p&gt;Finalizado el proceso, vamos a ver que efectivamente nos ha creado la nueva imagen:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea2/build$ docker images
REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE
javierpzh/bookmedik   v2                  cbf2c1f07b02        1 minute ago        420MB
javierpzh/bookmedik   v1                  58e4b5c7dcee        About an hour ago   251MB
&lt;/pre&gt;

&lt;p&gt;Vemos como nos ha creado una nueva versión de nuestra imagen, por lo que ahora, tan sólo nos quedaría modificar en el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose.yaml&lt;/code&gt;, el bloque relativo al contenedor que ejecutará &lt;em&gt;BookMedik&lt;/em&gt;, e indicar que haga uso de esta imagen. El contenido total del fichero será el siguiente:&lt;/p&gt;

&lt;pre&gt;
version: &quot;3.1&quot;

services:

  db:
    container_name: bookmedik-mysql
    image: mariadb
    restart: always
    environment:
      MYSQL_DATABASE: bookmedik
      MYSQL_USER: bookmedik
      MYSQL_PASSWORD: bookmedik
      MYSQL_ROOT_PASSWORD: javier
    volumes:
      - /home/javier/Docker/Volumes:/var/lib/mysql

  bookmedik:
    container_name: bookmedik
    image: javierpzh/bookmedik:v2
    restart: always
    ports:
      - 8080:80
    volumes:
      - /home/javier/Docker/Volumes:/var/log/apache2
&lt;/pre&gt;

&lt;p&gt;Realizamos el despliegue:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea2/deploy$ docker-compose up -d
Recreating bookmedik ...
Recreating bookmedik ... done
&lt;/pre&gt;

&lt;p&gt;Ya habríamos reconstruido el contenedor de la aplicación. Antes de dirigirnos a nuestro navegador, vamos a listar los contenedores que poseemos activos:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea2/deploy$ docker ps
CONTAINER ID        IMAGE                    COMMAND                  CREATED              STATUS              PORTS                  NAMES
fd625dd2f9f9        javierpzh/bookmedik:v2   &quot;script.sh&quot;              About a minute ago   Up About a minute   0.0.0.0:8080-&amp;gt;80/tcp   bookmedik
aef84a1160f0        mariadb                  &quot;docker-entrypoint.s…&quot;   About an hour ago    Up About an hour    3306/tcp               bookmedik-mysql
&lt;/pre&gt;

&lt;p&gt;Efectivamente se están ejecutando los dos contenedores, y podemos observar, como hemos cambiado el contenedor que ejecuta la aplicación mientras que el contenedor que ejecuta la base de datos, sigue siendo el mismo que el del apartado anterior.&lt;/p&gt;

&lt;p&gt;Es el momento de a acceder a la dirección &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1:8080&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/iaw_implantación_de_aplicaciones_web_PHP_en_Docker/phpbookmedik1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Vamos a &lt;em&gt;loguearnos&lt;/em&gt; mediante las credenciales por defecto: &lt;strong&gt;admin/admin&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/iaw_implantación_de_aplicaciones_web_PHP_en_Docker/phpbookmedik2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;¡Bien! Vemos como nos sigue mostrando la aplicación &lt;em&gt;BookMedik&lt;/em&gt;, pero ahora está ejecutándose en un contenedor creado a partir de una imagen distinta, en esta caso, la oficial de PHP.&lt;/p&gt;

&lt;h4 id=&quot;ejecución-de-la-aplicación-bookmedik-en-nginx&quot;&gt;Ejecución de la aplicación BookMedik en Nginx&lt;/h4&gt;

&lt;p&gt;En este tercer apartado vamos a ver como volver a desplegar la aplicación &lt;strong&gt;BookMedik&lt;/strong&gt; con &lt;em&gt;Docker&lt;/em&gt;, pero esta vez, utilizando tres contenedores:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;bookmedik-mysql:&lt;/strong&gt; contenedor basado en una imagen &lt;em&gt;mariadb&lt;/em&gt;, que como ya se puede intuir ejecutará nuestra base de datos.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;nginx:&lt;/strong&gt; contenedor basado en una imagen personalizada, basada en una imagen &lt;em&gt;nginx&lt;/em&gt;, que ejecutará la aplicación.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;bookmedik-php:&lt;/strong&gt; contenedor basado en una imagen &lt;em&gt;PHP&lt;/em&gt;, que ejecutará el servidor &lt;em&gt;PHP-FPM&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;El “escenario” sobre el que trabajaremos es algo así:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea3$ ls -l
total 0
drwxr-xr-x 3 javier javier 78 mar  7 00:15 build-nginx
drwxr-xr-x 2 javier javier 24 mar  7 00:01 build-php
drwxr-xr-x 2 javier javier 33 mar  7 00:15 deploy
&lt;/pre&gt;

&lt;p&gt;En primer lugar, nos situamos en el directorio &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build-nginx&lt;/code&gt;, ya que en él, es donde realizaremos la mayor parte del trabajo, ya que poseemos tres ficheros además del &lt;a href=&quot;https://github.com/evilnapsis/bookmedik&quot;&gt;repositorio&lt;/a&gt; de la aplicación:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea3/build-nginx$ ls -l
total 12
drwxr-xr-x 7 javier javier 166 mar  6 19:41 bookmedik
-rw-r--r-- 1 javier javier 514 mar  7 00:02 default.conf
-rw-r--r-- 1 javier javier 336 mar  7 00:15 Dockerfile
-rw-r--r-- 1 javier javier 387 mar  7 00:15 script.sh
&lt;/pre&gt;

&lt;p&gt;Vamos a empezar viendo el aspecto del fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;
FROM nginx
MAINTAINER Javier Pérez &quot;javierperezhidalgo01@gmail.com&quot;

EXPOSE 80

ADD default.conf /etc/nginx/conf.d/default.conf
ADD script.sh /usr/local/bin/

RUN chmod +x /usr/local/bin/script.sh

ENV DATABASE_USER bookmedik
ENV DATABASE_PASSWORD bookmedik
ENV DATABASE_HOST db

ENTRYPOINT [&quot;script.sh&quot;]
&lt;/pre&gt;

&lt;p&gt;Seguiremos con el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;script.sh&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;
#!/bin/bash

sed -i &quot;s/$this-&amp;gt;user=&quot;root&quot;;/$this-&amp;gt;user=&quot;$DATABASE_USER&quot;;/g&quot; /bookmedik/core/controller/Database.php
sed -i &quot;s/$this-&amp;gt;pass=&quot;&quot;;/$this-&amp;gt;pass=&quot;$DATABASE_PASSWORD&quot;;/g&quot; /bookmedik/core/controller/Database.php
sed -i &quot;s/$this-&amp;gt;host=&quot;localhost&quot;;/$this-&amp;gt;host=&quot;$DATABASE_HOST&quot;;/g&quot; /bookmedik/core/controller/Database.php

nginx -g 'daemon off;'
&lt;/pre&gt;

&lt;p&gt;Y para finalizar, el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default.conf&lt;/code&gt; que será el fichero de configuración de nuestro &lt;em&gt;virtualhost&lt;/em&gt; de &lt;em&gt;Nginx&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
server {
    index index.php index.html;
    server_name www.bookmedik.com;
    error_log  /var/log/nginx/error.log;
    access_log /var/log/nginx/access.log;
    root /bookmedik;

    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass php:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
}
&lt;/pre&gt;

&lt;p&gt;Visto todo el contenido del directorio &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build-nginx&lt;/code&gt;, procederemos a crear la imagen:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea3/build-nginx$ docker build -t javierpzh/nginx:v1 .
Sending build context to Docker daemon  5.775MB
Step 1/10 : FROM nginx
 ---&amp;gt; 35c43ace9216
Step 2/10 : MAINTAINER Javier Pérez &quot;javierperezhidalgo01@gmail.com&quot;
 ---&amp;gt; Running in b3fed2b62aa9
Removing intermediate container b3fed2b62aa9
 ---&amp;gt; 58c5819c8161
Step 3/10 : EXPOSE 80
 ---&amp;gt; Running in fb032eabf6bf
Removing intermediate container fb032eabf6bf
 ---&amp;gt; f6d8519513c1
Step 4/10 : ADD default.conf /etc/nginx/conf.d/default.conf
 ---&amp;gt; 3db249b151cf
Step 5/10 : ADD script.sh /usr/local/bin/
 ---&amp;gt; 40bd15c1b5c9
Step 6/10 : RUN chmod +x /usr/local/bin/script.sh
 ---&amp;gt; Running in 08c8bbd4a4e5
Removing intermediate container 08c8bbd4a4e5
 ---&amp;gt; 67da303c3bf2
Step 7/10 : ENV DATABASE_USER bookmedik
 ---&amp;gt; Running in 0d4bb6c08356
Removing intermediate container 0d4bb6c08356
 ---&amp;gt; ccd372739104
Step 8/10 : ENV DATABASE_PASSWORD bookmedik
 ---&amp;gt; Running in 188eee28ffe8
Removing intermediate container 188eee28ffe8
 ---&amp;gt; 35dc8e23b27d
Step 9/10 : ENV DATABASE_HOST db
 ---&amp;gt; Running in 2475c18ea322
Removing intermediate container 2475c18ea322
 ---&amp;gt; 430ae7eb838f
Step 10/10 : ENTRYPOINT [&quot;script.sh&quot;]
 ---&amp;gt; Running in 5d6b4466a190
Removing intermediate container 5d6b4466a190
 ---&amp;gt; 8f6aa9a30207
Successfully built 8f6aa9a30207
Successfully tagged javierpzh/nginx:v1
&lt;/pre&gt;

&lt;p&gt;En el directorio &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build-php&lt;/code&gt; solo nos encontraremos con el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;, que posee este aspecto:&lt;/p&gt;

&lt;pre&gt;
FROM php:7.4-apache
MAINTAINER Javier Pérez &quot;javierperezhidalgo01@gmail.com&quot;

RUN docker-php-ext-install mysqli
&lt;/pre&gt;

&lt;p&gt;Construimos la nueva imagen:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea3/build-php$ docker build -t javierpzh/php-fpm:v1 .
Sending build context to Docker daemon  2.048kB
Step 1/3 : FROM php:7.4-apache
 ---&amp;gt; 82e6dd286f92
Step 2/3 : MAINTAINER Javier Pérez &quot;javierperezhidalgo01@gmail.com&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; af250719abe4
Step 3/3 : RUN docker-php-ext-install mysqli
 ---&amp;gt; Running in 4175235d4ec5

 ...

 ---&amp;gt; e34648669ee1
Successfully built e34648669ee1
Successfully tagged javierpzh/php-fpm:v1
&lt;/pre&gt;

&lt;p&gt;En este punto, ya tendríamos las imágenes necesarias para poner en marcha nuestra aplicación, por lo que nos trasladamos al directorio &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deploy&lt;/code&gt; y creamos el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker.compose.yaml&lt;/code&gt; que definirá el escenario:&lt;/p&gt;

&lt;pre&gt;
version: &quot;3.1&quot;

services:

  db:
    container_name: bookmedik-mysql
    image: mariadb
    restart: always
    environment:
      MYSQL_DATABASE: bookmedik
      MYSQL_USER: bookmedik
      MYSQL_PASSWORD: bookmedik
      MYSQL_ROOT_PASSWORD: javier
    volumes:
      - /home/javier/Docker/Volumes:/var/lib/mysql

  bookmedik:
    container_name: bookmedik
    image: javierpzh/nginx:v1
    restart: always
    ports:
      - 8080:80
    volumes:
      - /home/javier/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea3/build-nginx/bookmedik/:/bookmedik

  php:
    container_name: bookmedik-php
    image: javierpzh/php-fpm:v1
    restart: always
    volumes:
      - /home/javier/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea3/build-nginx/bookmedik/:/bookmedik
&lt;/pre&gt;

&lt;p&gt;Una vez creado, desplegamos los contenedores:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea3/deploy$ docker-compose up -d
bookmedik-mysql is up-to-date
Recreating bookmedik   ... done
Creating bookmedik-php ... done
&lt;/pre&gt;

&lt;p&gt;Es el momento de a acceder a la dirección &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1:8080&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/iaw_implantación_de_aplicaciones_web_PHP_en_Docker/403.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Aún no he conseguido solventar este problema.&lt;/p&gt;

&lt;h4 id=&quot;ejecución-del-cms-prestashop&quot;&gt;Ejecución del CMS Prestashop&lt;/h4&gt;

&lt;p&gt;En este nuevo apartado vamos a llevar a cabo el despliegue del CMS PHP llamado &lt;strong&gt;Prestashop&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Como consecuencia, poseeremos dos contenedores, uno que ejecutará la base de datos, y otro que ejecutará la aplicación. Este último estará basado en una imagen personalizada, que vamos a crear a partir de la imagen oficial PHP.&lt;/p&gt;

&lt;p&gt;Para ello, en nuestro directorio &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build&lt;/code&gt; generaremos el siguiente fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;
FROM php:7.4-apache
MAINTAINER Javier Pérez &quot;javierperezhidalgo01@gmail.com&quot;

EXPOSE 80

WORKDIR /var/www/html/

ADD script.sh /usr/local/bin/

RUN apt-get update \
&amp;amp;&amp;amp; apt-get -y install \
unzip wget \
zlib1g-dev libzip-dev libicu-dev libpng-dev \
&amp;amp;&amp;amp; wget https://download.prestashop.com/download/releases/prestashop_1.7.7.2.zip -P /opt/ \
&amp;amp;&amp;amp; docker-php-ext-install zip gd pdo_mysql intl \
&amp;amp;&amp;amp; apt-get clean \
&amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/* \
&amp;amp;&amp;amp; a2enmod rewrite \
&amp;amp;&amp;amp; chmod +x /usr/local/bin/script.sh

ENTRYPOINT [&quot;script.sh&quot;]
&lt;/pre&gt;

&lt;p&gt;También debemos crear el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;script.sh&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;
#!/bin/bash

mv /opt/prestashop_1.7.7.2.zip /var/www/html/
unzip prestashop_1.7.7.2.zip
unzip -o prestashop.zip
rm -rf prestashop.zip prestashop_1.7.7.2.zip
chown -R www-data:www-data /var/www/html

apache2ctl -D FOREGROUND
&lt;/pre&gt;

&lt;p&gt;Una vez poseemos ambos archivos, es hora de construir la imagen que utilizará el contenedor de nuestra aplicación:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea4/build$ docker build -t javierpzh/prestashop:v1 .
Sending build context to Docker daemon  3.584kB
Step 1/7 : FROM php:7.4-apache
 ---&amp;gt; 82e6dd286f92
Step 2/7 : MAINTAINER Javier Pérez &quot;javierperezhidalgo01@gmail.com&quot;
 ---&amp;gt; Using cache
 ---&amp;gt; af250719abe4
Step 3/7 : EXPOSE 80
 ---&amp;gt; Using cache
 ---&amp;gt; 131de1a87b20
Step 4/7 : WORKDIR /var/www/html/
 ---&amp;gt; Running in 52f2af2bc8d6
Removing intermediate container 52f2af2bc8d6
 ---&amp;gt; 2f03fc19c53d
Step 5/7 : ADD script.sh /usr/local/bin/
 ---&amp;gt; 00800fe4c3a3
Step 6/7 : RUN apt-get update &amp;amp;&amp;amp; apt-get -y install unzip wget zlib1g-dev libzip-dev libicu-dev libpng-dev &amp;amp;&amp;amp; wget https://download.prestashop.com/download/releases/prestashop_1.7.7.2.zip -P /opt/ &amp;amp;&amp;amp; docker-php-ext-install zip gd pdo_mysql intl &amp;amp;&amp;amp; apt-get clean &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/* &amp;amp;&amp;amp; a2enmod rewrite &amp;amp;&amp;amp; chmod +x /usr/local/bin/script.sh
 ---&amp;gt; Running in bffe857f3412

 ...

 ---&amp;gt; 2f9eb9bb9d47
Step 7/7 : ENTRYPOINT [&quot;script.sh&quot;]
 ---&amp;gt; Running in 091a0d754fdf
Removing intermediate container 091a0d754fdf
 ---&amp;gt; bfbc6637a891
Successfully built bfbc6637a891
Successfully tagged javierpzh/prestashop:v1
&lt;/pre&gt;

&lt;p&gt;Finalizada la construcción de la imagen, nos situaremos en el directorio &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deploy&lt;/code&gt; y generaremos el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose.yaml&lt;/code&gt; que será el encargado de crear los distintos contenedores:&lt;/p&gt;

&lt;pre&gt;
version: &quot;3.1&quot;

services:

  db:
    container_name: prestashop-mysql
    image: mariadb
    restart: always
    environment:
      MYSQL_DATABASE: prestashop
      MYSQL_USER: prestashop
      MYSQL_PASSWORD: prestashop
      MYSQL_ROOT_PASSWORD: javier
    volumes:
      - /home/javier/Docker/Volumes/tarea4/db:/var/lib/mysql

  prestashop:
    container_name: prestashop
    image: javierpzh/prestashop:v1
    restart: always
    ports:
      - 8080:80
    volumes:
      - /home/javier/Docker/Volumes/tarea4/app:/var/www/html
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar en él, como también lo hemos configurado, para que la información de nuestra aplicación sea persistente, es decir, que no se pierda a la hora de destruir los contenedores.&lt;/p&gt;

&lt;p&gt;Hecho esto, ya podemos construir los contenedores:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea4/deploy$ docker-compose up -d
Creating prestashop-mysql ... done
Creating prestashop       ... done
&lt;/pre&gt;

&lt;p&gt;Es el momento de a acceder a la dirección &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1:8080&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/iaw_implantación_de_aplicaciones_web_PHP_en_Docker/prestashop1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Podemos ver como nos muestra el instalador de &lt;em&gt;Prestashop&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Conectamos la aplicación al contenedor que se encuentra ejecutando la base de datos:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/iaw_implantación_de_aplicaciones_web_PHP_en_Docker/prestashop2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Y terminada la instalación, podremos ver nuestro CMS listo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/iaw_implantación_de_aplicaciones_web_PHP_en_Docker/prestashop3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/iaw_implantación_de_aplicaciones_web_PHP_en_Docker/prestashop4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Para finalizar, vamos a destruir los contenedores y los volveremos a generar, para ver como seguimos poseyendo la información:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea4/deploy$ docker rm -f prestashop prestashop-mysql
prestashop
prestashop-mysql

javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea4/deploy$ docker-compose up -d
Creating prestashop-mysql ... done
Creating prestashop       ... done
&lt;/pre&gt;

&lt;p&gt;Accedemos de nuevo a la dirección &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1:8080&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/iaw_implantación_de_aplicaciones_web_PHP_en_Docker/prestashop5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/iaw_implantación_de_aplicaciones_web_PHP_en_Docker/prestashop4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;¡Bien! Podemos ver como nuestra aplicación sigue manteniendo los datos de nuestra tienda, por lo que habría terminado el proceso.&lt;/p&gt;

&lt;h4 id=&quot;ejecución-del-cms-drupal-a-partir-de-su-imagen-oficial&quot;&gt;Ejecución del CMS Drupal a partir de su imagen oficial&lt;/h4&gt;

&lt;p&gt;En este último apartado vamos a ver como desplegar el CMS PHP llamado &lt;strong&gt;Drupal&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Poseeremos dos contenedores, uno que ejecutará la base de datos, y otro en el que se ejecutará la aplicación. Este último estará basado en la imagen oficial de &lt;em&gt;Drupal&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Para ello, en nuestro directorio &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deploy&lt;/code&gt; generaremos el siguiente fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose.yaml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;
version: &quot;3.1&quot;

services:

  db:
    container_name: drupal-mysql
    image: mariadb
    restart: always
    environment:
      MYSQL_DATABASE: drupal
      MYSQL_USER: drupal
      MYSQL_PASSWORD: drupal
      MYSQL_ROOT_PASSWORD: javier
    volumes:
      - /home/javier/Docker/Volumes/tarea5/drupal/db:/var/lib/mysql

  drupal:
    container_name: drupal
    image: drupal
    restart: always
    ports:
      - 8080:80
    volumes:
      - /var/www/html/modules
      - /var/www/html/profiles
      - /var/www/html/themes
      - /var/www/html/sites
&lt;/pre&gt;

&lt;p&gt;Una vez creado el fichero, podríamos desplegar nuestro escenario y por tanto, crear nuestros contenedores.&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Docker/Implantacion-de-aplicaciones-web-PHP-en-Docker/Tarea5/deploy$ docker-compose up -d
Pulling drupal (drupal:)...
latest: Pulling from library/drupal
45b42c59be33: Already exists
366d949cba16: Already exists
4c65628244f3: Already exists
79a8e4ec25c6: Already exists
3512b0c25baf: Already exists
a983b5b9a384: Already exists
0def93a72fb4: Already exists
8b8bec9fa383: Pull complete
80713ac3f2c7: Pull complete
549982e9dd23: Pull complete
6d487548f700: Pull complete
ee1dd2a59f0a: Pull complete
a92ec02c1897: Pull complete
a880c8e72363: Pull complete
49a0baa978da: Pull complete
f15ffc6b3e10: Pull complete
7317421d31fe: Pull complete
e3f350043ad2: Pull complete
Digest: sha256:347d566bb770c27dabc8de84f7d9996157e9f9e26fd84ca1637df59ec24b12e1
Status: Downloaded newer image for drupal:latest
Creating drupal       ... done
Creating drupal-mysql ... done
&lt;/pre&gt;

&lt;p&gt;Es el momento de a acceder a la dirección &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1:8080&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/iaw_implantación_de_aplicaciones_web_PHP_en_Docker/drupal1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Podemos ver como nos muestra el instalador de &lt;em&gt;Drupal&lt;/em&gt;, por lo que continuamos el proceso indicando las credenciales de nuestra base de datos:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/iaw_implantación_de_aplicaciones_web_PHP_en_Docker/drupal2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Esperamos que terminen de instalarse los distintos componentes de &lt;em&gt;Drupal&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/iaw_implantación_de_aplicaciones_web_PHP_en_Docker/drupal3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Y terminada la instalación, ya podríamos disfruta de nuestro CMS:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/iaw_implantación_de_aplicaciones_web_PHP_en_Docker/drupal4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;¡Bien! Ya habríamos terminado de desplegar &lt;em&gt;Drupal&lt;/em&gt; en contenedores &lt;em&gt;Docker&lt;/em&gt;, y con ello este apartado y también el &lt;em&gt;post&lt;/em&gt; en sí.&lt;/p&gt;</content><author><name></name></author><summary type="html">En este artículo voy a realizar el despliegue de varias aplicaciones web escritas en PHP en contenedores Docker.</summary></entry><entry><title type="html">Despliegue De Un Cluster De Kubernetes</title><link href="https://www.javierpzh.com/blog/despliegue-de-un-cluster-de-kubernetes" rel="alternate" type="text/html" title="Despliegue De Un Cluster De Kubernetes" /><published>2021-03-06T00:00:00+01:00</published><updated>2021-03-06T00:00:00+01:00</updated><id>https://www.javierpzh.com/blog/despliegue-de-un-cluster-de-kubernetes</id><content type="html" xml:base="https://www.javierpzh.com/blog/despliegue-de-un-cluster-de-kubernetes">&lt;p&gt;En este artículo vamos a crear un &lt;strong&gt;cluster de Kubernetes (k8s)&lt;/strong&gt; y para ello he decidido utilizar la distribución &lt;strong&gt;k3s&lt;/strong&gt;. Posteriormente, desplegaremos la aplicación &lt;strong&gt;Let’s Chat&lt;/strong&gt; en él.&lt;/p&gt;

&lt;p&gt;Todo el proceso se llevará a cabo en varias instancias de &lt;em&gt;OpenStack&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;controlador:&lt;/strong&gt; máquina que controlará el &lt;em&gt;cluster&lt;/em&gt;. Posee la dirección IP 172.22.201.59&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;worker1:&lt;/strong&gt; máquina que actuará como &lt;em&gt;worker&lt;/em&gt;. Posee la dirección IP 172.22.201.69&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;worker2:&lt;/strong&gt; máquina que actuará como &lt;em&gt;worker&lt;/em&gt;. Posee la dirección IP 172.22.201.79&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;qué-es-k3s&quot;&gt;¿Qué es k3s?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;k3s&lt;/strong&gt; es una distribución de &lt;em&gt;Kubernetes&lt;/em&gt;, desarrollada por Rancher Labs, muy ligera y muy fácil de instalar, que requiere pocos requisitos y un uso de memoria mínimo.&lt;/p&gt;

&lt;p&gt;Para el planteamiento de un entorno de desarrollo, esto se convierte en una gran mejora sobre lo que hemos hablado anteriormente en &lt;em&gt;Kubernetes&lt;/em&gt;; crear un entorno mínimo para desarrollo, donde la creación del entorno es compleja y requiere de muchos recursos, aunque sea &lt;em&gt;Ansible&lt;/em&gt; el que realice el trabajo difícil.&lt;/p&gt;

&lt;p&gt;Entre las herramientas que nos proporciona se incluye &lt;strong&gt;kubectl&lt;/strong&gt;. Esta herramienta, es una interfaz de línea de comandos desarrollada en &lt;em&gt;Go&lt;/em&gt; para gestionar nuestros &lt;em&gt;clusters&lt;/em&gt; de manera centralizada.&lt;/p&gt;

&lt;p&gt;A continuación podemos ver un diagrama acerca de la estructura interna de &lt;em&gt;k3s&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/hlc_despliegue_de_un_cluster_de_kubernetes/estructurainterna.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;instalación-de-k3s-en-el-controlador&quot;&gt;Instalación de k3s en el controlador&lt;/h2&gt;

&lt;p&gt;Para llevar a cabo la instalación del &lt;em&gt;software&lt;/em&gt; de &lt;strong&gt;k3s&lt;/strong&gt;, vamos a utilizar el &lt;em&gt;script&lt;/em&gt; de instalación que se nos proporciona. Para ello, necesitaremos la herramienta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;curl&lt;/code&gt; en nuestro sistema, así que vamos a instalarla:&lt;/p&gt;

&lt;pre&gt;
apt install curl -y
&lt;/pre&gt;

&lt;p&gt;Una vez instalada, procederemos a la descarga del propio &lt;em&gt;software&lt;/em&gt; ejecutando el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
root@controlador:~# curl -sfL https://get.k3s.io | sh -
[INFO]  Finding release for channel stable
[INFO]  Using v1.20.4+k3s1 as release
[INFO]  Downloading hash https://github.com/k3s-io/k3s/releases/download/v1.20.4+k3s1/sha256sum-amd64.txt
[INFO]  Downloading binary https://github.com/k3s-io/k3s/releases/download/v1.20.4+k3s1/k3s
[INFO]  Verifying binary download
[INFO]  Installing k3s to /usr/local/bin/k3s
[INFO]  Creating /usr/local/bin/kubectl symlink to k3s
[INFO]  Creating /usr/local/bin/crictl symlink to k3s
[INFO]  Creating /usr/local/bin/ctr symlink to k3s
[INFO]  Creating killall script /usr/local/bin/k3s-killall.sh
[INFO]  Creating uninstall script /usr/local/bin/k3s-uninstall.sh
[INFO]  env: Creating environment file /etc/systemd/system/k3s.service.env
[INFO]  systemd: Creating service file /etc/systemd/system/k3s.service
[INFO]  systemd: Enabling k3s unit
Created symlink /etc/systemd/system/multi-user.target.wants/k3s.service → /etc/systemd/system/k3s.service.
[INFO]  systemd: Starting k3s
&lt;/pre&gt;

&lt;p&gt;Realizada la instalación, ya dispondríamos de todas las herramientas necesarias, incluyendo &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl&lt;/code&gt;. Para comprobarlo vamos a listar los nodos existentes en el &lt;em&gt;cluster&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
root@controlador:~# kubectl get nodes
NAME          STATUS   ROLES                  AGE    VERSION
controlador   Ready    control-plane,master   113s   v1.20.4+k3s1
&lt;/pre&gt;

&lt;p&gt;Lógicamente tan sólo nos muestra uno, que hace referencia al propio nodo que acabamos de instalar, ya que aún no hemos asociado ningún &lt;em&gt;worker&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Es el momento de vincular los &lt;em&gt;workers&lt;/em&gt;, para ello, necesitaremos conocer el &lt;em&gt;token&lt;/em&gt; del nodo maestro. Para conocer dicho &lt;em&gt;token&lt;/em&gt; ejecutamos el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
root@controlador:~# cat /var/lib/rancher/k3s/server/node-token
K10615847e0f0430ed497fa0037489ba29d2fe2c5b173632e0541e5a47ba23f0fc5::server:55221794658ca3660af7a2f3f80c93af
&lt;/pre&gt;

&lt;p&gt;Hecho esto, es el momento de pasar con la instalación de &lt;em&gt;k3s&lt;/em&gt; en los &lt;em&gt;workers&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;instalación-de-k3s-en-los-workers&quot;&gt;Instalación de k3s en los workers&lt;/h2&gt;

&lt;p&gt;Para llevar a cabo la instalación del &lt;em&gt;software&lt;/em&gt; de &lt;strong&gt;k3s&lt;/strong&gt; en estas máquinas, volveremos a utilizar el &lt;em&gt;script&lt;/em&gt; de instalación que se nos proporciona, pero esta vez, tendremos que indicarle dos parámetros para llevar a cabo la vinculación al nodo maestro. Dichos parámetros son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;K3S_URL:&lt;/strong&gt; indica la URL del controlador, a la que se conectará el &lt;em&gt;worker&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;K3S_TOKEN:&lt;/strong&gt; indica el &lt;em&gt;token&lt;/em&gt; del nodo maestro.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;De igual manera, volveremos a necesitar la herramienta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;curl&lt;/code&gt; en nuestro sistema, así que vamos a instalarla:&lt;/p&gt;

&lt;pre&gt;
apt install curl -y
&lt;/pre&gt;

&lt;p&gt;Llevamos a cabo las instalaciones:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;worker1&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;
root@worker1:~# curl -sfL https://get.k3s.io | K3S_URL=https://172.22.201.59:6443 K3S_TOKEN=K10615847e0f0430ed497fa0037489ba29d2fe2c5b173632e0541e5a47ba23f0fc5::server:55221794658ca3660af7a2f3f80c93af sh -
[INFO]  Finding release for channel stable
[INFO]  Using v1.20.4+k3s1 as release
[INFO]  Downloading hash https://github.com/k3s-io/k3s/releases/download/v1.20.4+k3s1/sha256sum-amd64.txt
[INFO]  Downloading binary https://github.com/k3s-io/k3s/releases/download/v1.20.4+k3s1/k3s
[INFO]  Verifying binary download
[INFO]  Installing k3s to /usr/local/bin/k3s
[INFO]  Creating /usr/local/bin/kubectl symlink to k3s
[INFO]  Creating /usr/local/bin/crictl symlink to k3s
[INFO]  Creating /usr/local/bin/ctr symlink to k3s
[INFO]  Creating killall script /usr/local/bin/k3s-killall.sh
[INFO]  Creating uninstall script /usr/local/bin/k3s-agent-uninstall.sh
[INFO]  env: Creating environment file /etc/systemd/system/k3s-agent.service.env
[INFO]  systemd: Creating service file /etc/systemd/system/k3s-agent.service
[INFO]  systemd: Enabling k3s-agent unit
Created symlink /etc/systemd/system/multi-user.target.wants/k3s-agent.service → /etc/systemd/system/k3s-agent.service.
[INFO]  systemd: Starting k3s-agent
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;worker2&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;
root@worker2:~# curl -sfL https://get.k3s.io | K3S_URL=https://172.22.201.59:6443 K3S_TOKEN=K10615847e0f0430ed497fa0037489ba29d2fe2c5b173632e0541e5a47ba23f0fc5::server:55221794658ca3660af7a2f3f80c93af sh -
[INFO]  Finding release for channel stable
[INFO]  Using v1.20.4+k3s1 as release
[INFO]  Downloading hash https://github.com/k3s-io/k3s/releases/download/v1.20.4+k3s1/sha256sum-amd64.txt
[INFO]  Downloading binary https://github.com/k3s-io/k3s/releases/download/v1.20.4+k3s1/k3s
[INFO]  Verifying binary download
[INFO]  Installing k3s to /usr/local/bin/k3s
[INFO]  Creating /usr/local/bin/kubectl symlink to k3s
[INFO]  Creating /usr/local/bin/crictl symlink to k3s
[INFO]  Creating /usr/local/bin/ctr symlink to k3s
[INFO]  Creating killall script /usr/local/bin/k3s-killall.sh
[INFO]  Creating uninstall script /usr/local/bin/k3s-agent-uninstall.sh
[INFO]  env: Creating environment file /etc/systemd/system/k3s-agent.service.env
[INFO]  systemd: Creating service file /etc/systemd/system/k3s-agent.service
[INFO]  systemd: Enabling k3s-agent unit
Created symlink /etc/systemd/system/multi-user.target.wants/k3s-agent.service → /etc/systemd/system/k3s-agent.service.
[INFO]  systemd: Starting k3s-agent
&lt;/pre&gt;

&lt;p&gt;Finalizada la instalación en ambos &lt;em&gt;workers&lt;/em&gt;, vamos a listar los nodos existentes en el nodo maestro:&lt;/p&gt;

&lt;pre&gt;
root@controlador:~# kubectl get nodes
NAME          STATUS   ROLES                  AGE     VERSION
controlador   Ready    control-plane,master   8m25s   v1.20.4+k3s1
worker1       Ready    none                   81s     v1.20.4+k3s1
worker2       Ready    none                   51s     v1.20.4+k3s1
&lt;/pre&gt;

&lt;p&gt;Podemos ver como efectivamente, ahora sí nos muestra los dos &lt;em&gt;workers&lt;/em&gt; que acabamos de vincular.&lt;/p&gt;

&lt;h2 id=&quot;conectando-nuestro-cluster-a-la-máquina-anfitriona&quot;&gt;Conectando nuestro cluster a la máquina anfitriona&lt;/h2&gt;

&lt;p&gt;Una vez tenemos nuestro &lt;em&gt;cluster&lt;/em&gt; listo, vamos a configurarlo para que en vez de gestionarlo desde la máquina &lt;em&gt;controlador&lt;/em&gt;, lo podamos gestionar desde nuestra máquina anfitriona, lo cuál sería mucho más cómodo.&lt;/p&gt;

&lt;p&gt;Lo primero que debemos hacer, es instalar &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl&lt;/code&gt; en nuestra máquina anfitriona. Para hacer esto, debemos ejecutar los siguientes comandos:&lt;/p&gt;

&lt;pre&gt;
echo &quot;deb https://apt.kubernetes.io/ kubernetes-xenial main&quot; | sudo tee -a /etc/apt/sources.list.d/kubernetes.list

curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -

apt update &amp;amp;&amp;amp; apt install kubectl -y
&lt;/pre&gt;

&lt;p&gt;Una vez disponemos de la herramienta, vamos a crear el directorio &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~/.kube&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;
root@debian:~# mkdir .kube
&lt;/pre&gt;

&lt;p&gt;¿Y para qué creamos este directorio? Pues porque para conectarnos a nuestro &lt;em&gt;cluster&lt;/em&gt; remotamente, necesitaremos un fichero llamado &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;config&lt;/code&gt; almacenado en esta ruta.&lt;/p&gt;

&lt;p&gt;Bien, el contenido del fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;config&lt;/code&gt; debe ser el mismo contenido que podemos encontrar en el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/rancher/k3s/k3s.yaml&lt;/code&gt; del nodo maestro de nuestro &lt;em&gt;cluster&lt;/em&gt;, por tanto copiamos dicho contenido. En mi caso queda de esta manera:&lt;/p&gt;

&lt;pre&gt;
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUJkekNDQVIyZ0F3SUJBZ0lCQURBS0JnZ3Foa2pPUFFRREFqQWpNU0V3SHdZRFZRUUREQmhyTTNNdGMyVnkKZG1WeUxXTmhRREUyTVRRNU9ESTBNRGd3SGhjTk1qRXdNekExTWpJeE16STRXaGNOTXpFd016QXpNakl4TXpJNApXakFqTVNFd0h3WURWUVFEREJock0zTXRjMlZ5ZG1WeUxXTmhRREUyTVRRNU9ESTBNRGd3V1RBVEJnY3Foa2pPClBRSUJCZ2dxaGtqT1BRTUJCd05DQUFTMUJ1amR6OEpVWHRHN0RocytDSnF4NS9YVVFkTEFSQXRqa3NiVlZuL1YKRDNtblQ4bU05RTVwOEo1M050aktUZ1NiNm91SDR5cnoyMWlLeENZa1BMZUZvMEl3UURBT0JnTlZIUThCQWY4RQpCQU1DQXFRd0R3WURWUjBUQVFIL0JBVXdBd0VCL3pBZEJnTlZIUTRFRmdRVWlIbndsZ3BSZmZ5ejhFcEk5cWorCkRSTU9WdlV3Q2dZSUtvWkl6ajBFQXdJRFNBQXdSUUlnQjIzV3JGeFU2MDJtUnZHMmNoQ3pWUmVsaHlaQ1JXMkcKaUJIWElWOE94aVFDSVFDMjJ6SVpmK2I5Z0VCZnljRkdiN1J6cklWZ3k4OWVzTmNZazh1NkdFbHREZz09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K
    server: https://127.0.0.1:6443
  name: default
contexts:
- context:
    cluster: default
    user: default
  name: default
current-context: default
kind: Config
preferences: {}
users:
- name: default
  user:
    client-certificate-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUJrakNDQVRlZ0F3SUJBZ0lJS1k0R25OMTlmSlV3Q2dZSUtvWkl6ajBFQXdJd0l6RWhNQjhHQTFVRUF3d1kKYXpOekxXTnNhV1Z1ZEMxallVQXhOakUwT1RneU5EQTRNQjRYRFRJeE1ETXdOVEl5TVRNeU9Gb1hEVEl5TURNdwpOVEl5TVRNeU9Gb3dNREVYTUJVR0ExVUVDaE1PYzNsemRHVnRPbTFoYzNSbGNuTXhGVEFUQmdOVkJBTVRESE41CmMzUmxiVHBoWkcxcGJqQlpNQk1HQnlxR1NNNDlBZ0VHQ0NxR1NNNDlBd0VIQTBJQUJJN20zRUdqWnNja3kwK1gKcENUbzFmdnIxTUwxcFBQdFZTc3I1aTFyVnMwZVlxNTlHWVZRVlRlV2FXRmZJTmJ2TWdUbVUxdWRaNUN2MWt3ZgpNbVVLekI2alNEQkdNQTRHQTFVZER3RUIvd1FFQXdJRm9EQVRCZ05WSFNVRUREQUtCZ2dyQmdFRkJRY0RBakFmCkJnTlZIU01FR0RBV2dCUkdMaS84Q2Q1NjVPVnNHNFlKZXlwVE5rd0syakFLQmdncWhrak9QUVFEQWdOSkFEQkcKQWlFQXZJMnFKbWJDSjVwSTBoMUYzUTBtclZqZm0rd2RFczA5elhVUzQySTBSVkVDSVFDWXAwcE9HT3pDVFdVVwp3VkNpYWhZM1VaNTdjeEdCY2liVFVhL0RzWGRFL3c9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQpNSUlCZGpDQ0FSMmdBd0lCQWdJQkFEQUtCZ2dxaGtqT1BRUURBakFqTVNFd0h3WURWUVFEREJock0zTXRZMnhwClpXNTBMV05oUURFMk1UUTVPREkwTURnd0hoY05NakV3TXpBMU1qSXhNekk0V2hjTk16RXdNekF6TWpJeE16STQKV2pBak1TRXdId1lEVlFRRERCaHJNM010WTJ4cFpXNTBMV05oUURFMk1UUTVPREkwTURnd1dUQVRCZ2NxaGtqTwpQUUlCQmdncWhrak9QUU1CQndOQ0FBUW04Wm1HbWJUZnBqc0dodmNKbjFvR0x5RzQ5U3ZVd01TRkozYWNwRG50Ckw5M1luZUZ2cjRabjd1RCtmOFRLSVVjc0NFa1QwSGN5cnRkRzd4U2l3VnBmbzBJd1FEQU9CZ05WSFE4QkFmOEUKQkFNQ0FxUXdEd1lEVlIwVEFRSC9CQVV3QXdFQi96QWRCZ05WSFE0RUZnUVVSaTR2L0FuZWV1VGxiQnVHQ1hzcQpVelpNQ3Rvd0NnWUlLb1pJemowRUF3SURSd0F3UkFJZ1lhMk8wUDNpa0pCaDRzSTBqNjFPYmRTRmNSRWNwVDVPCm5zVDhCUVVFWWdNQ0lHazR6emZmeU1PeXpNUkk5bGVTclVFQm1RckVxbW9OT3Y0emRkaUJGbC9HCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K
    client-key-data: LS0tLS1CRUdJTiBFQyBQUklWQVRFIEtFWS0tLS0tCk1IY0NBUUVFSURoTFl6TWZVRmhFazVaYlRHZ0NhY0JCcmlBZ1N3OXNvelpCSzMzT2ZzM01vQW9HQ0NxR1NNNDkKQXdFSG9VUURRZ0FFanViY1FhTm14eVRMVDVla0pPalYrK3ZVd3ZXazgrMVZLeXZtTFd0V3pSNWlybjBaaFZCVgpONVpwWVY4ZzF1OHlCT1pUVzUxbmtLL1dUQjh5WlFyTUhnPT0KLS0tLS1FTkQgRUMgUFJJVkFURSBLRVktLS0tLQo=
&lt;/pre&gt;

&lt;p&gt;Una vez tenemos el mismo contenido en nuestro equipo anfitrión, debemos cambiar el valor del parámetro &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;server&lt;/code&gt;, y en él establecer la dirección del nodo maestro del &lt;em&gt;cluster&lt;/em&gt;. En mi caso esta directiva quedaría tal que así:&lt;/p&gt;

&lt;pre&gt;
root@debian:~# cat .kube/config
...
    server: https://172.22.201.59:6443
...
&lt;/pre&gt;

&lt;p&gt;En teoría ya habríamos realizado toda la configuración y podríamos gestionar nuestro &lt;em&gt;cluster&lt;/em&gt; remotamente, para ello vamos a intentar los nodos existentes en él mediante el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
root@debian:~# kubectl get nodes
Unable to connect to the server: x509: certificate is valid for 10.0.0.13, 10.43.0.1, 127.0.0.1, not 172.22.201.59
&lt;/pre&gt;

&lt;p&gt;En este punto, en mi caso, me reportó un error debido a certificados x509, que logré solucionar con el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
kubectl --insecure-skip-tls-verify cluster-info dump
&lt;/pre&gt;

&lt;p&gt;Tras él, volvemos a intentar listar los nodos:&lt;/p&gt;

&lt;pre&gt;
root@debian:~# kubectl get nodes
NAME          STATUS     ROLES                  AGE   VERSION
controlador   Ready      control-plane,master   37m   v1.20.4+k3s1
worker1       Ready      none                   30m   v1.20.4+k3s1
worker2       Ready      none                   30m   v1.20.4+k3s1
&lt;/pre&gt;

&lt;p&gt;Efectivamente podemos ver los tanto el nodo maestro como los &lt;em&gt;workers&lt;/em&gt; por lo que ya podríamos gestionar nuestro &lt;em&gt;cluster&lt;/em&gt; de manera remota.&lt;/p&gt;

&lt;h2 id=&quot;desplegando-una-aplicación-en-nuestro-cluster&quot;&gt;Desplegando una aplicación en nuestro cluster&lt;/h2&gt;

&lt;p&gt;Para desplegar la aplicación &lt;strong&gt;Let’s Chat&lt;/strong&gt; utilizaremos &lt;a href=&quot;https://github.com/iesgn/kubernetes-storm&quot;&gt;este repositorio&lt;/a&gt; de &lt;em&gt;GitHub&lt;/em&gt;, que contiene todos los ficheros &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.yaml&lt;/code&gt; en los que se definen los &lt;em&gt;deployment&lt;/em&gt;, los servicios, …&lt;/p&gt;

&lt;p&gt;En primer lugar, lógicamente clonaremos dicho repositorio. Si no disponemos de la herramienta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git&lt;/code&gt;, tendremos que instalarla.&lt;/p&gt;

&lt;pre&gt;
root@debian:/home/javier/Kubernetes# git clone https://github.com/iesgn/kubernetes-storm.git
Clonando en 'kubernetes-storm'...
remote: Enumerating objects: 288, done.
remote: Counting objects: 100% (288/288), done.
remote: Compressing objects: 100% (213/213), done.
remote: Total 288 (delta 119), reused 224 (delta 60), pack-reused 0
Recibiendo objetos: 100% (288/288), 6.36 MiB | 8.71 MiB/s, listo.
Resolviendo deltas: 100% (119/119), listo.
&lt;/pre&gt;

&lt;p&gt;Cuando hayamos clonado el repositorio, tendremos que dirigirnos a la ruta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unidad3/ejemplos-3.2/ejemplo8/&lt;/code&gt; que es donde se encuentran los ficheros de esta aplicación:&lt;/p&gt;

&lt;pre&gt;
root@debian:/home/javier/Kubernetes# cd kubernetes-storm/unidad3/ejemplos-3.2/ejemplo8/

root@debian:/home/javier/Kubernetes/kubernetes-storm/unidad3/ejemplos-3.2/ejemplo8# ls -l
total 20
-rw-r--r-- 1 root root 247 mar  5 20:15 ingress.yaml
-rw-r--r-- 1 root root 394 mar  5 20:15 letschat-deployment.yaml
-rw-r--r-- 1 root root 177 mar  5 20:15 letschat-srv.yaml
-rw-r--r-- 1 root root 358 mar  5 20:15 mongo-deployment.yaml
-rw-r--r-- 1 root root 149 mar  5 20:15 mongo-srv.yaml
&lt;/pre&gt;

&lt;p&gt;Podemos observar que hay cinco ficheros. Dos de ellos definen los &lt;strong&gt;deployment&lt;/strong&gt; para la base de datos &lt;strong&gt;MongoDB&lt;/strong&gt; y para la propia aplicación &lt;strong&gt;Let’s Chat&lt;/strong&gt;. Otros dos nos ofrecerán los &lt;strong&gt;servicios&lt;/strong&gt; de dichos procesos. El último fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ingress.yaml&lt;/code&gt; lo veremos más adelante.&lt;/p&gt;

&lt;p&gt;En este punto, todo estaría listo para definir el primer &lt;em&gt;deployment&lt;/em&gt;, en este caso el de &lt;em&gt;MongoDB&lt;/em&gt;. Este &lt;em&gt;deployment&lt;/em&gt; tendrá como consecuencia la generación de un &lt;strong&gt;ReplicaSet&lt;/strong&gt; con un &lt;strong&gt;pod&lt;/strong&gt;, que ejecutará una imagen &lt;em&gt;mongo&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Para definir dicho &lt;em&gt;deployment&lt;/em&gt; utilizaremos el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
root@debian:/home/javier/Kubernetes/kubernetes-storm/unidad3/ejemplos-3.2/ejemplo8# kubectl apply -f mongo-deployment.yaml
deployment.apps/mongo created
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar en la salida del comando como efectivamente se ha definido dicho &lt;em&gt;deployment&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;El siguiente paso, será definir el &lt;em&gt;servicio&lt;/em&gt; de nuestra base de datos, esto nos permitirá poder acceder a ella. Ejecutamos el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
root@debian:/home/javier/Kubernetes/kubernetes-storm/unidad3/ejemplos-3.2/ejemplo8# kubectl apply -f mongo-srv.yaml
service/mongo created
&lt;/pre&gt;

&lt;p&gt;Una vez hayamos creado el &lt;em&gt;servicio&lt;/em&gt;, habremos terminado con lo relativo a &lt;em&gt;MongoDB&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;El mismo proceso que hemos llevado a cabo con nuestra base de datos, tendremos que seguir con nuestra aplicación.&lt;/p&gt;

&lt;p&gt;Por tanto, empezaremos por definir su &lt;em&gt;deployment&lt;/em&gt;, que al igual que el anterior, generará un &lt;strong&gt;ReplicaSet&lt;/strong&gt; con sólo un &lt;strong&gt;pod&lt;/strong&gt;, que ejecutará una imagen &lt;em&gt;sdelements/lets-chat&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Definiremos el &lt;em&gt;deployment&lt;/em&gt; utilizando el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
root@debian:/home/javier/Kubernetes/kubernetes-storm/unidad3/ejemplos-3.2/ejemplo8# kubectl apply -f letschat-deployment.yaml
deployment.apps/letschat created
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar en la salida del comando como efectivamente se ha definido este &lt;em&gt;deployment&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;El siguiente paso, será definir el &lt;em&gt;servicio&lt;/em&gt; de nuestra aplicación, esto nos permitirá poder acceder a ella. Ejecutamos el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
root@debian:/home/javier/Kubernetes/kubernetes-storm/unidad3/ejemplos-3.2/ejemplo8# kubectl apply -f letschat-srv.yaml
service/letschat created
&lt;/pre&gt;

&lt;p&gt;Una vez hayamos creado el &lt;em&gt;servicio&lt;/em&gt;, habremos terminado con lo relativo a &lt;em&gt;Let’s Chat&lt;/em&gt;, y por tanto todo estaría preparado.&lt;/p&gt;

&lt;p&gt;Para comprobar que los &lt;em&gt;deployment&lt;/em&gt; han sido correctamente creados, vamos a utilizar este comando:&lt;/p&gt;

&lt;pre&gt;
root@debian:/home/javier/Kubernetes/kubernetes-storm/unidad3/ejemplos-3.2/ejemplo8# kubectl get deploy,rs,po -o wide
NAME                       READY   UP-TO-DATE   AVAILABLE   AGE   CONTAINERS   IMAGES                 SELECTOR
deployment.apps/mongo      1/1     1            1           34m   mongo        mongo                  name=mongo
deployment.apps/letschat   1/1     1            1           30m   letschat     sdelements/lets-chat   name=letschat

NAME                                  DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES                 SELECTOR
replicaset.apps/mongo-5c694c878b      1         1         1       34m   mongo        mongo                  name=mongo,pod-template-hash=5c694c878b
replicaset.apps/letschat-7c66bd64f5   1         1         1       30m   letschat     sdelements/lets-chat   name=letschat,pod-template-hash=7c66bd64f5

NAME                            READY   STATUS    RESTARTS   AGE    IP          NODE      NOMINATED NODE   READINESS GATES
pod/mongo-5c694c878b-bwhsr      1/1     Running   0          34m    10.42.1.3   worker1    none             none
pod/letschat-7c66bd64f5-467dp   1/1     Running   0          105s   10.42.2.3   worker2    none             none
&lt;/pre&gt;

&lt;p&gt;Y para comprobar que los &lt;em&gt;servicios&lt;/em&gt; han sido correctamente creados, vamos a utilizar este comando:&lt;/p&gt;

&lt;pre&gt;
root@debian:/home/javier/Kubernetes/kubernetes-storm/unidad3/ejemplos-3.2/ejemplo8# kubectl get svc
NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)          AGE
kubernetes   ClusterIP   10.43.0.1       none         443/TCP          96m
mongo        ClusterIP   10.43.108.67    none         27017/TCP        8m14s
letschat     NodePort    10.43.5.244     none         8080:32094/TCP   111s
&lt;/pre&gt;

&lt;p&gt;En este momento, ya tendríamos disponible nuestra aplicación y podríamos acceder a ella. Para ello nos dirigiremos a nuestro navegador e introduciremos la dirección IP del nodo maestro, pero además de esto, debemos indicar el puerto donde se está sirviendo &lt;em&gt;Let’s Chat&lt;/em&gt;. Para conocer este puerto, que por defecto nos lo asigna en el rango comprendido entre 30000 y 40000, podemos utilizar el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
root@debian:/home/javier/Kubernetes/kubernetes-storm/unidad3/ejemplos-3.2/ejemplo8# kubectl describe service/letschat | grep NodePort
Type:                     NodePort
NodePort:                 http  32094/TCP
&lt;/pre&gt;

&lt;p&gt;Podemos ver como, en mi caso, está utilizando el puerto 32094, por tanto yo introduciré en mi navegador la dirección &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;172.22.201.59:32094&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/hlc_despliegue_de_un_cluster_de_kubernetes/letschat.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;¡Vaya! Aquí podemos ver como efectivamente poseemos nuestra aplicación.&lt;/p&gt;

&lt;p&gt;Pero, ¿no es demasiado incómodo tener que introducir este puerto tan inusual cada vez que queramos acceder a la aplicación? Para solucionar esto, pasaremos al siguiente apartado.&lt;/p&gt;

&lt;h2 id=&quot;proxy-inverso-con-ingress&quot;&gt;Proxy inverso con Ingress&lt;/h2&gt;

&lt;p&gt;Gracias a los controladores &lt;strong&gt;Ingress&lt;/strong&gt; o &lt;strong&gt;Ingress controller&lt;/strong&gt; podemos realizar un &lt;em&gt;proxy inverso&lt;/em&gt;, y así evitar tener que acceder a direcciones tan incómodas como la anterior, indicando nuestras aplicaciones por medio de nombres.&lt;/p&gt;

&lt;p&gt;Si recordamos, poseemos un fichero llamado &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ingress.yaml&lt;/code&gt; que aún no hemos utilizado. Al definir este fichero, cambiaremos el comportamiento y podremos acceder a nuestra aplicación en la dirección &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.letschat.com&lt;/code&gt;, usando resolución estática claro. Ejecutamos el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
root@debian:/home/javier/Kubernetes/kubernetes-storm/unidad3/ejemplos-3.2/ejemplo8# kubectl apply -f ingress.yaml
Warning: networking.k8s.io/v1beta1 Ingress is deprecated in v1.19+, unavailable in v1.22+; use networking.k8s.io/v1 Ingress
ingress.networking.k8s.io/ingress-letschat created
&lt;/pre&gt;

&lt;p&gt;Parece que se ha generado el nuevo &lt;em&gt;ingress&lt;/em&gt;, pero vamos a comprobarlo listando los &lt;em&gt;ingress&lt;/em&gt; existentes en nuestro &lt;em&gt;cluster&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
root@debian:/home/javier/Kubernetes/kubernetes-storm/unidad3/ejemplos-3.2/ejemplo8# kubectl get ingress
NAME               CLASS    HOSTS              ADDRESS     PORTS   AGE
ingress-letschat    none    www.letschat.com   10.0.0.13   80      30s
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar como efectivamente se ha creado el &lt;em&gt;ingress&lt;/em&gt; y ahora está utilizando el puerto 80.&lt;/p&gt;

&lt;p&gt;Por último, añadiremos la línea relativa al nodo maestro en nuestro fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt;. En mi caso, añado la siguiente línea:&lt;/p&gt;

&lt;pre&gt;
172.22.201.59   www.letschat.com
&lt;/pre&gt;

&lt;p&gt;Hecho esto, nos dirigimos a nuestro navegador e introducimos la dirección &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.letschat.com&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/hlc_despliegue_de_un_cluster_de_kubernetes/letschat80.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;¡Bien! Ahora podremos acceder a &lt;em&gt;Let’s Chat&lt;/em&gt; siempre que queramos en la dirección &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.letschat.com&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;escalabilidad-del-cluster&quot;&gt;Escalabilidad del cluster&lt;/h2&gt;

&lt;p&gt;Para terminar con el artículo, vamos a ver otras de las grandes ventajas de &lt;em&gt;Kubernetes&lt;/em&gt;, y se trata de la gran facilidad que nos presenta para escalar nuestro &lt;em&gt;cluster&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;En este caso, recordemos que posee dos &lt;em&gt;pods&lt;/em&gt; en funcionamiento, uno para &lt;em&gt;MongoDB&lt;/em&gt; y otro para &lt;em&gt;Let’s Chat&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Pero, imaginemos que vamos a realizar un despliegue de nuestra aplicación en un entorno de producción, a la cuál accederán una gran multitud de usuarios simultáneamente. Obviamente, esto será bastante difícil que lo soporte un sólo &lt;em&gt;pod&lt;/em&gt;, por lo que necesitaríamos desplegar &lt;em&gt;pods&lt;/em&gt; adicionales para soportar un mayor número de peticiones.&lt;/p&gt;

&lt;p&gt;En &lt;em&gt;Kubernetes&lt;/em&gt; ampliar este número de &lt;em&gt;pods&lt;/em&gt; es muy sencillo. Vamos a demostrarlo, escalando el número total de &lt;em&gt;pods&lt;/em&gt; a 4. Para ello, tan solo debemos ejecutar el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
root@debian:/home/javier/Kubernetes/kubernetes-storm/unidad3/ejemplos-3.2/ejemplo8# kubectl scale deployment.apps/letschat --replicas=4
deployment.apps/letschat scaled
&lt;/pre&gt;

&lt;p&gt;Listo, con esto habríamos pasado de tener un &lt;em&gt;pod&lt;/em&gt;, a tener 4 &lt;em&gt;pods&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Vamos a ver ahora los &lt;em&gt;pods&lt;/em&gt; existentes en nuestro &lt;em&gt;cluster&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
root@debian:/home/javier/Kubernetes/kubernetes-storm/unidad3/ejemplos-3.2/ejemplo8# kubectl get po -o wide
NAME                        READY   STATUS    RESTARTS   AGE    IP           NODE          NOMINATED NODE   READINESS GATES
mongo-5c694c878b-m9zss      1/1     Running   0          240m   10.42.0.29   controlador    none             none
letschat-7c66bd64f5-hvh7r   1/1     Running   0          208m   10.42.0.30   controlador    none             none
letschat-7c66bd64f5-vtghs   1/1     Running   0          80s    10.42.1.8    worker2        none             none
letschat-7c66bd64f5-bflgh   1/1     Running   0          64s    10.42.1.9    worker2        none             none
letschat-7c66bd64f5-pl4gx   1/1     Running   0          4s     10.42.2.8    worker1        none             none
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar, como efectivamente el número de &lt;em&gt;pods&lt;/em&gt; de &lt;em&gt;Let’s Chat&lt;/em&gt; se ha escalado a 4, donde uno de ellos se está ejecutando en el nodo maestro, dos de ellos en el &lt;em&gt;worker2&lt;/em&gt;, y el último en el &lt;em&gt;worker1&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Visto esto, habremos terminado con el contenido de este &lt;em&gt;post&lt;/em&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">En este artículo vamos a crear un cluster de Kubernetes (k8s) y para ello he decidido utilizar la distribución k3s. Posteriormente, desplegaremos la aplicación Let’s Chat en él.</summary></entry><entry><title type="html">Auditorías De Bases De Datos</title><link href="https://www.javierpzh.com/blog/auditor%C3%ADas-de-bases-de-datos" rel="alternate" type="text/html" title="Auditorías De Bases De Datos" /><published>2021-03-05T00:00:00+01:00</published><updated>2021-03-05T00:00:00+01:00</updated><id>https://www.javierpzh.com/blog/auditor%C3%ADas-de-bases-de-datos</id><content type="html" xml:base="https://www.javierpzh.com/blog/auditor%C3%ADas-de-bases-de-datos">&lt;h2 id=&quot;oracle&quot;&gt;Oracle&lt;/h2&gt;

&lt;h4 id=&quot;vamos-a-activar-las-auditorías-en-nuestro-servidor&quot;&gt;Vamos a activar las auditorías en nuestro servidor.&lt;/h4&gt;

&lt;p&gt;Por defecto, &lt;em&gt;Oracle&lt;/em&gt; incorpora las auditorías activadas, pero aún así, si queremos comprobar dicho funcionamiento por nosotros mismos, podríamos ejecutar la siguiente sentencia:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; SELECT name, value
  2  FROM v$parameter
  3  WHERE name like 'audit_trail';

NAME
--------------------------------------------------------------------------------
VALUE
--------------------------------------------------------------------------------
audit_trail
DB
&lt;/pre&gt;

&lt;p&gt;Podemos ver que efectivamente están activadas, ya que el parámetro &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;audit_trail&lt;/code&gt;, posee el valor &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;db&lt;/code&gt;, lo cual quiere decir que las auditorías se encuentran activadas y que los registros se almacenan en la base de datos.&lt;/p&gt;

&lt;p&gt;En caso de que estuviesen desactivadas, es decir, que el parámetro &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;audit_trail&lt;/code&gt;, posea el valor &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NONE&lt;/code&gt;, podríamos activarlas ejecutando la siguiente sentencia:&lt;/p&gt;

&lt;pre&gt;
ALTER SYSTEM SET audit_trail=db scope=spfile;
&lt;/pre&gt;

&lt;p&gt;Listo.&lt;/p&gt;

&lt;h4 id=&quot;vamos-a-activar-la-auditoría-de-los-intentos-de-acceso-fallidos-al-sistema&quot;&gt;Vamos a activar la auditoría de los intentos de acceso fallidos al sistema.&lt;/h4&gt;

&lt;p&gt;En este apartado vamos a activar la auditoría que se encarga de detectar los intentos de acceso fallidos:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; AUDIT CREATE SESSION WHENEVER NOT SUCCESSFUL;

Auditoria terminada correctamente.
&lt;/pre&gt;

&lt;p&gt;Una vez habilitada, para comprobar su funcionamiento, realizaremos un inicio de sesión erróneo y posteriormente, visualizaremos como se ha registrado dicho intento de acceso:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; connect usuarioerror/error
ERROR:
ORA-01017: nombre de usuario/contrase?a no validos; conexion denegada

SQL&amp;gt; connect sysdba
Introduzca la contrase?a:
...

SQL&amp;gt; SELECT os_username, username, extended_timestamp, action_name, returncode
  2  FROM DBA_AUDIT_SESSION;

OS_USERNAME
--------------------------------------------------------------------------------
USERNAME
--------------------------------------------------------------------------------
EXTENDED_TIMESTAMP
---------------------------------------------------------------------------
ACTION_NAME		     RETURNCODE
---------------------------- ----------
oracle
USUARIOERROR
04/03/21 15:38:26,163150 +01:00
LOGON				   1017
&lt;/pre&gt;

&lt;p&gt;Podemos ver como efectivamente nos muestra el intento de acceso fallido, además del nombre de usuario utilizado, la fecha exacta, …&lt;/p&gt;

&lt;h4 id=&quot;vamos-a-activar-la-auditoría-de-las-operaciones-dml-realizadas-por-scott&quot;&gt;Vamos a activar la auditoría de las operaciones DML realizadas por SCOTT.&lt;/h4&gt;

&lt;p&gt;En este apartado vamos a activar la auditoría de las operaciones DML realizadas por SCOTT, para ello ejecutamos la siguiente sentencia SQL:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; AUDIT INSERT TABLE, UPDATE TABLE, DELETE TABLE BY SCOTT;

Auditoria terminada correctamente.
&lt;/pre&gt;

&lt;p&gt;Una vez habilitada, para comprobar su funcionamiento, realizaremos un &lt;em&gt;INSERT&lt;/em&gt;, un &lt;em&gt;UPDATE&lt;/em&gt; y un &lt;em&gt;DELETE&lt;/em&gt; y posteriormente, visualizaremos como se han registrado en dicha auditoría:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; INSERT INTO DEPT (DEPTNO, DNAME, LOC) VALUES (50,'Pruebas','Sevilla');

1 fila creada.

SQL&amp;gt; UPDATE DEPT SET LOC='Dos Hermanas' WHERE DEPTNO=50;

1 fila actualizada.

SQL&amp;gt; DELETE FROM DEPT WHERE DEPTNO=50;

1 fila suprimida.

SQL&amp;gt; SELECT username, obj_name, action_name, extended_timestamp
  2  FROM DBA_AUDIT_OBJECT;

USERNAME
------------------------------
OBJ_NAME
--------------------------------------------------------------------------------
ACTION_NAME
----------------------------
EXTENDED_TIMESTAMP
---------------------------------------------------------------------------
SCOTT
DEPT
INSERT
04/03/21 16:21:19,163150 +01:00


USERNAME
------------------------------
OBJ_NAME
--------------------------------------------------------------------------------
ACTION_NAME
----------------------------
EXTENDED_TIMESTAMP
---------------------------------------------------------------------------
SCOTT
DEPT
UPDATE
04/03/21 16:21:28,264893 +01:00


USERNAME
------------------------------
OBJ_NAME
--------------------------------------------------------------------------------
ACTION_NAME
----------------------------
EXTENDED_TIMESTAMP
---------------------------------------------------------------------------
SCOTT
DEPT
DELETE
04/03/21 16:21:43,371902 +01:00
&lt;/pre&gt;

&lt;p&gt;Podemos ver como efectivamente nos muestra el usuario que ha realizado la acción, qué acción ha realizado, la fecha exacta, …&lt;/p&gt;

&lt;h4 id=&quot;auditoría-de-grano-fino&quot;&gt;Auditoría de grano fino&lt;/h4&gt;

&lt;p&gt;Las auditorías de grano fino son auditorías que almacenan más datos sobre las sentencias que ejecutamos, como la estructura completa de la sentencias.&lt;/p&gt;

&lt;p&gt;Es decir, gracias a ellas, podríamos saber qué consulta ha sido ejecutada sobre una tabla o qué datos
han sido insertados, modificados o borrados.&lt;/p&gt;

&lt;h4 id=&quot;vamos-a-realizar-una-auditoría-de-grano-fino-para-almacenar-información-sobre-la-inserción-de-empleados-del-departamento-10-de-la-tabla-emp-de-scott&quot;&gt;Vamos a realizar una auditoría de grano fino para almacenar información sobre la inserción de empleados del departamento 10 de la tabla EMP de SCOTT.&lt;/h4&gt;

&lt;p&gt;Ahora que ya sabemos lo que son las auditorías de grano fino (FGA), vamos a crear una que almacenen información sobre la inserción de empleados del departamento 10 de la tabla &lt;em&gt;EMP&lt;/em&gt; de &lt;em&gt;SCOTT&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Vamos a crear la siguiente auditoría de grano fino para ello:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; BEGIN
  2  DBMS_FGA.ADD_POLICY (
  3  OBJECT_SCHEMA      =&amp;gt; 'SCOTT',
  4  OBJECT_NAME        =&amp;gt; 'EMP',
  5  POLICY_NAME        =&amp;gt; 'audit_fino_javier',
  6  AUDIT_CONDITION    =&amp;gt; 'DEPTNO = 10',
  7  STATEMENT_TYPES    =&amp;gt; 'INSERT'
  8  );
  9  end;
 10  /

Procedimiento PL/SQL terminado correctamente.
&lt;/pre&gt;

&lt;p&gt;Una vez creadas, vamos a realizar una serie de inserciones en el departamento 10, y posteriormente comprobaremos la información almacenada:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (9000, 'Javier', 'Administr', 8500, '19-11-2001', 2000, NULL, 10);

1 fila creada.

SQL&amp;gt; INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (9001, 'Pablo', 'Administr', 8600, '22-01-1997', 2100, NULL, 10);

1 fila creada.

SQL&amp;gt; SELECT DB_USER, OBJECT_NAME, SQL_TEXT, EXTENDED_TIMESTAMP
  2  FROM DBA_FGA_AUDIT_TRAIL
  3  WHERE POLICY_NAME='AUDIT_FINO_JAVIER';

DB_USER
------------------------------
OBJECT_NAME
--------------------------------------------------------------------------------
SQL_TEXT
--------------------------------------------------------------------------------
EXTENDED_TIMESTAMP
---------------------------------------------------------------------------
SCOTT
EMP
INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (90
00, 'Javier', 'Administr', 8500, '19-11-2001', 2000, NULL, 10)
04/03/21 17:30:24,253000 +01:00

DB_USER
------------------------------
OBJECT_NAME
--------------------------------------------------------------------------------
SQL_TEXT
--------------------------------------------------------------------------------
EXTENDED_TIMESTAMP
---------------------------------------------------------------------------
SCOTT
EMP
INSERT INTO EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO) VALUES (90
01, 'Pablo', 'Administr', 8600, '22-01-1997', 2100, NULL, 10)
04/03/21 17:31:23,488000 +01:00
&lt;/pre&gt;

&lt;p&gt;Podemos ver como efectivamente nos muestra la información relativa a las acciones realizadas.&lt;/p&gt;

&lt;h4 id=&quot;diferencias-entre-auditar-una-operación-by-access-o-by-session&quot;&gt;Diferencias entre auditar una operación ‘BY ACCESS’ o ‘BY SESSION’.&lt;/h4&gt;

&lt;p&gt;La principal diferencia entre ambas operaciones es la siguiente:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;BY ACCESS:&lt;/strong&gt; almacena un registro por cada acción realizada independientemente de si es repetida o no.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BY SESSION:&lt;/strong&gt; almacena un solo registro de una misma acción que hagamos, evitando repetirlas.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Para terminar, hay que saber, que al activar una auditoría, podemos indicar el tipo que deseamos, si &lt;strong&gt;BY ACCESS&lt;/strong&gt; o &lt;strong&gt;BY SESSION&lt;/strong&gt;. Por ejemplo:&lt;/p&gt;

&lt;pre&gt;
AUDIT INSERT TABLE, UPDATE TABLE, DELETE TABLE BY SCOTT BY {ACCESS/SESSION};
&lt;/pre&gt;

&lt;p&gt;Listo.&lt;/p&gt;

&lt;h4 id=&quot;diferencias-entre-los-valores-db-y-db-extended-del-parámetro-audit_trail&quot;&gt;Diferencias entre los valores ‘DB’ y ‘DB, EXTENDED’ del parámetro audit_trail.&lt;/h4&gt;

&lt;p&gt;Ambos valores activan la auditoría y almacenan los datos en la tabla &lt;strong&gt;SYS.AUD$&lt;/strong&gt; de &lt;em&gt;Oracle&lt;/em&gt;, pero, la principal diferencia que existe entre ellos es que, el valor &lt;strong&gt;DB, EXTENDED&lt;/strong&gt;, además almacena los datos correspondientes en las columnas &lt;strong&gt;SQLBIND&lt;/strong&gt; y &lt;strong&gt;SQLTEXT&lt;/strong&gt; de dicha tabla, &lt;em&gt;SYS.AUD$&lt;/em&gt;, mientras que el valor &lt;strong&gt;DB&lt;/strong&gt; no lo hace.&lt;/p&gt;

&lt;p&gt;Ahora, vamos a ver como podríamos cambiar de un valor a otro.&lt;/p&gt;

&lt;p&gt;En primer lugar, para ver cuál de los dos estamos utilizando, ejecutaremos la siguiente sentencia:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; SHOW PARAMETER AUDIT_TRAIL

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
audit_trail                          string      DB
&lt;/pre&gt;

&lt;p&gt;Vemos como actualmente, en mi caso, poseo el valor &lt;strong&gt;DB&lt;/strong&gt;. Ahora voy a cambiar al valor &lt;strong&gt;DB, EXTENDED&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; ALTER SYSTEM SET audit_trail = &quot;DB_EXTENDED&quot; SCOPE=SPFILE;

Sistema modificado.
&lt;/pre&gt;

&lt;p&gt;Parece que ya se ha cambiado, pero no, para que se aplique este cambio, es necesario que reiniciemos la base de datos, por lo que vamos a ello:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; shutdown
Base de datos cerrada.
Base de datos desmontada.
Instancia ORACLE cerrada.

SQL&amp;gt; startup
Instancia ORACLE iniciada.

Total System Global Area 1720328192 bytes
Fixed Size                  2176448 bytes
Variable Size            1073744448 bytes
Database Buffers          637534208 bytes
Redo Buffers                6873088 bytes
Base de datos montada.
Base de datos abierta.
&lt;/pre&gt;

&lt;p&gt;Comprobamos de nuevo que valor estamos utilizando:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; SHOW PARAMETER AUDIT_TRAIL

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
audit_trail                          string      DB_EXTENDED
&lt;/pre&gt;

&lt;p&gt;Vemos como efectivamente ahora sí, hemos cambiado al nuevo valor.&lt;/p&gt;

&lt;h2 id=&quot;postgresql&quot;&gt;PostgreSQL&lt;/h2&gt;

&lt;h4 id=&quot;vamos-a-activar-las-auditorías-en-nuestro-servidor-1&quot;&gt;Vamos a activar las auditorías en nuestro servidor.&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;PostgreSQL&lt;/em&gt; por defecto no incorpora una herramienta de auditorías, por lo que, si queremos conseguir realizar auditorías, tendremos que descargarnos una herramienta que ha desarrollado la comunidad, llamada &lt;strong&gt;Audit trigger 91plus&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Esta herramienta consiste en una serie de &lt;em&gt;scripts&lt;/em&gt; y &lt;em&gt;triggers&lt;/em&gt; que realizan las acciones necesarias para simular las auditorías.&lt;/p&gt;

&lt;p&gt;Para descargarnos la herramienta debemos utilizar el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
wget https://raw.githubusercontent.com/2ndQuadrant/audit-trigger/master/audit.sql
&lt;/pre&gt;

&lt;p&gt;Una vez descargada, nos conectaremos a nuestro servidor y ejecutaremos el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
scott=# \i audit.sql
CREATE EXTENSION
CREATE SCHEMA
REVOKE
COMMENT
CREATE TABLE
REVOKE
COMMENT
COMMENT
COMMENT
COMMENT
COMMENT
COMMENT
COMMENT
COMMENT
COMMENT
COMMENT
COMMENT
COMMENT
COMMENT
COMMENT
COMMENT
COMMENT
COMMENT
COMMENT
CREATE INDEX
CREATE INDEX
CREATE INDEX
CREATE FUNCTION
COMMENT
CREATE FUNCTION
COMMENT
CREATE FUNCTION
CREATE FUNCTION
COMMENT
CREATE VIEW
COMMENT
&lt;/pre&gt;

&lt;p&gt;Por último, tan sólo nos faltaría activar la recogida de datos en dichas auditorías, para ello ejecutamos la siguiente sentencia:&lt;/p&gt;

&lt;pre&gt;
select audit.audit_table({nombretabla});
&lt;/pre&gt;

&lt;p&gt;Listo.&lt;/p&gt;

&lt;h4 id=&quot;vamos-a-activar-la-auditoría-de-los-intentos-de-acceso-fallidos-al-sistema-1&quot;&gt;Vamos a activar la auditoría de los intentos de acceso fallidos al sistema.&lt;/h4&gt;

&lt;p&gt;No es posible activar este tipo de auditoría en &lt;em&gt;PostgreSQL&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;vamos-a-activar-la-auditoría-de-las-operaciones-dml&quot;&gt;Vamos a activar la auditoría de las operaciones DML.&lt;/h4&gt;

&lt;p&gt;En este apartado vamos a activar la auditoría de las operaciones DML en la tabla &lt;em&gt;DEPT&lt;/em&gt;, para ello ejecutamos la siguiente sentencia SQL:&lt;/p&gt;

&lt;pre&gt;
scott=# select audit.audit_table('dept');
NOTICE:  trigger &quot;audit_trigger_row&quot; for relation &quot;dept&quot; does not exist, skipping
NOTICE:  trigger &quot;audit_trigger_stm&quot; for relation &quot;dept&quot; does not exist, skipping
NOTICE:  CREATE TRIGGER audit_trigger_row AFTER INSERT OR UPDATE OR DELETE ON dept FOR EACH ROW EXECUTE PROCEDURE audit.if_modified_func('true');
NOTICE:  CREATE TRIGGER audit_trigger_stm AFTER TRUNCATE ON dept FOR EACH STATEMENT EXECUTE PROCEDURE audit.if_modified_func('true');
 audit_table
-------------

(1 row)
&lt;/pre&gt;

&lt;p&gt;Una vez habilitada, para comprobar su funcionamiento, realizaremos un &lt;em&gt;INSERT&lt;/em&gt;, un &lt;em&gt;UPDATE&lt;/em&gt; y un &lt;em&gt;DELETE&lt;/em&gt; y posteriormente, visualizaremos como se han registrado en dicha auditoría:&lt;/p&gt;

&lt;pre&gt;
scott=# INSERT INTO DEPT (DEPTNO, DNAME, LOC) VALUES (50,'Pruebas','Sevilla');
INSERT 0 1

scott=# UPDATE DEPT SET LOC='Dos Hermanas' WHERE DEPTNO=50;
UPDATE 1

scott=# DELETE FROM DEPT WHERE DEPTNO=50;
DELETE 1

scott=# select session_user_name, action, table_name, action_tstamp_clk, client_query
from audit.logged_actions;
 session_user_name | action | table_name |       action_tstamp_clk       |                              client_query                              
-------------------+--------+------------+-------------------------------+------------------------------------------------------------------------
 postgres          | I      | dept       | 2021-03-05 11:58:31.904308+00 | INSERT INTO DEPT (DEPTNO, DNAME, LOC) VALUES (50,'Pruebas','Sevilla');
 postgres          | U      | dept       | 2021-03-05 11:58:31.905631+00 | UPDATE DEPT SET LOC='Dos Hermanas' WHERE DEPTNO=50;
 postgres          | D      | dept       | 2021-03-05 11:58:32.84674+00  | DELETE FROM DEPT WHERE DEPTNO=50;
(3 rows)
&lt;/pre&gt;

&lt;p&gt;Podemos ver como efectivamente nos muestra el usuario que ha realizado la acción, qué acción ha realizado, la fecha exacta, … Pero además podemos apreciar como directamente, nos muestra las sentencias introducidas, por lo que esta auditoría sería de &lt;strong&gt;grano fino&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;mysql&quot;&gt;MySQL&lt;/h2&gt;

&lt;h4 id=&quot;vamos-a-activar-las-auditorías-en-nuestro-servidor-2&quot;&gt;Vamos a activar las auditorías en nuestro servidor.&lt;/h4&gt;

&lt;p&gt;Para activar las auditorías en &lt;em&gt;MySQL&lt;/em&gt;, debemos ejecutar la siguiente sentencia:&lt;/p&gt;

&lt;pre&gt;
SET SESSION profiling = 1;
&lt;/pre&gt;

&lt;p&gt;Listo.&lt;/p&gt;

&lt;h4 id=&quot;vamos-a-activar-la-auditoría-de-los-intentos-de-acceso-fallidos-al-sistema-2&quot;&gt;Vamos a activar la auditoría de los intentos de acceso fallidos al sistema.&lt;/h4&gt;

&lt;p&gt;No es posible activar este tipo de auditoría en &lt;em&gt;MySQL&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;vamos-a-activar-la-auditoría-de-las-operaciones-dml-1&quot;&gt;Vamos a activar la auditoría de las operaciones DML.&lt;/h4&gt;

&lt;p&gt;En este apartado vamos a ver como se auditan las operaciones DML.&lt;/p&gt;

&lt;p&gt;Para comprobar su funcionamiento, realizaremos un &lt;em&gt;INSERT&lt;/em&gt;, un &lt;em&gt;UPDATE&lt;/em&gt; y un &lt;em&gt;DELETE&lt;/em&gt; y posteriormente, visualizaremos como se han registrado dichas operaciones:&lt;/p&gt;

&lt;pre&gt;
MariaDB [scott]&amp;gt; INSERT INTO DEPT (DEPTNO, DNAME, LOC) VALUES (50,'Pruebas','Sevilla');
Query OK, 1 row affected (0.004 sec)

MariaDB [scott]&amp;gt; UPDATE DEPT SET LOC='Dos Hermanas' WHERE DEPTNO=50;
Query OK, 1 row affected (0.001 sec)
Rows matched: 1  Changed: 1  Warnings: 0

MariaDB [scott]&amp;gt; DELETE FROM DEPT WHERE DEPTNO=50;
Query OK, 1 row affected (0.004 sec)

MariaDB [scott]&amp;gt; SHOW PROFILES;
+----------+------------+-----------------------------------------------------------------------+
| Query_ID | Duration   | Query                                                                 |
+----------+------------+-----------------------------------------------------------------------+
|        1 | 0.00027403 | SELECT DATABASE()                                                     |
|        2 | 0.00060149 | show databases                                                        |
|        3 | 0.00044156 | show tables                                                           |
|        4 | 0.00363078 | INSERT INTO DEPT (DEPTNO, DNAME, LOC) VALUES (50,'Pruebas','Sevilla') |
|        5 | 0.00136099 | UPDATE DEPT SET LOC='Dos Hermanas' WHERE DEPTNO=50                    |
|        6 | 0.00401232 | DELETE FROM DEPT WHERE DEPTNO=50                                      |
+----------+------------+-----------------------------------------------------------------------+
6 rows in set (0.000 sec)
&lt;/pre&gt;

&lt;p&gt;Podemos ver como nos muestra las sentencias introducidas, por lo que esta auditoría sería de &lt;strong&gt;grano fino&lt;/strong&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">Oracle</summary></entry><entry><title type="html">Configuración De Un Proxy Inverso Con Apache</title><link href="https://www.javierpzh.com/blog/Configuraci%C3%B3n-de-un-Proxy-Inverso-con-Apache" rel="alternate" type="text/html" title="Configuración De Un Proxy Inverso Con Apache" /><published>2021-03-03T00:00:00+01:00</published><updated>2021-03-03T00:00:00+01:00</updated><id>https://www.javierpzh.com/blog/Configuraci%C3%B3n-de-un-Proxy-Inverso-con-Apache</id><content type="html" xml:base="https://www.javierpzh.com/blog/Configuraci%C3%B3n-de-un-Proxy-Inverso-con-Apache">&lt;p&gt;En este artículo vamos a instalar un &lt;strong&gt;proxy inverso&lt;/strong&gt; con &lt;em&gt;Apache&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;El escenario en el que vamos a trabajar, está definido en este &lt;a href=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_Configuración_de_un_ProxyInverso_con_Apache/Vagrantfile.txt&quot;&gt;Vagrantfile&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tendremos una máquina llamada &lt;strong&gt;balanceador&lt;/strong&gt; que estará conectada a nuestra red doméstica, de manera que podremos acceder a ella, además de estar conectada a una red privada, a la que también pertenecerán dos máquinas, cada una con un servidor &lt;em&gt;Apache&lt;/em&gt; y que servirán webs distintas.&lt;/p&gt;

&lt;p&gt;La máquina &lt;strong&gt;balanceador&lt;/strong&gt; actuará como &lt;em&gt;proxy inverso&lt;/em&gt; y se encargará de redirigir las distintas peticiones, a las diferentes máquinas internas.&lt;/p&gt;

&lt;p&gt;En mi caso, ambas páginas webs serán de prueba, y he utilizado dos plantillas cualquiera. Puedes descargar ambas desde los siguientes enlaces: &lt;a href=&quot;https://themewagon.com/themes/free-coffee-shop-bootstrap-template/&quot;&gt;Coffee-Master&lt;/a&gt; y &lt;a href=&quot;https://themewagon.com/themes/free-bootstrap-blog-website-template/&quot;&gt;Original-Master&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;He descargado una plantilla en cada máquina interna, y he almacenado ambas carpetas resultantes en el directorio &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/www/html&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A continuación dejo el contenido de los ficheros de los diferentes &lt;em&gt;virtualhosts&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Máquina apache1&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;
root@apache1:~# cat /etc/apache2/sites-available/000-default.conf

&amp;lt;\VirtualHost *:80\&amp;gt;

	ServerAdmin webmaster@localhost
	DocumentRoot /var/www/html/coffee-master/

	ErrorLog ${APACHE_LOG_DIR}/error.log
	CustomLog ${APACHE_LOG_DIR}/access.log combined

&amp;lt;\/VirtualHost\&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Atención:&lt;/strong&gt; a esta configuración hay que eliminarle los carácteres &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\&lt;/code&gt;, que he tenido que introducir para escapar los carácteres siguientes, así que en caso de querer copiar la configuración, debemos tener en cuenta esto.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Máquina apache2&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;
root@apache2:~# cat /etc/apache2/sites-available/000-default.conf

&amp;lt;\VirtualHost *:80\&amp;gt;

	ServerAdmin webmaster@localhost
	DocumentRoot /var/www/html/original-master/

	ErrorLog ${APACHE_LOG_DIR}/error.log
	CustomLog ${APACHE_LOG_DIR}/access.log combined

&amp;lt;\/VirtualHost\&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Atención:&lt;/strong&gt; a esta configuración hay que eliminarle los carácteres &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\&lt;/code&gt;, que he tenido que introducir para escapar los carácteres siguientes, así que en caso de querer copiar la configuración, debemos tener en cuenta esto.&lt;/p&gt;

&lt;p&gt;Explicado esto, vamos a empezar con las configuraciones del propio &lt;em&gt;post&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Pongámonos en situación, ahora mismo nos encontramos con las dos máquinas internas sirviendo cada una, una web diferente. Obviamente para acceder a ellas tenemos que utilizar la máquina &lt;strong&gt;balanceador&lt;/strong&gt;, que es la que posee una dirección de mi red local.&lt;/p&gt;

&lt;p&gt;Bien, ahora lo que vamos a hacer, es acceder a las webs mediante nuestro &lt;em&gt;proxy inverso&lt;/em&gt;, a través de nombres de dominio. Para llevar a cabo esto, primeramente debemos habilitar el siguiente módulo de &lt;em&gt;Apache&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
a2enmod proxy proxy_http
&lt;/pre&gt;

&lt;p&gt;Hecho esto, necesitaremos crear los distintos &lt;em&gt;virtualhosts&lt;/em&gt;, que se almacenarán en la ruta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/apache2/sites-available/&lt;/code&gt;, y que en mi caso, se llamarán &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;app1.conf&lt;/code&gt; y &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;app2.conf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Vamos a ver el contenido del fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/apache2/sites-available/app1.conf&lt;/code&gt; y luego explicaremos su funcionamiento:&lt;/p&gt;

&lt;pre&gt;
&amp;lt;\VirtualHost *:80\&amp;gt;

        ServerName www.app1.org

        ServerAdmin webmaster@localhost
        DocumentRoot /var/www/html

        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined

        ProxyPass &quot;/&quot; &quot;http://10.10.10.11/&quot;
        ProxyPassReverse &quot;/&quot; &quot;http://10.10.10.11/&quot;

&amp;lt;\/VirtualHost\&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Atención:&lt;/strong&gt; a esta configuración hay que eliminarle los carácteres &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\&lt;/code&gt;, que he tenido que introducir para escapar los carácteres siguientes, así que en caso de querer copiar la configuración, debemos tener en cuenta esto.&lt;/p&gt;

&lt;p&gt;Podemos apreciar como este &lt;em&gt;virtualhost&lt;/em&gt; actuará cuando se acceda a la web &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.app1.org&lt;/code&gt;. Al acceder a esta web, lo que hará la máquina &lt;em&gt;balanceador&lt;/em&gt; será redirigir la petición a la máquina cuya IP es &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.10.10.11&lt;/code&gt;, que es la primera de las máquinas de nuestra red interna.&lt;/p&gt;

&lt;p&gt;Entendido el funcionamiento, vamos a ver el contenido del segundo fichero, el &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/apache2/sites-available/app2.conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;
&amp;lt;\VirtualHost *:80\&amp;gt;

        ServerName www.app2.org

        ServerAdmin webmaster@localhost
        DocumentRoot /var/www/html

        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined

        ProxyPass &quot;/&quot; &quot;http://10.10.10.22/&quot;
        ProxyPassReverse &quot;/&quot; &quot;http://10.10.10.22/&quot;

&amp;lt;\/VirtualHost\&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Atención:&lt;/strong&gt; a esta configuración hay que eliminarle los carácteres &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\&lt;/code&gt;, que he tenido que introducir para escapar los carácteres siguientes, así que en caso de querer copiar la configuración, debemos tener en cuenta esto.&lt;/p&gt;

&lt;p&gt;De igual manera, podemos ver como este &lt;em&gt;virtualhost&lt;/em&gt; actuará cuando se acceda a la web &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.app2.org&lt;/code&gt;, y al acceder a ella, la máquina &lt;em&gt;balanceador&lt;/em&gt; redirigirá la petición a la máquina cuya IP es &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.10.10.22&lt;/code&gt;, que es la segunda de las máquinas de nuestra red interna.&lt;/p&gt;

&lt;p&gt;De esta manera, lo que estaremos haciendo será utilizando la máquina &lt;em&gt;balanceador&lt;/em&gt; como &lt;em&gt;proxy inverso&lt;/em&gt; para acceder a las distintas webs de nuestra red interna.&lt;/p&gt;

&lt;p&gt;Vamos a comprobar que efectivamente el funcionamiento es el explicado, para ello antes, debemos habilitar los distintos ficheros de los &lt;em&gt;virtualhosts&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
a2ensite app1.conf
a2ensite app2.conf
&lt;/pre&gt;

&lt;p&gt;Reiniciamos el servidor web &lt;em&gt;Apache&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
systemctl restart apache2
&lt;/pre&gt;

&lt;p&gt;Para poder acceder desde nuestro equipo, debemos añadir en nuestro fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt;, las siguientes líneas, haciendo referencia a la IP de nuestra red doméstica que posea la máquina &lt;em&gt;balanceador&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
192.168.0.74 www.app1.org
192.168.0.74 www.app2.org
&lt;/pre&gt;

&lt;p&gt;Si accedemos desde nuestro navegador a la web &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.app1.org&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_Configuración_de_un_ProxyInverso_con_Apache/web1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Y si accedemos desde nuestro navegador a la web &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.app2.org&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_Configuración_de_un_ProxyInverso_con_Apache/web2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Podemos ver como efectivamente, el funcionamiento es el correcto y estamos accediendo a las distintas webs diferenciando mediante nombres de dominio.&lt;/p&gt;

&lt;p&gt;Antes de finalizar el artículo, vamos a ver también como podemos configurar el &lt;em&gt;proxy inverso&lt;/em&gt; para que, en vez de distinguir por nombre de dominio, lo haga por URL.&lt;/p&gt;

&lt;p&gt;En este caso, únicamente poseeremos un nombre de dominio, y nuestro &lt;em&gt;proxy inverso&lt;/em&gt; distinguirá mediante URLs, de manera que accederá a la primera web si la URL es &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.proxyinverso.org/app1/&lt;/code&gt;, y accederá a la segunda web si la URL es &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.proxyinverso.org/app2/&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para hacer esto, vamos a crear un nuevo &lt;em&gt;virtualhost&lt;/em&gt;, que de nuevo se almacenará en la ruta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/apache2/sites-available/&lt;/code&gt;, y que en mi caso, se llamará &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proxyinverso.conf&lt;/code&gt;, como el siguiente:&lt;/p&gt;

&lt;pre&gt;
&amp;lt;\VirtualHost *:80\&amp;gt;

        ServerName www.proxyinverso.org

        ServerAdmin webmaster@localhost
        DocumentRoot /var/www/html

        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined

        &amp;lt;\Location &quot;/app1/&quot;\&amp;gt;
          ProxyPass &quot;http://10.10.10.11/&quot;
          ProxyPassReverse &quot;http://10.10.10.11/&quot;
        &amp;lt;\/Location\&amp;gt;

        &amp;lt;\Location &quot;/app2/&quot;\&amp;gt;
          ProxyPass &quot;http://10.10.10.22/&quot;
          ProxyPassReverse &quot;http://10.10.10.22/&quot;
        &amp;lt;\/Location\&amp;gt;

&amp;lt;\/VirtualHost\&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Atención:&lt;/strong&gt; a esta configuración hay que eliminarle los carácteres &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\&lt;/code&gt;, que he tenido que introducir para escapar los carácteres siguientes, así que en caso de querer copiar la configuración, debemos tener en cuenta esto.&lt;/p&gt;

&lt;p&gt;Una vez creado, vamos a comprobar que efectivamente el funcionamiento es el explicado, para ello antes, debemos habilitar el fichero del nuevo &lt;em&gt;virtualhost&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
a2ensite proxyinverso.conf
&lt;/pre&gt;

&lt;p&gt;Reiniciamos el servidor web &lt;em&gt;Apache&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
systemctl restart apache2
&lt;/pre&gt;

&lt;p&gt;Para poder acceder desde nuestro equipo, debemos añadir en nuestro fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt;, la siguiente línea, haciendo referencia a la IP de nuestra red doméstica que posea la máquina &lt;em&gt;balanceador&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
192.168.0.74 www.proxyinverso.org
&lt;/pre&gt;

&lt;p&gt;Si accedemos desde nuestro navegador a la URL &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.proxyinverso.org/app1/&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_Configuración_de_un_ProxyInverso_con_Apache/web1.2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Y si accedemos desde nuestro navegador a la URL &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.proxyinverso.org/app2/&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_Configuración_de_un_ProxyInverso_con_Apache/web2.2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Podemos ver como efectivamente, el funcionamiento es el correcto y ahora estamos accediendo a las distintas webs diferenciando mediante las URLs.&lt;/p&gt;

&lt;p&gt;Ya hemos visto todo lo relativo a esta entrada, por lo que este &lt;em&gt;post&lt;/em&gt; finalizaría aquí.&lt;/p&gt;</content><author><name></name></author><summary type="html">En este artículo vamos a instalar un proxy inverso con Apache.</summary></entry><entry><title type="html">Configuración De Un Proxy Squid</title><link href="https://www.javierpzh.com/blog/Configuraci%C3%B3n-de-un-proxy-Squid" rel="alternate" type="text/html" title="Configuración De Un Proxy Squid" /><published>2021-03-03T00:00:00+01:00</published><updated>2021-03-03T00:00:00+01:00</updated><id>https://www.javierpzh.com/blog/Configuraci%C3%B3n-de-un-proxy-Squid</id><content type="html" xml:base="https://www.javierpzh.com/blog/Configuraci%C3%B3n-de-un-proxy-Squid">&lt;p&gt;En este artículo vamos a instalar un &lt;em&gt;proxy&lt;/em&gt; &lt;strong&gt;Squid&lt;/strong&gt; para configurar nuestro cliente para que acceda a internet por medio de este &lt;em&gt;proxy&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;El escenario en el que vamos a trabajar, está definido en este &lt;a href=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_Configuración_de_un_proxy_Squid/Vagrantfile.txt&quot;&gt;Vagrantfile&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;instalación&quot;&gt;Instalación&lt;/h4&gt;

&lt;p&gt;En primer lugar, vamos a llevar a cabo la instalación de &lt;em&gt;Squid&lt;/em&gt; en la primera máquina llamada &lt;em&gt;proxy&lt;/em&gt;. Para ello empleamos el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
apt install squid -y
&lt;/pre&gt;

&lt;p&gt;Y lo iniciaremos, además de habilitarlo en cada inicio del sistema:&lt;/p&gt;

&lt;pre&gt;
systemctl enable squid &amp;amp;&amp;amp; systemctl start squid
&lt;/pre&gt;

&lt;p&gt;Listo.&lt;/p&gt;

&lt;h4 id=&quot;configuración-squid&quot;&gt;Configuración Squid&lt;/h4&gt;

&lt;p&gt;Una vez instalado, tendremos que llevar a cabo su configuración. En mi caso, me interesa que &lt;em&gt;Squid&lt;/em&gt; permita conexiones desde mi red local. Por defecto, escuchará peticiones en el puerto &lt;strong&gt;3128&lt;/strong&gt;. Para que no permita conexiones desde cualquier dirección, nos dirigiremos a su fichero de configuración &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/squid/squid.conf&lt;/code&gt; y en él debemos buscar la siguiente línea:&lt;/p&gt;

&lt;pre&gt;
http_access deny all
&lt;/pre&gt;

&lt;p&gt;Puede ser que nos la encontramos con el siguiente aspecto:&lt;/p&gt;

&lt;pre&gt;
http_access allow all
&lt;/pre&gt;

&lt;p&gt;Si el valor establecido es &lt;em&gt;allow&lt;/em&gt; significará que permitirá conexiones desde cualquier interfaz de red.&lt;/p&gt;

&lt;p&gt;También debemos asegurarnos que las siguientes líneas estén habilitadas, es decir, que no se encuentren comentadas:&lt;/p&gt;

&lt;pre&gt;
http_access allow localnet
http_access allow localhost
&lt;/pre&gt;

&lt;p&gt;Esto significa, que nos permitirá realizar peticiones desde ambas redes especificadas. Comprobado estos detalles, añadiremos la siguiente línea:&lt;/p&gt;

&lt;pre&gt;
acl localnet src 172.22.9.28
&lt;/pre&gt;

&lt;p&gt;Esta línea se encarga de definir una ACL que permitirá a la IP indicada la conexión a nuestro &lt;em&gt;proxy&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Es muy &lt;strong&gt;importante&lt;/strong&gt; añadir la línea junto a este bloque de ACLs, ya que el orden de las configuraciones influye:&lt;/p&gt;

&lt;pre&gt;
acl localnet src 0.0.0.1-0.255.255.255  # RFC 1122 &quot;this&quot; network (LAN)
acl localnet src 10.0.0.0/8             # RFC 1918 local private network (LAN)
acl localnet src 100.64.0.0/10          # RFC 6598 shared address space (CGN)
acl localnet src 169.254.0.0/16         # RFC 3927 link-local (directly plugged) machines
acl localnet src 172.16.0.0/12          # RFC 1918 local private network (LAN)
acl localnet src 192.168.0.0/16         # RFC 1918 local private network (LAN)
acl localnet src fc00::/7               # RFC 4193 local private network range
acl localnet src fe80::/10              # RFC 4291 link-local (directly plugged) machines

acl localnet src 172.22.9.28

acl SSL_ports port 443
acl Safe_ports port 80          # http
acl Safe_ports port 21          # ftp
acl Safe_ports port 443         # https
acl Safe_ports port 70          # gopher
acl Safe_ports port 210         # wais
acl Safe_ports port 1025-65535  # unregistered ports
acl Safe_ports port 280         # http-mgmt
acl Safe_ports port 488         # gss-http
acl Safe_ports port 591         # filemaker
acl Safe_ports port 777         # multiling http
acl CONNECT method CONNECT
&lt;/pre&gt;

&lt;p&gt;Hecho esto, reiniciaremos el servicio:&lt;/p&gt;

&lt;pre&gt;
systemctl restart squid
&lt;/pre&gt;

&lt;p&gt;Ya podríamos utilizar nuestro &lt;em&gt;proxy&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;configuración-en-el-cliente-para-que-utilice-el-proxy-squid&quot;&gt;Configuración en el cliente para que utilice el proxy Squid&lt;/h4&gt;

&lt;p&gt;Antes de dirigirnos a nuestro navegador para establecer el nuevo &lt;em&gt;proxy&lt;/em&gt;, en la terminal, dejaremos el siguiente proceso activo para ver a tiempo real los &lt;em&gt;logs&lt;/em&gt; de acceso al &lt;em&gt;proxy&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
tail -f /var/log/squid/access.log
&lt;/pre&gt;

&lt;p&gt;Para configurar el &lt;em&gt;proxy&lt;/em&gt; en nuestro navegador, en mi caso, explicaré como es el proceso en &lt;strong&gt;Firefox&lt;/strong&gt;, nos dirigimos a &lt;strong&gt;Preferencias&lt;/strong&gt;, y en el apartado &lt;strong&gt;General&lt;/strong&gt;, al final nos aparece una sección llamada &lt;strong&gt;Configuración de red&lt;/strong&gt;, dentro de su configuración podremos establecer manualmente nuestro &lt;em&gt;proxy&lt;/em&gt;.ç&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_Configuración_de_un_proxy_Squid/proxyfirefox.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Establecido el &lt;em&gt;proxy&lt;/em&gt; vamos a probar a acceder a diferentes webs como pueden ser &lt;a href=&quot;https://javierpzh.github.io/&quot;&gt;javierpzh.github.io&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com&quot;&gt;www.youtube.com&lt;/a&gt; y &lt;a href=&quot;https://www.google.com/&quot;&gt;www.google.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Una vez comprobamos que podemos acceder correctamente, vamos a revisar el proceso que dejamos en ejecución en nuestra terminal:&lt;/p&gt;

&lt;pre&gt;
root@proxy:~# tail -f /var/log/squid/access.log
1613985923.460     12 192.168.200.1 TCP_TUNNEL/200 39 CONNECT fonts.googleapis.com:443 - HIER_DIRECT/142.250.184.170 -
1613985923.466     19 192.168.200.1 TCP_TUNNEL/200 39 CONNECT fonts.googleapis.com:443 - HIER_DIRECT/142.250.184.170 -
1613985923.479     32 192.168.200.1 TCP_TUNNEL/200 39 CONNECT maxcdn.bootstrapcdn.com:443 - HIER_DIRECT/209.197.3.15 -
1613985923.511      0 192.168.200.1 NONE/000 0 NONE error:transaction-end-before-headers - HIER_NONE/- -
1613985923.521     10 192.168.200.1 TCP_TUNNEL/200 39 CONNECT fonts.gstatic.com:443 - HIER_DIRECT/216.58.211.227 -
1613985923.521     11 192.168.200.1 TCP_TUNNEL/200 39 CONNECT fonts.gstatic.com:443 - HIER_DIRECT/216.58.211.227 -
1613985926.218     98 192.168.200.1 TCP_TUNNEL/200 5461 CONNECT fonts.googleapis.com:443 - HIER_DIRECT/142.250.184.170 -
1613985926.221    102 192.168.200.1 TCP_TUNNEL/200 5121 CONNECT fonts.googleapis.com:443 - HIER_DIRECT/142.250.184.170 -
1613985926.785     10 192.168.200.1 TCP_TUNNEL/200 39 CONNECT fonts.gstatic.com:443 - HIER_DIRECT/216.58.211.227 -
1613985926.880     18 192.168.200.1 TCP_TUNNEL/200 39 CONNECT lh3.googleusercontent.com:443 - HIER_DIRECT/142.250.184.1 -
1613985928.513    170 192.168.200.1 TCP_TUNNEL/200 10059 CONNECT yt3.ggpht.com:443 - HIER_DIRECT/142.250.184.1 -
1613985932.983     17 192.168.200.1 TCP_TUNNEL/200 39 CONNECT lh3.googleusercontent.com:443 - HIER_DIRECT/142.250.184.1 -
1613985932.987     21 192.168.200.1 TCP_TUNNEL/200 39 CONNECT ssl.gstatic.com:443 - HIER_DIRECT/216.58.215.131 -
1613985932.987     21 192.168.200.1 TCP_TUNNEL/200 39 CONNECT fonts.gstatic.com:443 - HIER_DIRECT/216.58.211.227 -
&lt;/pre&gt;

&lt;p&gt;Vemos como nos muestra los &lt;em&gt;logs&lt;/em&gt; referentes a los accesos que acabamos de realizar.&lt;/p&gt;

&lt;p&gt;Ahora, vamos a configurar nuestra máquina para que haga uso del &lt;em&gt;proxy Squid&lt;/em&gt;, pero esta vez la configuración no la haremos en el navegador, sino en el propio sistema.&lt;/p&gt;

&lt;p&gt;Para ello, antes, vamos a dirigirnos de nuevo a la configuración del navegador, a la parte de la configuración del &lt;em&gt;proxy&lt;/em&gt; e indicaremos que use la configuración &lt;em&gt;proxy&lt;/em&gt; del sistema.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_Configuración_de_un_proxy_Squid/proxyfirefox2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Hecho esto, tendremos que configurar el sistema para que por defecto utilice nuestro &lt;em&gt;proxy&lt;/em&gt;. Este proceso lo realizaremos en el apartado &lt;strong&gt;Configuración del sistema&lt;/strong&gt;, en la sección de &lt;strong&gt;Red&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_Configuración_de_un_proxy_Squid/configuracionred.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Configuraremos el &lt;em&gt;proxy&lt;/em&gt; de manera manual de la siguiente manera:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_Configuración_de_un_proxy_Squid/configuracionredproxy.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Con esto habríamos terminado de configurar nuestro sistema para que utilice el &lt;em&gt;proxy Squid&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Antes de dirigirnos a nuestro navegador para acceder a las webs, en la terminal, volveremos a dejar el siguiente proceso activo para ver a tiempo real los &lt;em&gt;logs&lt;/em&gt; de acceso al &lt;em&gt;proxy&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
tail -f /var/log/squid/access.log
&lt;/pre&gt;

&lt;p&gt;Establecido el &lt;em&gt;proxy&lt;/em&gt; vamos a probar a acceder a diferentes webs como pueden ser &lt;a href=&quot;https://github.com&quot;&gt;github.com&lt;/a&gt;, y &lt;a href=&quot;https://hub.docker.com/&quot;&gt;hub.docker.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Una vez comprobamos que podemos acceder correctamente, vamos a revisar el proceso que dejamos en ejecución en nuestra terminal:&lt;/p&gt;

&lt;pre&gt;
root@proxy:~# tail -f /var/log/squid/access.log
1613986400.038    327 192.168.200.1 TCP_TUNNEL/200 39 CONNECT github.githubassets.com:443 - HIER_DIRECT/185.199.111.154 -
1613986400.038    326 192.168.200.1 TCP_TUNNEL/200 39 CONNECT github.githubassets.com:443 - HIER_DIRECT/185.199.111.154 -
1613986400.038    249 192.168.200.1 TCP_TUNNEL/200 39 CONNECT github.githubassets.com:443 - HIER_DIRECT/185.199.111.154 -
1613986400.039    328 192.168.200.1 TCP_TUNNEL/200 39 CONNECT github.githubassets.com:443 - HIER_DIRECT/185.199.111.154 -
1613986400.039    249 192.168.200.1 TCP_TUNNEL/200 39 CONNECT github.githubassets.com:443 - HIER_DIRECT/185.199.111.154 -
1613986400.045    113 192.168.200.1 TCP_TUNNEL/200 39 CONNECT github.githubassets.com:443 - HIER_DIRECT/185.199.111.154 -
1613986400.045    256 192.168.200.1 TCP_TUNNEL/200 39 CONNECT github.githubassets.com:443 - HIER_DIRECT/185.199.111.154 -
1613986400.045    256 192.168.200.1 TCP_TUNNEL/200 39 CONNECT github.githubassets.com:443 - HIER_DIRECT/185.199.111.154 -
1613986400.045    334 192.168.200.1 TCP_TUNNEL/200 39 CONNECT github.githubassets.com:443 - HIER_DIRECT/185.199.111.154 -
1613986400.045    334 192.168.200.1 TCP_TUNNEL/200 39 CONNECT github.githubassets.com:443 - HIER_DIRECT/185.199.111.154 -
1613986400.098    386 192.168.200.1 TCP_TUNNEL/200 6018 CONNECT avatars.githubusercontent.com:443 - HIER_DIRECT/185.199.110.133 -
1613986400.099    387 192.168.200.1 TCP_TUNNEL/200 7055 CONNECT avatars.githubusercontent.com:443 - HIER_DIRECT/185.199.110.133 -
1613986400.244    532 192.168.200.1 TCP_TUNNEL/200 25697 CONNECT avatars.githubusercontent.com:443 - HIER_DIRECT/185.199.110.133 -
1613986408.461    236 192.168.200.1 TCP_MISS/200 1171 POST http://ocsp.sca1b.amazontrust.com/ - HIER_DIRECT/54.230.104.69 application/ocsp-response
1613986408.795   8858 192.168.200.1 TCP_TUNNEL/200 4450 CONNECT alive.github.com:443 - HIER_DIRECT/140.82.113.25 -
1613986408.981    289 192.168.200.1 TCP_TUNNEL/200 19141 CONNECT d36jcksde1wxzq.cloudfront.net:443 - HIER_DIRECT/54.230.104.29 -
1613986409.034    342 192.168.200.1 TCP_TUNNEL/200 116639 CONNECT d36jcksde1wxzq.cloudfront.net:443 - HIER_DIRECT/54.230.104.29 -
1613986409.113    421 192.168.200.1 TCP_TUNNEL/200 794202 CONNECT d36jcksde1wxzq.cloudfront.net:443 - HIER_DIRECT/54.230.104.29 -
1613986413.616   5897 192.168.200.1 TCP_TUNNEL/200 6879 CONNECT hub.docker.com:443 - HIER_DIRECT/34.202.113.184 -
1613986416.414  61653 192.168.200.1 TCP_TUNNEL/200 4246 CONNECT profile.accounts.firefox.com:443 - HIER_DIRECT/54.148.210.55 -
1613986463.364  62781 192.168.200.1 TCP_TUNNEL/200 4225 CONNECT collector.githubapp.com:443 - HIER_DIRECT/3.218.144.29 -
1613986475.322  66631 192.168.200.1 TCP_TUNNEL/200 82917 CONNECT cdn-pci.optimizely.com:443 - HIER_DIRECT/104.126.101.248 -
1613986475.571     68 192.168.200.1 TCP_MISS/200 1087 POST http://ocsp.sectigo.com/ - HIER_DIRECT/151.139.128.14 application/ocsp-response
1613986476.296      0 192.168.200.1 NONE/000 0 NONE error:transaction-end-before-headers - HIER_NONE/- -
1613986476.307     11 192.168.200.1 TCP_TUNNEL/200 39 CONNECT fonts.gstatic.com:443 - HIER_DIRECT/216.58.211.227 -
1613986476.308     19 192.168.200.1 TCP_TUNNEL/200 39 CONNECT fonts.gstatic.com:443 - HIER_DIRECT/216.58.211.227 -
1613986477.279     60 192.168.200.1 TCP_MISS/200 895 POST http://ocsp.pki.goog/gts1d2 - HIER_DIRECT/216.58.211.227 application/ocsp-response
1613986477.526    269 192.168.200.1 TCP_TUNNEL/200 13094 CONNECT d1q6f0aelx0por.cloudfront.net:443 - HIER_DIRECT/54.230.104.101 -
1613986477.530    273 192.168.200.1 TCP_TUNNEL/200 22145 CONNECT d1q6f0aelx0por.cloudfront.net:443 - HIER_DIRECT/54.230.104.101 -
1613986477.531    274 192.168.200.1 TCP_TUNNEL/200 15931 CONNECT d1q6f0aelx0por.cloudfront.net:443 - HIER_DIRECT/54.230.104.101 -
1613986477.543    286 192.168.200.1 TCP_TUNNEL/200 13682 CONNECT d1q6f0aelx0por.cloudfront.net:443 - HIER_DIRECT/54.230.104.101 -
1613986477.597    353 192.168.200.1 TCP_TUNNEL/200 22513 CONNECT d1q6f0aelx0por.cloudfront.net:443 - HIER_DIRECT/54.230.104.101 -
1613986477.789     88 192.168.200.1 TCP_MISS/200 993 POST http://ocsp.digicert.com/ - HIER_DIRECT/93.184.220.29 application/ocsp-response
1613986478.201    147 192.168.200.1 TCP_MISS/200 895 POST http://ocsp.pki.goog/gts1o1core - HIER_DIRECT/216.58.211.227 application/ocsp-response
1613986478.470     18 192.168.200.1 TCP_TUNNEL/200 39 CONNECT www.gstatic.com:443 - HIER_DIRECT/142.250.184.3 -
1613986482.408   7070 192.168.200.1 TCP_TUNNEL/200 6133 CONNECT hub.docker.com:443 - HIER_DIRECT/34.202.113.184 -
1613986482.444   6668 192.168.200.1 TCP_TUNNEL/200 1808 CONNECT hub.docker.com:443 - HIER_DIRECT/34.202.113.184 -
1613986486.742 119497 192.168.200.1 TCP_TUNNEL/200 1043044 CONNECT abs.twimg.com:443 - HIER_DIRECT/152.199.21.141 -
&lt;/pre&gt;

&lt;p&gt;Vemos como nos muestra los &lt;em&gt;logs&lt;/em&gt; referentes a los accesos que acabamos de realizar.&lt;/p&gt;

&lt;h4 id=&quot;configuración-en-el-cliente-interno-para-que-utilice-el-proxy-squid&quot;&gt;Configuración en el cliente interno para que utilice el proxy Squid&lt;/h4&gt;

&lt;p&gt;Configuraremos nuestro cliente interno para que también navegue a través de nuestro &lt;em&gt;proxy&lt;/em&gt;. Este cliente no posee entorno gráfico, por lo que la configuración se llevará a cabo por consola.&lt;/p&gt;

&lt;p&gt;En la parte del servidor, tan sólo debemos asegurarnos que la directiva siguiente esté habilitada:&lt;/p&gt;

&lt;pre&gt;
http_access allow localnet
&lt;/pre&gt;

&lt;p&gt;Para configurar un &lt;em&gt;proxy&lt;/em&gt; en un sistema &lt;em&gt;Linux&lt;/em&gt;, bastará con configurar una variable de entorno. Dicha variable de entorno recibe el nombre &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http_proxy&lt;/code&gt;. La sintaxis para establecer esta variable de entorno es la siguiente:&lt;/p&gt;

&lt;pre&gt;
export http_proxy=http://(IP/URL):(PUERTO)/
&lt;/pre&gt;

&lt;p&gt;En mi caso, como mi &lt;em&gt;servidor proxy&lt;/em&gt; posee la dirección IP interna &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.0.0.10&lt;/code&gt;, introduzco la siguiente línea:&lt;/p&gt;

&lt;pre&gt;
root@buster:~# export http_proxy=http://10.0.0.10:3128/

root@buster:~# echo $http_proxy
http://10.0.0.10:3128/
&lt;/pre&gt;

&lt;p&gt;Hecho esto, estaremos navegando por el &lt;em&gt;proxy&lt;/em&gt;, así que vamos a hacer una prueba accediendo a cualquier web, pero antes dejaremos el siguiente proceso activo para ver a tiempo real los &lt;em&gt;logs&lt;/em&gt; de acceso al &lt;em&gt;proxy&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
tail -f /var/log/squid/access.log
&lt;/pre&gt;

&lt;p&gt;Accedemos a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.google.es&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;
root@buster:~# wget www.google.es
--2021-03-02 20:44:15--  http://www.google.es/
Connecting to 10.0.0.10:3128... connected.
Proxy request sent, awaiting response... 200 OK
Length: unspecified [text/html]
Saving to: ‘index.html’

index.html                    [ &amp;lt;=&amp;gt;                                  ]  13.60K  --.-KB/s    in 0.009s  

2021-03-02 20:44:15 (1.49 MB/s) - ‘index.html’ saved [13930]
&lt;/pre&gt;

&lt;p&gt;Una vez comprobamos que podemos acceder correctamente, vamos a revisar el proceso que dejamos en ejecución en nuestra terminal:&lt;/p&gt;

&lt;pre&gt;
root@proxy:~# tail -f /var/log/squid/access.log
1614717855.566    155 10.0.0.11 TCP_MISS/200 14718 GET http://www.google.es/ - HIER_DIRECT/142.250.184.3 text/html
&lt;/pre&gt;

&lt;p&gt;Podemos ver que efectivamente nuestro cliente interno está navegando por nuestro &lt;em&gt;proxy&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;filtros-de-acceso&quot;&gt;Filtros de acceso&lt;/h4&gt;

&lt;p&gt;En este apartado vamos a ver como podemos configurar &lt;em&gt;Squid&lt;/em&gt; para implementar distintos filtros que controlen el acceso a las diferentes webs.&lt;/p&gt;

&lt;p&gt;En primer lugar, implementaremos un filtro que funcionará como lista negra, es decir, limitaremos el acceso únicamente a determinadas webs.&lt;/p&gt;

&lt;p&gt;Por ejemplo, imaginemos que somos los administradores de una empresa y queremos evitar que nuestros trabajadores accedan a sus redes sociales para que así no puedan distraerse del trabajo. Esto lo podemos solucionar con una &lt;em&gt;blacklist&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Para añadir este tipo de filtro a nuestro &lt;em&gt;proxy&lt;/em&gt;, nos dirigiremos al fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/squid/squid.conf&lt;/code&gt; y en él, en la parte de las &lt;em&gt;ACLs&lt;/em&gt; introduciremos las siguientes líneas:&lt;/p&gt;

&lt;pre&gt;
#LISTA NEGRA
acl lista-negra dstdomain &quot;/etc/squid/listanegra&quot;

http_access deny lista-negra
&lt;/pre&gt;

&lt;p&gt;De manera que el resultado sería algo así:&lt;/p&gt;

&lt;pre&gt;
acl localnet src 0.0.0.1-0.255.255.255  # RFC 1122 &quot;this&quot; network (LAN)
acl localnet src 10.0.0.0/8             # RFC 1918 local private network (LAN)
acl localnet src 100.64.0.0/10          # RFC 6598 shared address space (CGN)
acl localnet src 169.254.0.0/16         # RFC 3927 link-local (directly plugged) machines
acl localnet src 172.16.0.0/12          # RFC 1918 local private network (LAN)
acl localnet src 192.168.0.0/16         # RFC 1918 local private network (LAN)
acl localnet src fc00::/7               # RFC 4193 local private network range
acl localnet src fe80::/10              # RFC 4291 link-local (directly plugged) machines

acl localnet src 172.22.9.28
acl localnet src 192.168.15.151

acl SSL_ports port 443
acl Safe_ports port 80          # http
acl Safe_ports port 21          # ftp
acl Safe_ports port 443         # https
acl Safe_ports port 70          # gopher
acl Safe_ports port 210         # wais
acl Safe_ports port 1025-65535  # unregistered ports
acl Safe_ports port 280         # http-mgmt
acl Safe_ports port 488         # gss-http
acl Safe_ports port 591         # filemaker
acl Safe_ports port 777         # multiling http
acl CONNECT method CONNECT

#LISTA NEGRA
acl lista-negra dstdomain &quot;/etc/squid/listanegra&quot;

http_access deny lista-negra
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar que hemos hecho referencia al fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/squid/listanegra&lt;/code&gt;. Este fichero será el que crearemos y en él indicaremos las URLs que estarán bloqueadas. En mi caso, si visualizamos su contenido:&lt;/p&gt;

&lt;pre&gt;
root@proxy:~# cat /etc/squid/listanegra
.facebook.com
&lt;/pre&gt;

&lt;p&gt;Hecho esto, reiniciaremos el servicio:&lt;/p&gt;

&lt;pre&gt;
systemctl restart squid
&lt;/pre&gt;

&lt;p&gt;Antes de dirigirnos a nuestro navegador para acceder a la web de &lt;em&gt;Facebook&lt;/em&gt;, en la terminal, volveremos a dejar el siguiente proceso activo para ver a tiempo real los &lt;em&gt;logs&lt;/em&gt; de acceso al &lt;em&gt;proxy&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
tail -f /var/log/squid/access.log
&lt;/pre&gt;

&lt;p&gt;En mi caso, sigo teniendo establecida la configuración del &lt;em&gt;proxy&lt;/em&gt;, de manera que vamos a probar a acceder a &lt;a href=&quot;https://www.facebook.com/&quot;&gt;www.facebook.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_Configuración_de_un_proxy_Squid/facebook.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Vemos que no nos permite acceder a la web, por lo que, parece que el funcionamiento es el correcto, pero ahora, voy a probar a acceder a cualquier otra web, para asegurarme que el &lt;em&gt;proxy&lt;/em&gt; solo esté bloqueando la conexión a &lt;em&gt;Facebook&lt;/em&gt; y no a todas las webs. Intento acceder a &lt;a href=&quot;https://www.amazon.es/&quot;&gt;www.amazon.es&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_Configuración_de_un_proxy_Squid/amazon.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Una vez comprobamos que a ésta sí nos permite acceder, vamos a revisar el proceso que dejamos en ejecución en nuestra terminal:&lt;/p&gt;

&lt;pre&gt;
root@proxy:~# tail -f /var/log/squid/access.log
1613988887.582      0 192.168.200.1 TCP_DENIED/403 3968 CONNECT www.facebook.com:443 - HIER_NONE/- text/html
1613988891.778    437 192.168.200.1 TCP_TUNNEL/200 39 CONNECT images-eu.ssl-images-amazon.com:443 - HIER_DIRECT/52.84.68.73 -
1613988891.778    437 192.168.200.1 TCP_TUNNEL/200 39 CONNECT images-eu.ssl-images-amazon.com:443 - HIER_DIRECT/52.84.68.73 -
1613988892.131    178 192.168.200.1 TCP_TUNNEL/200 13411 CONNECT m.media-amazon.com:443 - HIER_DIRECT/52.84.68.73 -
1613988892.151    197 192.168.200.1 TCP_TUNNEL/200 12365 CONNECT m.media-amazon.com:443 - HIER_DIRECT/52.84.68.73 -
1613988892.152    199 192.168.200.1 TCP_TUNNEL/200 14711 CONNECT m.media-amazon.com:443 - HIER_DIRECT/52.84.68.73 -
1613988892.155    201 192.168.200.1 TCP_TUNNEL/200 14846 CONNECT m.media-amazon.com:443 - HIER_DIRECT/52.84.68.73 -
1613988892.166    127 192.168.200.1 TCP_TUNNEL/200 5553 CONNECT m.media-amazon.com:443 - HIER_DIRECT/52.84.68.73 -
1613988892.174    220 192.168.200.1 TCP_TUNNEL/200 11651 CONNECT m.media-amazon.com:443 - HIER_DIRECT/52.84.68.73 -
1613988892.673    160 192.168.200.1 TCP_MISS/200 1170 POST http://ocsp.sca1b.amazontrust.com/ - HIER_DIRECT/13.33.234.111 application/ocsp-response
1613988892.681    169 192.168.200.1 TCP_MISS/200 1170 POST http://ocsp.sca1b.amazontrust.com/ - HIER_DIRECT/13.33.234.111 application/ocsp-response
1613988892.689    177 192.168.200.1 TCP_MISS/200 1170 POST http://ocsp.sca1b.amazontrust.com/ - HIER_DIRECT/13.33.234.111 application/ocsp-response
1613988892.690    178 192.168.200.1 TCP_MISS/200 1170 POST http://ocsp.sca1b.amazontrust.com/ - HIER_DIRECT/13.33.234.111 application/ocsp-response
1613988892.739    430 192.168.200.1 TCP_TUNNEL/200 6107 CONNECT fls-eu.amazon.es:443 - HIER_DIRECT/3.248.163.40 -
1613988892.742    434 192.168.200.1 TCP_TUNNEL/200 6107 CONNECT fls-eu.amazon.es:443 - HIER_DIRECT/3.248.163.40 -
1613988892.749    440 192.168.200.1 TCP_TUNNEL/200 6107 CONNECT fls-eu.amazon.es:443 - HIER_DIRECT/3.248.163.40 -
1613988892.749    440 192.168.200.1 TCP_TUNNEL/200 6107 CONNECT fls-eu.amazon.es:443 - HIER_DIRECT/3.248.163.40 -
1613988892.773    261 192.168.200.1 TCP_MISS/200 1170 POST http://ocsp.sca1b.amazontrust.com/ - HIER_DIRECT/13.33.234.111 application/ocsp-response
1613988892.830    522 192.168.200.1 TCP_TUNNEL/200 6107 CONNECT fls-eu.amazon.es:443 - HIER_DIRECT/3.248.163.40 -
1613988894.470    137 192.168.200.1 TCP_TUNNEL/200 30872 CONNECT images-na.ssl-images-amazon.com:443 - HIER_DIRECT/52.84.68.73 -
&lt;/pre&gt;

&lt;p&gt;¡Perfecto! Ya tendríamos funcionando nuestra lista negra.&lt;/p&gt;

&lt;p&gt;Ya sabemos como podríamos bloquear el acceso a determinadas webs, pero, ¿y si lo que quisiéramos es bloquear el acceso a todas las webs, menos a las que nosotros especifiquemos? O lo que sería lo mismo, implementar una lista blanca.&lt;/p&gt;

&lt;p&gt;Por ejemplo, imaginemos que somos los administradores de una empresa y queremos que nuestros trabajadores solo puedan acceder a determinadas webs. Esto lo podemos solucionar con una &lt;em&gt;whitelist&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Para añadir este tipo de filtro a nuestro &lt;em&gt;proxy&lt;/em&gt;, nos dirigiremos al fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/squid/squid.conf&lt;/code&gt; y en él, en la parte de las &lt;em&gt;ACLs&lt;/em&gt; introduciremos las siguientes líneas:&lt;/p&gt;

&lt;pre&gt;
#LISTA BLANCA
acl lista-blanca dstdomain &quot;/etc/squid/listablanca&quot;

http_access allow lista-blanca
&lt;/pre&gt;

&lt;p&gt;De manera que el resultado sería algo así:&lt;/p&gt;

&lt;pre&gt;
acl localnet src 0.0.0.1-0.255.255.255  # RFC 1122 &quot;this&quot; network (LAN)
acl localnet src 10.0.0.0/8             # RFC 1918 local private network (LAN)
acl localnet src 100.64.0.0/10          # RFC 6598 shared address space (CGN)
acl localnet src 169.254.0.0/16         # RFC 3927 link-local (directly plugged) machines
acl localnet src 172.16.0.0/12          # RFC 1918 local private network (LAN)
acl localnet src 192.168.0.0/16         # RFC 1918 local private network (LAN)
acl localnet src fc00::/7               # RFC 4193 local private network range
acl localnet src fe80::/10              # RFC 4291 link-local (directly plugged) machines

acl localnet src 172.22.9.28
acl localnet src 192.168.15.151

acl SSL_ports port 443
acl Safe_ports port 80          # http
acl Safe_ports port 21          # ftp
acl Safe_ports port 443         # https
acl Safe_ports port 70          # gopher
acl Safe_ports port 210         # wais
acl Safe_ports port 1025-65535  # unregistered ports
acl Safe_ports port 280         # http-mgmt
acl Safe_ports port 488         # gss-http
acl Safe_ports port 591         # filemaker
acl Safe_ports port 777         # multiling http
acl CONNECT method CONNECT

#LISTA NEGRA
#acl lista-negra dstdomain &quot;/etc/squid/listanegra&quot;

#http_access deny lista-negra

#LISTA BLANCA
acl lista-blanca dstdomain &quot;/etc/squid/listablanca&quot;

http_access allow lista-blanca
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar que hemos hecho referencia al fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/squid/listablanca&lt;/code&gt;. Este fichero será el que crearemos y en él indicaremos las URLs que estarán permitidas. En mi caso, si visualizamos su contenido:&lt;/p&gt;

&lt;pre&gt;
root@proxy:~# cat /etc/squid/listablanca
.javierpzh.github.io
&lt;/pre&gt;

&lt;p&gt;Ya casi habríamos terminado, pero analicemos el cambio que hemos hecho. Hemos permitido el acceso a una determinada web, pero no hemos bloqueado el acceso a las demás webs. Para hacer esto y bloquear todas las webs menos las que especifiquemos en nuestra &lt;em&gt;whitelist&lt;/em&gt;, debemos cambiar el valor de la siguiente línea:&lt;/p&gt;

&lt;pre&gt;
http_access deny localnet
&lt;/pre&gt;

&lt;p&gt;Hecho esto, reiniciaremos el servicio:&lt;/p&gt;

&lt;pre&gt;
systemctl restart squid
&lt;/pre&gt;

&lt;p&gt;Antes de dirigirnos a nuestro navegador para acceder a mi web, en la terminal, volveremos a dejar el siguiente proceso activo para ver a tiempo real los &lt;em&gt;logs&lt;/em&gt; de acceso al &lt;em&gt;proxy&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
tail -f /var/log/squid/access.log
&lt;/pre&gt;

&lt;p&gt;En mi caso, sigo teniendo establecida la configuración del &lt;em&gt;proxy&lt;/em&gt;, de manera que vamos a probar a acceder a &lt;a href=&quot;https://javierpzh.github.io/&quot;&gt;javierpzh.github.io&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_Configuración_de_un_proxy_Squid/mipagina.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Vemos que nos permite acceder a la web, por lo que, de momento el funcionamiento es el correcto, pero ahora, para terminar de comprobarlo, voy a probar a acceder a cualquier otra web, para asegurarme que el &lt;em&gt;proxy&lt;/em&gt; esté bloqueando cualquier tipo de conexión que no sea a mi web. Intento acceder a &lt;a href=&quot;https://www.amazon.es/&quot;&gt;www.amazon.es&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_Configuración_de_un_proxy_Squid/amazon2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Una vez comprobamos que a ésta web no nos permite acceder, vamos a revisar el proceso que dejamos en ejecución en nuestra terminal:&lt;/p&gt;

&lt;pre&gt;
root@proxy:~# tail -f /var/log/squid/access.log
1614082229.707   1058 192.168.200.1 TCP_TUNNEL/200 39 CONNECT javierpzh.github.io:443 - HIER_DIRECT/185.199.110.153 -
1614082237.344      0 192.168.200.1 TCP_DENIED/403 3959 CONNECT www.amazon.es:443 - HIER_NONE/- text/html
&lt;/pre&gt;

&lt;p&gt;¡Perfecto! Ya tendríamos funcionando nuestra lista blanca.&lt;/p&gt;</content><author><name></name></author><summary type="html">En este artículo vamos a instalar un proxy Squid para configurar nuestro cliente para que acceda a internet por medio de este proxy.</summary></entry><entry><title type="html">Vpn Con Openvpn Y Certificados X509</title><link href="https://www.javierpzh.com/blog/VPN-con-OpenVPN-y-certificados-x509" rel="alternate" type="text/html" title="Vpn Con Openvpn Y Certificados X509" /><published>2021-03-02T00:00:00+01:00</published><updated>2021-03-02T00:00:00+01:00</updated><id>https://www.javierpzh.com/blog/VPN-con-OpenVPN-y-certificados-x509</id><content type="html" xml:base="https://www.javierpzh.com/blog/VPN-con-OpenVPN-y-certificados-x509">&lt;h2 id=&quot;qué-es-una-vpn&quot;&gt;¿Qué es una VPN?&lt;/h2&gt;

&lt;p&gt;Una &lt;strong&gt;VPN (Virtual Private Network)&lt;/strong&gt; es una tecnología que permite una conexión segura a otra red mediante una red pública. Permite, además, enviar y recibir datos como si se formase parte de la red local o privada, obteniendo así las funcionalidades que dicha red ofrece.&lt;/p&gt;

&lt;p&gt;También se puede hacer referencia a una red privada virtual como un &lt;strong&gt;túnel&lt;/strong&gt;, pues realmente lo que hace es crear un canal para el tráfico entre el cliente y el servidor VPN en el que su contenido corre independientemente del resto y de manera cifrada.&lt;/p&gt;

&lt;p&gt;Existen cuatro tipos según su uso:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;VPN de acceso remoto&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;VPN Site to Site&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;tunneling&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;VPN over LAN&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;vpn-de-acceso-remoto-con-openvpn-y-certificados-x509&quot;&gt;VPN de acceso remoto con OpenVPN y certificados x509&lt;/h2&gt;

&lt;p&gt;En el siguiente supuesto práctico vamos a interconectar dos máquinas que están en redes separadas, y para ello vamos a crear una VPN con el rango &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.99.99.0/32&lt;/code&gt;. Dividiremos la configuración en dos partes: la configuración del servidor, que también se comportará como autoridad certificadora, y la configuración del cliente.&lt;/p&gt;

&lt;p&gt;He creado los siguientes escenarios:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Fichero Vagrantfile Servidor:&lt;/strong&gt; &lt;a href=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sad_VPN_con_OpenVPN_y_certificados_x509/Vagrantfileservidor.txt&quot;&gt;Vagrantfile&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Fichero Vagrantfile Cliente:&lt;/strong&gt; &lt;a href=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sad_VPN_con_OpenVPN_y_certificados_x509/Vagrantfilecliente.txt&quot;&gt;Vagrantfile&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;escenario-servidor&quot;&gt;Escenario Servidor&lt;/h5&gt;

&lt;p&gt;En el escenario del &lt;strong&gt;servidor&lt;/strong&gt; hay que realizar las siguientes modificaciones:&lt;/p&gt;

&lt;p&gt;En la máquina &lt;strong&gt;servidor&lt;/strong&gt;, instalar el siguiente paquete:&lt;/p&gt;

&lt;pre&gt;
apt install openvpn -y
&lt;/pre&gt;

&lt;p&gt;También debemos establecer el &lt;em&gt;bit de forward&lt;/em&gt; a 1:&lt;/p&gt;

&lt;pre&gt;
sysctl -w net.ipv4.ip_forward=1
&lt;/pre&gt;

&lt;p&gt;En la máquina &lt;strong&gt;cliente&lt;/strong&gt;, debemos borrar la puerta de enlace predeterminada y establecer como &lt;em&gt;gateway&lt;/em&gt; la máquina &lt;em&gt;servidor&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
ip r del default
ip r add default via 192.168.100.10 dev eth1
&lt;/pre&gt;

&lt;p&gt;Hecho.&lt;/p&gt;

&lt;h5 id=&quot;escenario-cliente&quot;&gt;Escenario Cliente&lt;/h5&gt;

&lt;p&gt;En el escenario del &lt;strong&gt;cliente&lt;/strong&gt; hay que instalar el siguiente paquete:&lt;/p&gt;

&lt;pre&gt;
apt install openvpn -y
&lt;/pre&gt;

&lt;p&gt;Explicado esto, empezaremos con la propia configuración del ejercicio.&lt;/p&gt;

&lt;h4 id=&quot;configuración-de-openvpn&quot;&gt;Configuración de OpenVPN&lt;/h4&gt;

&lt;p&gt;En primer lugar, voy a crear un nuevo fichero llamado &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vars&lt;/code&gt; a partir del fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vars.example&lt;/code&gt;. Ambos se encuentran en la ruta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/usr/share/easy-rsa&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;
root@vpn:~# cd /usr/share/easy-rsa/

root@vpn:/usr/share/easy-rsa# cp vars.example vars

root@vpn:/usr/share/easy-rsa# nano vars
&lt;/pre&gt;

&lt;p&gt;Debemos modificar una serie de líneas en este fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vars&lt;/code&gt;, que por defecto vienen comentadas. Su resultado final sería el siguiente:&lt;/p&gt;

&lt;pre&gt;
root@vpn:/usr/share/easy-rsa# cat vars
...
set_var EASYRSA_REQ_COUNTRY	  &quot;ES&quot;
set_var EASYRSA_REQ_PROVINCE  &quot;Sevilla&quot;
set_var EASYRSA_REQ_CITY	    &quot;Dos Hermanas&quot;
set_var EASYRSA_REQ_ORG		    &quot;JAVIERPZH ORG&quot;
set_var EASYRSA_REQ_EMAIL	    &quot;javierperezhidalgo01@gmail.com&quot;
set_var EASYRSA_REQ_OU		    &quot;Ejercicio&quot;
...
&lt;/pre&gt;

&lt;p&gt;Hecho esto, vamos a proceder con la creación de la &lt;strong&gt;CA&lt;/strong&gt;, para ello, antes es necesario ejecutar algunos comandos.&lt;/p&gt;

&lt;p&gt;En primer lugar, tenemos que crear el directorio de salida (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.../pki/&lt;/code&gt;), donde se irán almacenando los distintos ficheros:&lt;/p&gt;

&lt;pre&gt;
root@vpn:/usr/share/easy-rsa# ./easyrsa init-pki

Note: using Easy-RSA configuration from: ./vars

init-pki complete; you may now create a CA or requests.
Your newly created PKI dir is: /usr/share/easy-rsa/pki
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar como nos ha creado un nuevo directorio llamado &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pki&lt;/code&gt;. En este directorio se almacenarán los certificados firmados de los clientes, del servidor, de la propia CA, …&lt;/p&gt;

&lt;p&gt;Y por último, antes de crear la propia &lt;strong&gt;CA&lt;/strong&gt;, debemos generar una clave &lt;strong&gt;Diffie-Helman&lt;/strong&gt;. Para esta clave no nos pedirá ninguna frase de paso, ya que no requiere de la confianza de la CA. Esta clave consiste en un algoritmo criptográfico, cuyo fin es muy similar a los usados en otros protocolos como &lt;em&gt;HTTPs&lt;/em&gt;, es decir, cifrar de forma asimétrica la conexión.&lt;/p&gt;

&lt;p&gt;Para generar la clave, utilizaremos el parámetro &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gen-dh&lt;/code&gt;. Puede que tarde cierto tiempo, pero es normal, ya que &lt;strong&gt;Diffie-Hellman&lt;/strong&gt; es un algoritmo de encriptación duro.&lt;/p&gt;

&lt;pre&gt;
root@vpn:/usr/share/easy-rsa# ./easyrsa gen-dh

Note: using Easy-RSA configuration from: ./vars

Using SSL: openssl OpenSSL 1.1.1d  10 Sep 2019
Generating DH parameters, 2048 bit long safe prime, generator 2
This is going to take a long time

...

DH parameters of size 2048 created at /usr/share/easy-rsa/pki/dh.pem
&lt;/pre&gt;

&lt;p&gt;Ahora sí, vamos a crear mi &lt;strong&gt;Autoridad Certificadora (CA)&lt;/strong&gt;, para ello empleamos el siguiente comando:&lt;/p&gt;

&lt;pre&gt;

Note: using Easy-RSA configuration from: ./vars

Using SSL: openssl OpenSSL 1.1.1d  10 Sep 2019

Enter New CA Key Passphrase:
Re-Enter New CA Key Passphrase:
Generating RSA private key, 2048 bit long modulus (2 primes)
........+++++
..........................+++++
e is 65537 (0x010001)
Can't load /usr/share/easy-rsa/pki/.rnd into RNG
140626734470272:error:2406F079:random number generator:RAND_load_file:Cannot open file:../crypto/rand/randfile.c:98:Filename=/usr/share/easy-rsa/pki/.rnd
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Common Name (eg: your user, host, or server name) [Easy-RSA CA]:Javier Perez

CA creation complete and you may now import and sign cert requests.
Your new CA certificate file for publishing is at:
/usr/share/easy-rsa/pki/ca.crt
&lt;/pre&gt;

&lt;p&gt;Una vez disponemos de nuestra &lt;strong&gt;Autoridad Certificadora&lt;/strong&gt;, es el momento de crear y firmar con nuestra nueva CA, el certificado que utilizará nuestro &lt;strong&gt;servidor VPN&lt;/strong&gt;. El proceso es el siguiente:&lt;/p&gt;

&lt;pre&gt;
root@servidor:/usr/share/easy-rsa# ./easyrsa gen-req server

Note: using Easy-RSA configuration from: ./vars

Using SSL: openssl OpenSSL 1.1.1d  10 Sep 2019
Generating a RSA private key
.......................................+++++
....................................+++++
writing new private key to '/usr/share/easy-rsa/pki/private/server.key.K03xc5Q5bC'
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Common Name (eg: your user, host, or server name) [server]:Javier Perez

Keypair and certificate request completed. Your files are:
req: /usr/share/easy-rsa/pki/reqs/server.req
key: /usr/share/easy-rsa/pki/private/server.key

root@servidor:/usr/share/easy-rsa# ./easyrsa sign-req server server

Note: using Easy-RSA configuration from: ./vars

Using SSL: openssl OpenSSL 1.1.1d  10 Sep 2019


You are about to sign the following certificate.
Please check over the details shown below for accuracy. Note that this request
has not been cryptographically verified. Please be sure it came from a trusted
source or that you have verified the request checksum with the sender.

Request subject, to be signed as a server certificate for 1080 days:

subject=
    commonName                = Javier Perez


Type the word 'yes' to continue, or any other input to abort.
  Confirm request details: yes
Using configuration from /usr/share/easy-rsa/pki/safessl-easyrsa.cnf
Enter pass phrase for /usr/share/easy-rsa/pki/private/ca.key:
Check that the request matches the signature
Signature ok
The Subject's Distinguished Name is as follows
commonName            :ASN.1 12:'Javier Perez'
Certificate is to be certified until Feb 14 19:03:04 2024 GMT (1080 days)

Write out database with 1 new entries
Data Base Updated

Certificate created at: /usr/share/easy-rsa/pki/issued/server.crt
&lt;/pre&gt;

&lt;p&gt;Hecho esto, tan sólo nos faltaría, crear el certificado que utilizará el &lt;strong&gt;cliente externo&lt;/strong&gt; para conectarse a nuestro &lt;strong&gt;servidor VPN&lt;/strong&gt; y así conectarse a la red privada. Creamos dicho certificado y lo firmamos con nuestra CA:&lt;/p&gt;

&lt;pre&gt;
root@servidor:/usr/share/easy-rsa# ./easyrsa gen-req vpncliente

Note: using Easy-RSA configuration from: ./vars

Using SSL: openssl OpenSSL 1.1.1d  10 Sep 2019
Generating a RSA private key
.......................................................................+++++
....................................................................+++++
writing new private key to '/usr/share/easy-rsa/pki/private/vpncliente.key.wTCsIvU2Wn'
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Common Name (eg: your user, host, or server name) [vpncliente]:Cliente

Keypair and certificate request completed. Your files are:
req: /usr/share/easy-rsa/pki/reqs/vpncliente.req
key: /usr/share/easy-rsa/pki/private/vpncliente.key

root@servidor:/usr/share/easy-rsa# ./easyrsa sign-req client vpncliente

Note: using Easy-RSA configuration from: ./vars

Using SSL: openssl OpenSSL 1.1.1d  10 Sep 2019


You are about to sign the following certificate.
Please check over the details shown below for accuracy. Note that this request
has not been cryptographically verified. Please be sure it came from a trusted
source or that you have verified the request checksum with the sender.

Request subject, to be signed as a client certificate for 1080 days:

subject=
    commonName                = Cliente


Type the word 'yes' to continue, or any other input to abort.
  Confirm request details: yes
Using configuration from /usr/share/easy-rsa/pki/safessl-easyrsa.cnf
Enter pass phrase for /usr/share/easy-rsa/pki/private/ca.key:
Check that the request matches the signature
Signature ok
The Subject's Distinguished Name is as follows
commonName            :ASN.1 12:'Cliente'
Certificate is to be certified until Feb 14 19:04:45 2024 GMT (1080 days)

Write out database with 1 new entries
Data Base Updated

Certificate created at: /usr/share/easy-rsa/pki/issued/vpncliente.crt
&lt;/pre&gt;

&lt;p&gt;Bien, en este punto, habríamos terminado la parte de creación de los certificados, pero aún nos faltaría distribuir correctamente estos certificados y hacerle llegar al &lt;strong&gt;cliente externo&lt;/strong&gt;, los que él va a necesitar.&lt;/p&gt;

&lt;p&gt;Como comenté anteriormente, todos los archivos que hemos generado se almacenan dentro del directorio &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pki&lt;/code&gt;. En dicha ruta también nos encontramos con distintos subdirectorios, como los siguientes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;issued:&lt;/strong&gt; en él se almacenan los certificados firmados.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;private:&lt;/strong&gt; en él se almacenan las claves privadas.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Estos certificados, deben estar en la ruta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/openvpn&lt;/code&gt;, por lo que creo una nueva carpeta en esta ruta, y los copio.&lt;/p&gt;

&lt;pre&gt;
root@servidor:/usr/share/easy-rsa/pki# mkdir /etc/openvpn/pki

root@servidor:/usr/share/easy-rsa/pki# cp ca.crt /etc/openvpn/pki/

root@servidor:/usr/share/easy-rsa/pki# cp dh.pem /etc/openvpn/pki/

root@servidor:/usr/share/easy-rsa/pki# cp issued/server.crt /etc/openvpn/pki/

root@servidor:/usr/share/easy-rsa/pki# cp private/server.key /etc/openvpn/pki/

root@servidor:/usr/share/easy-rsa/pki# ls /etc/openvpn/pki/
ca.crt	dh.pem	server.crt  server.key
&lt;/pre&gt;

&lt;p&gt;Para que el &lt;strong&gt;cliente externo&lt;/strong&gt; pueda conectarse a la red privada, necesita poseer los ficheros &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ca.crt&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dh.pem&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpncliente.crt&lt;/code&gt; y &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpncliente.key&lt;/code&gt;. Por tanto, se los he pasado:&lt;/p&gt;

&lt;p&gt;Es el momento de comenzar con las configuraciones. En primer lugar, veremos como actúo yo de servidor y mi compañero como cliente.&lt;/p&gt;

&lt;p&gt;Para realizar la configuración del &lt;strong&gt;servidor VPN&lt;/strong&gt;, he creado el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/openvpn/server.conf&lt;/code&gt;. Su contenido es el siguiente:&lt;/p&gt;

&lt;pre&gt;
dev tun

server 10.99.99.0 255.255.255.0

push &quot;route 192.168.100.0 255.255.255.0&quot;

proto tcp

tls-server

dh /etc/openvpn/pki/dh.pem

ca /etc/openvpn/pki/ca.crt

cert /etc/openvpn/pki/server.crt

key /etc/openvpn/pki/server.key

comp-lzo

keepalive 10 60

log /var/log/openvpn/server.log

askpass pass1.txt

verb 3
&lt;/pre&gt;

&lt;p&gt;Podemos ver como hago referencia a un fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pass1.txt&lt;/code&gt;. Este fichero también debe ser creado en la ruta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/openvpn/&lt;/code&gt; y dentro de él debemos introducir la contraseña que establecimos a la hora de crear la clave con la cual firmamos el certificado del servidor con nuestra CA.&lt;/p&gt;

&lt;p&gt;Hecho esto, ya podríamos iniciar nuestro servidor:&lt;/p&gt;

&lt;pre&gt;
root@servidor:/etc/openvpn# systemctl start openvpn@server

root@servidor:/etc/openvpn# systemctl status openvpn@server
● openvpn@server.service - OpenVPN connection to server
   Loaded: loaded (/lib/systemd/system/openvpn@.service; enabled-runtime; vendor preset: enabled)
   Active: active (running) since Tue 2021-03-02 17:56:07 UTC; 4s ago
     Docs: man:openvpn(8)
           https://community.openvpn.net/openvpn/wiki/Openvpn24ManPage
           https://community.openvpn.net/openvpn/wiki/HOWTO
 Main PID: 1523 (openvpn)
   Status: &quot;Initialization Sequence Completed&quot;
    Tasks: 1 (limit: 544)
   Memory: 1.1M
   CGroup: /system.slice/system-openvpn.slice/openvpn@server.service
           └─1523 /usr/sbin/openvpn --daemon ovpn-server --status /run/openvpn/server.status 10 --cd /et

Mar 02 17:56:07 servidor systemd[1]: Starting OpenVPN connection to server...
Mar 02 17:56:07 servidor systemd[1]: Started OpenVPN connection to server.

root@servidor:/etc/openvpn# ip a show tun0
4: tun0: &amp;lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 100
    link/none
    inet 10.99.99.1 peer 10.99.99.2/32 scope global tun0
       valid_lft forever preferred_lft forever
    inet6 fe80::8905:bd21:3450:bf22/64 scope link stable-privacy
       valid_lft forever preferred_lft forever

root@servidor:/etc/openvpn# ip r
default via 192.168.0.1 dev eth1
10.0.2.0/24 dev eth0 proto kernel scope link src 10.0.2.15
10.99.99.0/24 via 10.99.99.2 dev tun0
10.99.99.2 dev tun0 proto kernel scope link src 10.99.99.1
192.168.0.0/24 dev eth1 proto kernel scope link src 192.168.0.54
192.168.100.0/24 dev eth2 proto kernel scope link src 192.168.100.10
&lt;/pre&gt;

&lt;p&gt;Podemos ver como nos ha creado una nueva interfaz llamada &lt;strong&gt;tun0&lt;/strong&gt; y una nueva ruta de encaminamiento. Si lo consultamos, podemos ver que efectivamente está escuchando en el puerto 1194:&lt;/p&gt;

&lt;pre&gt;
root@servidor:/etc/openvpn# lsof -i -P -n | grep openvpn
openvpn  1523    root    5u  IPv4  19271      0t0  TCP *:1194 (LISTEN)
&lt;/pre&gt;

&lt;p&gt;Por otro lado, vamos a realizar la configuración del &lt;strong&gt;cliente VPN&lt;/strong&gt;. Para ello, he creado el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/openvpn/client.conf&lt;/code&gt;. Su contenido es el siguiente:&lt;/p&gt;

&lt;pre&gt;
dev tun

ifconfig 10.99.99.0 255.255.255.0
pull

remote 192.168.0.54

proto tcp-client

tls-client

remote-cert-tls server

ca /etc/openvpn/pki/ca.crt

cert /etc/openvpn/pki/vpncliente.crt

key /etc/openvpn/pki/vpncliente.key

comp-lzo

keepalive 10 60

log /var/log/openvpn/cliente.log

askpass pass2.txt

verb 3
&lt;/pre&gt;

&lt;p&gt;Podemos ver como hago referencia a un fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pass2.txt&lt;/code&gt;. Este fichero también debe ser creado en la ruta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/openvpn/&lt;/code&gt; y dentro de él debemos introducir la contraseña que se estableció a la hora de crear la clave con la cual se firmó el certificado del &lt;strong&gt;cliente VPN&lt;/strong&gt; con nuestra CA.&lt;/p&gt;

&lt;p&gt;Hecho esto, iniciamos el &lt;strong&gt;cliente VPN&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;
root@clienteexterno:/etc/openvpn# systemctl start openvpn@client

root@clienteexterno:/etc/openvpn# systemctl status openvpn@client
● openvpn@client.service - OpenVPN connection to client
   Loaded: loaded (/lib/systemd/system/openvpn@.service; enabled-runtime; vendor preset: enabled)
   Active: active (running) since Tue 2021-03-02 17:57:21 UTC; 1s ago
     Docs: man:openvpn(8)
           https://community.openvpn.net/openvpn/wiki/Openvpn24ManPage
           https://community.openvpn.net/openvpn/wiki/HOWTO
 Main PID: 1375 (openvpn)
   Status: &quot;Pre-connection initialization successful&quot;
    Tasks: 1 (limit: 544)
   Memory: 1.1M
   CGroup: /system.slice/system-openvpn.slice/openvpn@client.service
           └─1375 /usr/sbin/openvpn --daemon ovpn-client --status /run/openvpn/client.status 10 --cd /et

Mar 02 17:57:21 clienteexterno systemd[1]: Starting OpenVPN connection to client...
Mar 02 17:57:21 clienteexterno systemd[1]: Started OpenVPN connection to client.

root@clienteexterno:/etc/openvpn# ip a show tun0
4: tun0: &amp;lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 100
    link/none
    inet 10.99.99.6 peer 10.99.99.5/32 scope global tun0
       valid_lft forever preferred_lft forever
    inet6 fe80::3968:e84e:5015:575d/64 scope link stable-privacy
       valid_lft forever preferred_lft forever

root@clienteexterno:/etc/openvpn# ip r
default via 192.168.0.1 dev eth1
10.0.2.0/24 dev eth0 proto kernel scope link src 10.0.2.15
10.99.99.1 via 10.99.99.5 dev tun0
10.99.99.5 dev tun0 proto kernel scope link src 10.99.99.6
192.168.0.0/24 dev eth1 proto kernel scope link src 192.168.0.56
192.168.100.0/24 via 10.99.99.5 dev tun0
&lt;/pre&gt;

&lt;p&gt;Podemos ver como me ha creado una nueva interfaz llamada &lt;strong&gt;tun0&lt;/strong&gt; y una nueva ruta de encaminamiento hacia la red &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;192.168.100.0/24&lt;/code&gt;. En este punto ya debo tener accesible las máquinas de la red privada.&lt;/p&gt;

&lt;p&gt;Al iniciar el &lt;strong&gt;servidor VPN&lt;/strong&gt; vimos que se encontraba escuchando en el puerto 1194, vamos a realizar de nuevo la misma consulta:&lt;/p&gt;

&lt;pre&gt;
root@servidor:/etc/openvpn# lsof -i -P -n | grep openvpn
openvpn  1523    root    5u  IPv4  19271      0t0  TCP *:1194 (LISTEN)
openvpn  1523    root    7u  IPv4  20654      0t0  TCP 192.168.0.54:1194-&amp;gt;192.168.0.56:54350 (ESTABLISHED)
&lt;/pre&gt;

&lt;p&gt;¡Vaya! Vemos como ahora aparecen dos resultados, ya que el &lt;strong&gt;cliente VPN&lt;/strong&gt; se ha conectado correctamente.&lt;/p&gt;

&lt;p&gt;En teoría ya habríamos terminado pero vamos a comprobarlo. Voy a realizar los siguientes &lt;em&gt;pings&lt;/em&gt; a la máquina &lt;em&gt;servidor&lt;/em&gt; y al cliente interno, respectivamente:&lt;/p&gt;

&lt;pre&gt;
root@clienteexterno:/etc/openvpn# ping 192.168.100.10
PING 192.168.100.10 (192.168.100.10) 56(84) bytes of data.
64 bytes from 192.168.100.10: icmp_seq=1 ttl=64 time=0.613 ms
64 bytes from 192.168.100.10: icmp_seq=2 ttl=64 time=1.42 ms
64 bytes from 192.168.100.10: icmp_seq=3 ttl=64 time=1.46 ms
^C
--- 192.168.100.10 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 72ms
rtt min/avg/max/mdev = 0.613/1.161/1.457/0.390 ms

root@clienteexterno:/etc/openvpn# ping 192.168.100.20
PING 192.168.100.20 (192.168.100.20) 56(84) bytes of data.
64 bytes from 192.168.100.20: icmp_seq=1 ttl=63 time=2.37 ms
64 bytes from 192.168.100.20: icmp_seq=2 ttl=63 time=1.03 ms
64 bytes from 192.168.100.20: icmp_seq=3 ttl=63 time=2.23 ms
^C
--- 192.168.100.20 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 34ms
rtt min/avg/max/mdev = 1.028/1.876/2.373/0.603 ms
&lt;/pre&gt;

&lt;p&gt;Vemos como puedo hacer &lt;em&gt;ping&lt;/em&gt; a la máquina que está actuando como &lt;strong&gt;servidor VPN&lt;/strong&gt;, y también al cliente interno que únicamente está conectado a la red privada.&lt;/p&gt;

&lt;h2 id=&quot;site-to-site&quot;&gt;Site to site&lt;/h2&gt;

&lt;p&gt;Ahora, vamos a ver como realizar una &lt;strong&gt;VPN Site to Site&lt;/strong&gt;, aunque antes vamos a ver qué es este tipo de VPN.&lt;/p&gt;

&lt;p&gt;Se basa en un concepto algo distinto, ya que ahora no vamos a conectar una máquina a una red remota, sino que vamos a conectar dos redes remotas, por lo que estaremos fusionando las dos redes.&lt;/p&gt;

&lt;h4 id=&quot;javier-servidor---álvaro-cliente&quot;&gt;Javier servidor - Álvaro cliente&lt;/h4&gt;

&lt;p&gt;En este apartado vamos a ver el proceso desde el lado del servidor. Es algo más complejo que en el lado del cliente, ya que también necesitaremos crear una &lt;strong&gt;Autoridad Certificadora (CA)&lt;/strong&gt; y firmar los certificados de nuestros clientes.&lt;/p&gt;

&lt;p&gt;Esta vez, tendremos un escenario como el siguiente.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Red de Javier &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.0.5.0/24&lt;/code&gt;:&lt;/strong&gt; poseo dos máquinas distintas conectadas a esta red privada. La primera de éstas actuará como &lt;strong&gt;servidor&lt;/strong&gt;, y es alcanzable por la máquina &lt;strong&gt;servidor&lt;/strong&gt; de Álvaro. Mi segunda máquina sólo posee una dirección IP de mi red privada, por lo que no es accesible desde la red de Álvaro.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Red de Álvaro &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.0.4.0/24&lt;/code&gt;:&lt;/strong&gt; misma situación anterior. Álvaro posee dos máquinas distintas conectadas a esta red privada. La primera de éstas actuará como &lt;strong&gt;servidor&lt;/strong&gt;, y es alcanzable por mi máquina &lt;strong&gt;servidor&lt;/strong&gt;. La segunda máquina sólo posee una dirección IP de esta red privada, por lo que no es accesible desde mi red.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En primer lugar, vamos a crear un nuevo fichero llamado &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vars&lt;/code&gt; a partir del fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vars.example&lt;/code&gt;. Ambos se encuentran en la ruta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/usr/share/easy-rsa&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;
root@vpn:~# cd /usr/share/easy-rsa/

root@vpn:/usr/share/easy-rsa# cp vars.example vars

root@vpn:/usr/share/easy-rsa# nano vars
&lt;/pre&gt;

&lt;p&gt;Debemos modificar una serie de líneas en este fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vars&lt;/code&gt;, que por defecto vienen comentadas. Su resultado final sería el siguiente:&lt;/p&gt;

&lt;pre&gt;
root@vpn:/usr/share/easy-rsa# cat vars
...
set_var EASYRSA_REQ_COUNTRY	  &quot;ES&quot;
set_var EASYRSA_REQ_PROVINCE  &quot;Sevilla&quot;
set_var EASYRSA_REQ_CITY	    &quot;Dos Hermanas&quot;
set_var EASYRSA_REQ_ORG		    &quot;JAVIERPZH ORG&quot;
set_var EASYRSA_REQ_EMAIL	    &quot;javierperezhidalgo01@gmail.com&quot;
set_var EASYRSA_REQ_OU		    &quot;Ejercicio&quot;
...
&lt;/pre&gt;

&lt;p&gt;Hecho esto, vamos a proceder con la creación de nuestra &lt;strong&gt;CA&lt;/strong&gt;, para ello, antes es necesario ejecutar algunos comandos.&lt;/p&gt;

&lt;p&gt;En primer lugar, tenemos que crear el directorio de salida (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.../pki/&lt;/code&gt;), donde se irán almacenando los distintos ficheros:&lt;/p&gt;

&lt;pre&gt;
root@vpn:/usr/share/easy-rsa# ./easyrsa init-pki

Note: using Easy-RSA configuration from: ./vars

init-pki complete; you may now create a CA or requests.
Your newly created PKI dir is: /usr/share/easy-rsa/pki
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar como nos ha creado un nuevo directorio llamado &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pki&lt;/code&gt;. En este directorio se almacenarán los certificados firmados de los clientes, del servidor, de la propia CA, …&lt;/p&gt;

&lt;p&gt;Y por último, antes de crear la propia &lt;strong&gt;CA&lt;/strong&gt;, debemos generar una clave &lt;strong&gt;Diffie-Helman&lt;/strong&gt;. Puede que tarde cierto tiempo, pero es normal, ya que &lt;strong&gt;Diffie-Hellman&lt;/strong&gt; es un algoritmo de encriptación duro.&lt;/p&gt;

&lt;pre&gt;
root@vpn:/usr/share/easy-rsa# ./easyrsa gen-dh

Note: using Easy-RSA configuration from: ./vars

Using SSL: openssl OpenSSL 1.1.1d  10 Sep 2019
Generating DH parameters, 2048 bit long safe prime, generator 2
This is going to take a long time

...

DH parameters of size 2048 created at /usr/share/easy-rsa/pki/dh.pem
&lt;/pre&gt;

&lt;p&gt;Ahora sí, vamos a crear nuestra &lt;strong&gt;Autoridad Certificadora (CA)&lt;/strong&gt;, para ello empleamos el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
root@vpn:/usr/share/easy-rsa# ./easyrsa build-ca

Note: using Easy-RSA configuration from: ./vars

Using SSL: openssl OpenSSL 1.1.1d  10 Sep 2019

Enter New CA Key Passphrase:
Re-Enter New CA Key Passphrase:
Generating RSA private key, 2048 bit long modulus (2 primes)
.............................................+++++
.........+++++
e is 65537 (0x010001)
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Common Name (eg: your user, host, or server name) [Easy-RSA CA]:Javier Pérez

CA creation complete and you may now import and sign cert requests.
Your new CA certificate file for publishing is at:
/usr/share/easy-rsa/pki/ca.crt
&lt;/pre&gt;

&lt;p&gt;Ya dispondríamos de nuestra &lt;strong&gt;Autoridad Certificadora&lt;/strong&gt;, por lo que, es el momento de crear y firmar con nuestra nueva CA, el certificado que utilizará nuestro &lt;strong&gt;servidor VPN&lt;/strong&gt;. El proceso es el siguiente:&lt;/p&gt;

&lt;pre&gt;
root@vpn:/usr/share/easy-rsa# ./easyrsa gen-req server

Note: using Easy-RSA configuration from: ./vars

Using SSL: openssl OpenSSL 1.1.1d  10 Sep 2019
Generating a RSA private key
...............................................................................+++++
....................+++++
writing new private key to '/usr/share/easy-rsa/pki/private/server.key.nx2TAMpMy5'
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Common Name (eg: your user, host, or server name) [server]:Javier Perez

Keypair and certificate request completed. Your files are:
req: /usr/share/easy-rsa/pki/reqs/server.req
key: /usr/share/easy-rsa/pki/private/server.key

root@vpn:/usr/share/easy-rsa# ./easyrsa sign-req server server

Note: using Easy-RSA configuration from: ./vars

Using SSL: openssl OpenSSL 1.1.1d  10 Sep 2019


You are about to sign the following certificate.
Please check over the details shown below for accuracy. Note that this request
has not been cryptographically verified. Please be sure it came from a trusted
source or that you have verified the request checksum with the sender.

Request subject, to be signed as a server certificate for 1080 days:

subject=
    commonName                = Javier Perez


Type the word 'yes' to continue, or any other input to abort.
  Confirm request details: yes
Using configuration from /usr/share/easy-rsa/pki/safessl-easyrsa.cnf
Enter pass phrase for /usr/share/easy-rsa/pki/private/ca.key:
Check that the request matches the signature
Signature ok
The Subject's Distinguished Name is as follows
commonName            :ASN.1 12:'Javier Perez'
Certificate is to be certified until Feb 14 15:48:45 2024 GMT (1080 days)

Write out database with 1 new entries
Data Base Updated

Certificate created at: /usr/share/easy-rsa/pki/issued/server.crt
&lt;/pre&gt;

&lt;p&gt;Hecho esto, tan sólo nos faltaría, crear los certificados que utilizarán nuestros clientes. En mi caso, voy a crear y firmar el certificado que utilizará Álvaro para conectarse a mi máquina &lt;strong&gt;servidor&lt;/strong&gt; y así conectarse a mi red privada. Creo dicho certificado y lo firmo con mi CA:&lt;/p&gt;

&lt;pre&gt;
root@vpn:/usr/share/easy-rsa# ./easyrsa gen-req vpnAlvaro

Note: using Easy-RSA configuration from: ./vars

Using SSL: openssl OpenSSL 1.1.1d  10 Sep 2019
Generating a RSA private key
........+++++
...........+++++
writing new private key to '/usr/share/easy-rsa/pki/private/vpnAlvaro.key.BbyZVkhsTn'
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Common Name (eg: your user, host, or server name) [vpnAlvaro]:Alvaro Vaca

Keypair and certificate request completed. Your files are:
req: /usr/share/easy-rsa/pki/reqs/vpnAlvaro.req
key: /usr/share/easy-rsa/pki/private/vpnAlvaro.key

root@vpn:/usr/share/easy-rsa# ./easyrsa sign-req client vpnAlvaro

Note: using Easy-RSA configuration from: ./vars

Using SSL: openssl OpenSSL 1.1.1d  10 Sep 2019


You are about to sign the following certificate.
Please check over the details shown below for accuracy. Note that this request
has not been cryptographically verified. Please be sure it came from a trusted
source or that you have verified the request checksum with the sender.

Request subject, to be signed as a client certificate for 1080 days:

subject=
    commonName                = Alvaro Vaca


Type the word 'yes' to continue, or any other input to abort.
  Confirm request details: yes
Using configuration from /usr/share/easy-rsa/pki/safessl-easyrsa.cnf
Enter pass phrase for /usr/share/easy-rsa/pki/private/ca.key:
Check that the request matches the signature
Signature ok
The Subject's Distinguished Name is as follows
commonName            :ASN.1 12:'Alvaro Vaca'
Certificate is to be certified until Feb 14 15:49:58 2024 GMT (1080 days)

Write out database with 1 new entries
Data Base Updated

Certificate created at: /usr/share/easy-rsa/pki/issued/vpnAlvaro.crt
&lt;/pre&gt;

&lt;p&gt;Bien, en este punto, habríamos terminado la parte de creación de los certificados, pero aún nos faltaría distribuir correctamente estos certificados y hacerle llegar a nuestros clientes (Álvaro), los que necesitarán.&lt;/p&gt;

&lt;p&gt;Como comenté anteriormente, todos los archivos que hemos generado se almacenan dentro del directorio &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pki&lt;/code&gt;. En dicha ruta también nos encontramos con distintos subdirectorios, como los siguientes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;issued:&lt;/strong&gt; en él se almacenan los certificados firmados.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;private:&lt;/strong&gt; en él se almacenan las claves privadas.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Estos certificados, deben estar en la ruta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/openvpn&lt;/code&gt;, por lo que creo una nueva carpeta en esta ruta, y los copio.&lt;/p&gt;

&lt;pre&gt;
root@vpn:/usr/share/easy-rsa/pki# mkdir /etc/openvpn/pki

root@vpn:/usr/share/easy-rsa/pki# cp ca.crt /etc/openvpn/pki/caJavier.crt

root@vpn:/usr/share/easy-rsa/pki# cp dh.pem /etc/openvpn/pki/dhJavier.pem

root@vpn:/usr/share/easy-rsa/pki# cp issued/server.crt /etc/openvpn/pki/serverJavier.crt

root@vpn:/usr/share/easy-rsa/pki# cp private/server.key /etc/openvpn/pki/serverJavier.key

root@vpn:/usr/share/easy-rsa/pki# ls /etc/openvpn/pki/
caJavier.crt  dhJavier.pem  serverJavier.crt  serverJavier.key
&lt;/pre&gt;

&lt;p&gt;Para que Álvaro pueda conectarse a mi red privada, necesita poseer los ficheros &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;caJavier.crt&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dhJavier.pem&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpnAlvaro.crt&lt;/code&gt; y &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpnAlvaro.key&lt;/code&gt;. Por tanto, se los paso:&lt;/p&gt;

&lt;pre&gt;
root@vpn:~# scp /etc/openvpn/pki/caJavier.crt debian@172.22.200.186:
debian@172.22.200.186's password:
caJavier.crt                                                          100% 1212   568.1KB/s   00:00    

root@vpn:~# scp /etc/openvpn/pki/dhJavier.pem debian@172.22.200.186:
debian@172.22.200.186's password:
dhJavier.pem                                                          100%  424   237.6KB/s   00:00    

root@vpn:~# scp /usr/share/easy-rsa/pki/issued/vpnAlvaro.crt debian@172.22.200.186:
debian@172.22.200.186's password:
vpnAlvaro.crt                                                         100% 4526     1.7MB/s   00:00    

root@vpn:~# scp /usr/share/easy-rsa/pki/private/vpnAlvaro.key debian@172.22.200.186:
debian@172.22.200.186's password:
vpnAlvaro.key                                                         100% 1854   938.3KB/s   00:00
&lt;/pre&gt;

&lt;p&gt;Es el momento de realizar la configuración del &lt;strong&gt;servidor VPN&lt;/strong&gt;, para ello, he creado el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/openvpn/server.conf&lt;/code&gt;. Su contenido es el siguiente:&lt;/p&gt;

&lt;pre&gt;
dev tun

ifconfig 10.99.99.1 10.99.99.2

route 10.0.4.0 255.255.255.0

tls-server

dh /etc/openvpn/pki/dhJavier.pem

ca /etc/openvpn/pki/caJavier.crt

cert /etc/openvpn/pki/serverJavier.crt

key /etc/openvpn/pki/serverJavier.key

comp-lzo

keepalive 10 60

log /var/log/openvpn/server.log

askpass pass1.txt

verb 3
&lt;/pre&gt;

&lt;p&gt;Podemos ver como hago referencia a un fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pass1.txt&lt;/code&gt;. Este fichero también debe ser creado en la ruta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/openvpn/&lt;/code&gt; y dentro de él debemos introducir la contraseña que establecimos a la hora de crear la clave con la cual firmamos el certificado del servidor con nuestra CA.&lt;/p&gt;

&lt;p&gt;Hecho esto, ya podríamos iniciar nuestro servidor y Álvaro podrá conectarse a mi red privada.&lt;/p&gt;

&lt;pre&gt;
root@vpn:/etc/openvpn# systemctl start openvpn@server

root@vpn:/etc/openvpn# systemctl status openvpn@server
● openvpn@server.service - OpenVPN connection to server
   Loaded: loaded (/lib/systemd/system/openvpn@.service; disabled; vendor preset: enabled)
   Active: active (running) since Tue 2021-03-02 11:15:03 UTC; 24min ago
     Docs: man:openvpn(8)
           https://community.openvpn.net/openvpn/wiki/Openvpn24ManPage
           https://community.openvpn.net/openvpn/wiki/HOWTO
 Main PID: 17505 (openvpn)
   Status: &quot;Pre-connection initialization successful&quot;
    Tasks: 1 (limit: 562)
   Memory: 1.2M
   CGroup: /system.slice/system-openvpn.slice/openvpn@server.service
           └─17505 /usr/sbin/openvpn --daemon ovpn-server --status /run/openvpn/server.status 10 --cd /et

Mar 02 11:15:03 vpn systemd[1]: Starting OpenVPN connection to server...
Mar 02 11:15:03 vpn systemd[1]: Started OpenVPN connection to server.

root@vpn:/etc/openvpn# ip a show tun0
4: tun0: &amp;lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 100
    link/none
    inet 10.99.99.1 peer 10.99.99.2/32 scope global tun0
       valid_lft forever preferred_lft forever
    inet6 fe80::9bb3:c109:1018:9699/64 scope link stable-privacy
       valid_lft forever preferred_lft forever

root@vpn:/etc/openvpn# ip r
default via 10.0.0.1 dev eth0
10.0.0.0/24 dev eth0 proto kernel scope link src 10.0.0.14
10.0.4.0/24 via 10.99.99.2 dev tun0
10.0.5.0/24 dev eth1 proto kernel scope link src 10.0.5.10
10.99.99.2 dev tun0 proto kernel scope link src 10.99.99.1
169.254.169.254 via 10.0.5.1 dev eth1
&lt;/pre&gt;

&lt;p&gt;Podemos ver como me ha creado una nueva interfaz llamada &lt;strong&gt;tun0&lt;/strong&gt; y una nueva ruta de encaminamiento hacia la red &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.0.4.0/24&lt;/code&gt;. Efectivamente mi compañero inició su cliente VPN, y ya tiene accesible mis máquinas, al igual que yo las suyas. Para demostrarlo he realizado los siguientes &lt;em&gt;pings&lt;/em&gt; desde mi máquina interna hacia las máquinas de Álvaro:&lt;/p&gt;

&lt;pre&gt;
root@vpn:~# ping 10.0.4.4
PING 10.0.4.4 (10.0.4.4) 56(84) bytes of data.
64 bytes from 10.0.4.4: icmp_seq=1 ttl=64 time=1.94 ms
64 bytes from 10.0.4.4: icmp_seq=2 ttl=64 time=2.36 ms
64 bytes from 10.0.4.4: icmp_seq=3 ttl=64 time=2.16 ms
^C
--- 10.0.4.4 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 5ms
rtt min/avg/max/mdev = 1.941/2.154/2.362/0.180 ms

root@vpn:~# ping 10.0.4.5
PING 10.0.4.5 (10.0.4.5) 56(84) bytes of data.
64 bytes from 10.0.4.5: icmp_seq=1 ttl=63 time=5.03 ms
64 bytes from 10.0.4.5: icmp_seq=2 ttl=63 time=3.06 ms
64 bytes from 10.0.4.5: icmp_seq=3 ttl=63 time=2.63 ms
^C
--- 10.0.4.5 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 5ms
rtt min/avg/max/mdev = 2.633/3.572/5.025/1.042 ms
&lt;/pre&gt;

&lt;p&gt;Vemos como puedo hacer &lt;em&gt;ping&lt;/em&gt; a ambas máquinas de Álvaro, por lo que tanto él como yo, tendremos accesibles ambas redes, y el proceso habría terminado.&lt;/p&gt;

&lt;h4 id=&quot;javier-cliente---álvaro-servidor&quot;&gt;Javier cliente - Álvaro servidor&lt;/h4&gt;

&lt;p&gt;Hemos visto el proceso desde el lado del servidor, pero no desde el lado del cliente, así que vamos a ver también como sería el proceso de configuración desde el cliente, para lo cuál, actuaré yo de cliente y mi compañero como servidor.&lt;/p&gt;

&lt;p&gt;Álvaro me ha hecho llegar los siguientes ficheros que ha generado con su CA y yo necesito:&lt;/p&gt;

&lt;pre&gt;
root@vpn:/etc/openvpn/pki# mv /home/debian/* ./

root@vpn:/etc/openvpn/pki# ls
caalvaro.crt  dhalvaro.pem  vpnjavier.crt  vpnjavier.key
&lt;/pre&gt;

&lt;p&gt;Perfecto, ya podríamos realizar la configuración del cliente VPN. Para ello, he creado el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/openvpn/client.conf&lt;/code&gt;. Su contenido es el siguiente:&lt;/p&gt;

&lt;pre&gt;
dev tun

remote 172.22.200.186

ifconfig 10.99.99.2 10.99.99.1

route 10.0.4.0 255.255.255.0

tls-client

ca /etc/openvpn/pki/caalvaro.crt

cert /etc/openvpn/pki/vpnjavier.crt

key /etc/openvpn/pki/vpnjavier.key

comp-lzo

keepalive 10 60

verb 3

askpass pass2.txt
&lt;/pre&gt;

&lt;p&gt;Podemos ver como hago referencia a un fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pass2.txt&lt;/code&gt;. Este fichero también debe ser creado en la ruta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/openvpn/&lt;/code&gt; y dentro de él debemos introducir la contraseña que Álvaro estableció a la hora de crear la clave con la cual firmó el certificado de mi cliente VPN con su CA.&lt;/p&gt;

&lt;p&gt;Hecho esto, mi compañero ha iniciado su servidor VPN, y en teoría, una vez inicie mi cliente, podré conectarme a la red privada de Álvaro.&lt;/p&gt;

&lt;pre&gt;
root@vpn:/etc/openvpn# systemctl start openvpn@client

root@vpn:/etc/openvpn# systemctl status openvpn@client
● openvpn@client.service - OpenVPN connection to client
   Loaded: loaded (/lib/systemd/system/openvpn@.service; disabled; vendor preset: enabled)
   Active: active (running) since Tue 2021-03-02 11:43:21 UTC; 5s ago
     Docs: man:openvpn(8)
           https://community.openvpn.net/openvpn/wiki/Openvpn24ManPage
           https://community.openvpn.net/openvpn/wiki/HOWTO
 Main PID: 18090 (openvpn)
   Status: &quot;Initialization Sequence Completed&quot;
    Tasks: 1 (limit: 562)
   Memory: 1.2M
   CGroup: /system.slice/system-openvpn.slice/openvpn@client.service
           └─18090 /usr/sbin/openvpn --daemon ovpn-client --status /run/openvpn/client.status 10 --cd /et

Mar 02 11:43:21 vpn ovpn-client[18090]: Outgoing Data Channel: Cipher 'BF-CBC' initialized with 128 bit k
Mar 02 11:43:21 vpn ovpn-client[18090]: WARNING: INSECURE cipher with block size less than 128 bit (64 bi
Mar 02 11:43:21 vpn ovpn-client[18090]: Outgoing Data Channel: Using 160 bit message hash 'SHA1' for HMAC
Mar 02 11:43:21 vpn ovpn-client[18090]: Incoming Data Channel: Cipher 'BF-CBC' initialized with 128 bit k
Mar 02 11:43:21 vpn ovpn-client[18090]: WARNING: INSECURE cipher with block size less than 128 bit (64 bi
Mar 02 11:43:21 vpn ovpn-client[18090]: Incoming Data Channel: Using 160 bit message hash 'SHA1' for HMAC
Mar 02 11:43:21 vpn ovpn-client[18090]: WARNING: cipher with small block size in use, reducing reneg-byte
Mar 02 11:43:21 vpn ovpn-client[18090]: Control Channel: TLSv1.3, cipher TLSv1.3 TLS_AES_256_GCM_SHA384,
Mar 02 11:43:21 vpn ovpn-client[18090]: [server] Peer Connection Initiated with [AF_INET]172.22.200.186:1
Mar 02 11:43:22 vpn ovpn-client[18090]: Initialization Sequence Completed

root@vpn:/etc/openvpn# ip a show tun0
4: tun0: &amp;lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 100
    link/none
    inet 10.99.99.2 peer 10.99.99.1/32 scope global tun0
       valid_lft forever preferred_lft forever
    inet6 fe80::f261:f23f:5d1a:1d79/64 scope link stable-privacy
       valid_lft forever preferred_lft forever

root@vpn:/etc/openvpn# ip r
default via 10.0.0.1 dev eth0
10.0.0.0/24 dev eth0 proto kernel scope link src 10.0.0.14
10.0.4.0/24 via 10.99.99.1 dev tun0
10.0.5.0/24 dev eth1 proto kernel scope link src 10.0.5.10
10.99.99.1 dev tun0 proto kernel scope link src 10.99.99.2
169.254.169.254 via 10.0.5.1 dev eth1
&lt;/pre&gt;

&lt;p&gt;Podemos ver como me ha creado una nueva interfaz llamada &lt;strong&gt;tun0&lt;/strong&gt; y una nueva ruta de encaminamiento hacia la red &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10.0.4.0/24&lt;/code&gt;. En este punto ya debo tener accesible las máquinas de la red de Álvaro, al igual que él debe tener accesibles las mías. Para comprobarlo voy a hacer los siguientes &lt;em&gt;pings&lt;/em&gt; desde mi máquina interna hacia el servidor VPN de Álvaro, y también hacia su máquina interna:&lt;/p&gt;

&lt;pre&gt;
root@vpn:~# ping 10.0.4.4
PING 10.0.4.4 (10.0.4.4) 56(84) bytes of data.
64 bytes from 10.0.4.4: icmp_seq=1 ttl=64 time=1.82 ms
64 bytes from 10.0.4.4: icmp_seq=2 ttl=64 time=2.07 ms
64 bytes from 10.0.4.4: icmp_seq=3 ttl=64 time=2.21 ms
^C
--- 10.0.4.4 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 5ms
rtt min/avg/max/mdev = 1.816/2.030/2.208/0.166 ms

root@vpn:~# ping 10.0.4.5
PING 10.0.4.5 (10.0.4.5) 56(84) bytes of data.
64 bytes from 10.0.4.5: icmp_seq=1 ttl=63 time=2.74 ms
64 bytes from 10.0.4.5: icmp_seq=2 ttl=63 time=2.57 ms
64 bytes from 10.0.4.5: icmp_seq=3 ttl=63 time=2.96 ms
^C
--- 10.0.4.5 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 4ms
rtt min/avg/max/mdev = 2.574/2.757/2.956/0.162 ms
&lt;/pre&gt;

&lt;p&gt;Vemos como puedo hacer &lt;em&gt;ping&lt;/em&gt; a la máquina servidor de Álvaro, y también a su máquina cliente que únicamente está conectada a su red privada. Mi compañero también tiene accesible mis dos máquinas, por lo que, el proceso habría terminado correctamente.&lt;/p&gt;

&lt;p&gt;Con esto, el contenido del &lt;em&gt;post&lt;/em&gt; habría finalizado.&lt;/p&gt;</content><author><name></name></author><summary type="html">¿Qué es una VPN?</summary></entry><entry><title type="html">Aumento De Rendimiento De Servidores Web Con Varnish</title><link href="https://www.javierpzh.com/blog/Aumento-de-rendimiento-de-servidores-web-con-Varnish" rel="alternate" type="text/html" title="Aumento De Rendimiento De Servidores Web Con Varnish" /><published>2021-02-26T00:00:00+01:00</published><updated>2021-02-26T00:00:00+01:00</updated><id>https://www.javierpzh.com/blog/Aumento-de-rendimiento-de-servidores-web-con-Varnish</id><content type="html" xml:base="https://www.javierpzh.com/blog/Aumento-de-rendimiento-de-servidores-web-con-Varnish">&lt;p&gt;En este artículo vamos a ver como podemos aumentar el rendimiento de nuestro servidor web con &lt;strong&gt;Varnish&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Para ello, antes, vamos a comparar el rendimiento de distintas configuraciones de servidores web sirviendo páginas dinámicas programadas con &lt;em&gt;PHP&lt;/em&gt;, en concreto, vamos a servir un &lt;em&gt;CMS Wordpress&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Las configuraciones que vamos a realizar son las siguientes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Módulo Apache2-PHP5&lt;/li&gt;
  &lt;li&gt;Apache2 + PHP-FPM (socket unix)&lt;/li&gt;
  &lt;li&gt;Apache2 + PHP-FPM (socket TCP)&lt;/li&gt;
  &lt;li&gt;Nginx + PHP-FPM (socket unix)&lt;/li&gt;
  &lt;li&gt;Nginx + PHP-FPM (socket TCP)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Para cada una de las configuraciones he hecho una prueba de rendimiento con el comando &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ab&lt;/code&gt;, por ejemplo, durante 10 segundos, he hecho 200 peticiones concurrentes.&lt;/p&gt;

&lt;pre&gt;
ab -t 10 -c 200 -k http://172.22.x.x/wordpress/index.php
&lt;/pre&gt;

&lt;p&gt;Después de hacer muchas pruebas de rendimiento con un número variable de peticiones concurrentes (1, 10, 25, 50, 75, 100, 250, 500, 1000) y distintas direcciones del &lt;em&gt;Wordpress&lt;/em&gt;, los resultados obtenidos son los siguientes:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_aumento_de_rendimiento_de_servidores_web_con_Varnish/grafica.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTA:&lt;/strong&gt; No es importante el número concreto de peticiones/segundo. Puede variar por muchas razones, como pueden ser:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Desde donde haga las pruebas (no es lo mismo hacerlas desde &lt;em&gt;localhost&lt;/em&gt;, o desde una máquina en la misma red, o desde internet).&lt;/li&gt;
  &lt;li&gt;El estado del servidor, que recursos tenga libre,…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lo importante es calcular una media intentando hacer las pruebas en un escenario lo más similar posible (por eso después de realizar cada prueba es recomendable reiniciar los servicios).&lt;/p&gt;

&lt;p&gt;Podemos determinar que la opción que nos ofrece más rendimiento es &lt;strong&gt;Nginx + PHP-FPM (socket unix)&lt;/strong&gt;, cuyo resultado es aproximadamente unas 600 peticiones/segundo (parámetro &lt;em&gt;Requests per second&lt;/em&gt; de &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ab&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;A partir de esa configuración vamos a intentar aumentar el rendimiento de nuestro servidor.&lt;/p&gt;

&lt;p&gt;Para ello vamos a llevar a cabo los siguientes apartados:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Vamos a configurar una máquina con la configuración ganadora: Nginx + PHP-FPM (socket unix). Para ello ejecutaremos la receta &lt;em&gt;Ansible&lt;/em&gt; que se encuentra en &lt;a href=&quot;https://github.com/josedom24/ansible_nginx_fpm_php&quot;&gt;este repositorio&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Comenzaremos clonando el repositorio en nuestro sistema:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Ansible$ git clone https://github.com/josedom24/ansible_nginx_fpm_php.git
Clonando en 'ansible_nginx_fpm_php'...
remote: Enumerating objects: 40, done.
remote: Counting objects: 100% (40/40), done.
remote: Compressing objects: 100% (27/27), done.
remote: Total 40 (delta 0), reused 36 (delta 0), pack-reused 0
Desempaquetando objetos: 100% (40/40), listo.

javier@debian:~/Ansible$ cd ansible_nginx_fpm_php/

javier@debian:~/Ansible/ansible_nginx_fpm_php$ ls
ansible.cfg  group_vars  hosts  LICENSE  README.md  roles  site.retry  site.yaml
&lt;/pre&gt;

&lt;p&gt;En mi caso, he tenido que modificar el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ansible.cfg&lt;/code&gt; ya que voy a utilizar como equipo auxiliar una máquina construida en &lt;em&gt;Vagrant&lt;/em&gt; y dichas máquinas no se crean con un usuario llamado &lt;em&gt;debian&lt;/em&gt;, sino &lt;em&gt;vagrant&lt;/em&gt;. Además de esta modificación, he editado el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hosts&lt;/code&gt; y en él he indicado la dirección IP correcta, es decir, la IP de dicha máquina &lt;em&gt;Vagrant&lt;/em&gt;. Realizados estos cambios, vamos a ejecutar la receta de &lt;em&gt;Ansible&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
javier@debian:~/Ansible/ansible_nginx_fpm_php$ ansible-playbook site.yaml

PLAY [servidores_web] **********************************************************************************

TASK [Gathering Facts] *********************************************************************************
ok: [nodo1]

TASK [nginx : install nginx, php-fpm] ******************************************************************
changed: [nodo1]

TASK [nginx : Copy info.php] ***************************************************************************
changed: [nodo1]

TASK [nginx : Copy virtualhost default] ****************************************************************
changed: [nodo1]

RUNNING HANDLER [nginx : restart nginx] ****************************************************************
changed: [nodo1]

PLAY [servidores_web] **********************************************************************************

TASK [Gathering Facts] *********************************************************************************
ok: [nodo1]

TASK [mariadb : ensure mariadb is installed] ***********************************************************
changed: [nodo1]

TASK [mariadb : ensure mariadb binds to internal interface] ********************************************
changed: [nodo1]

RUNNING HANDLER [mariadb : restart mariadb] ************************************************************
changed: [nodo1]

PLAY [servidores_web] **********************************************************************************

TASK [Gathering Facts] *********************************************************************************
ok: [nodo1]

TASK [wordpress : install unzip] ***********************************************************************
changed: [nodo1]

TASK [wordpress : download wordpress] ******************************************************************
changed: [nodo1]

TASK [wordpress : unzip wordpress] *********************************************************************
changed: [nodo1]

TASK [wordpress : create database wordpress] ***********************************************************
changed: [nodo1]

TASK [wordpress : create user mysql wordpress] *********************************************************
changed: [nodo1] =&amp;gt; (item=localhost)

TASK [wordpress : copy wp-config.php] ******************************************************************
changed: [nodo1]

RUNNING HANDLER [wordpress : restart nginx] ************************************************************
changed: [nodo1]

PLAY RECAP *********************************************************************************************
nodo1                      : ok=17   changed=14   unreachable=0    failed=0
&lt;/pre&gt;

&lt;p&gt;Terminado el proceso, automáticamente tendremos listo nuestro servidor web, en la dirección IP especificada. En mi caso es la &lt;em&gt;192.168.0.35&lt;/em&gt;, por lo que si me dirijo al navegador e introduzco dicha dirección me aparece la siguiente web:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_aumento_de_rendimiento_de_servidores_web_con_Varnish/nginx.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Podemos ver como efectivamente se encuentra ejecutándose el servidor &lt;em&gt;Nginx&lt;/em&gt;, pero, ¿se estará ejecutando el proceso adecuado para &lt;em&gt;Wordpress&lt;/em&gt;? Para comprobarlo, vamos a añadir a nuestra dirección &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/wordpress&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_aumento_de_rendimiento_de_servidores_web_con_Varnish/wordpress.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Parece ser que también disponemos de nuestro &lt;em&gt;Wordpress&lt;/em&gt;, así que vamos a terminar la instalación de esta nueva web y acceder a su panel de administración:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/sri_aumento_de_rendimiento_de_servidores_web_con_Varnish/panelwordpress.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Vamos a hacer las pruebas de rendimiento desde la misma máquina. Para ello, vamos a ejecutar instrucciones similares a esta:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;
ab -t 10 -c 50 -k http://127.0.0.1/wordpress/index.php
&lt;/pre&gt;

&lt;p&gt;Hay que decir, que el comando &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ab&lt;/code&gt; se encuentra en el paquete &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apache2-utils&lt;/code&gt;, por lo que debemos instalarlo:&lt;/p&gt;

&lt;pre&gt;
apt install apache2-utils -y
&lt;/pre&gt;

&lt;p&gt;Procedo a realizar las pruebas de rendimiento con valores distintos para comprobar el nivel de concurrencia, para ello, nos centraremos en los resultados de &lt;strong&gt;peticiones/segundo&lt;/strong&gt;. Hay que decir, que entre cada prueba, he reiniciado tanto el servidor &lt;em&gt;Nginx&lt;/em&gt; y el como el servidor &lt;em&gt;PHP-FPM&lt;/em&gt;, para que los resultados sean los más reales posibles.&lt;/p&gt;

&lt;p&gt;Veamos los resultados:&lt;/p&gt;

&lt;pre&gt;
root@varnish:~# ab -t 10 -c 50 -k http://127.0.0.1/wordpress/index.php
...
Requests per second:    163.73 [#/sec] (mean)

root@varnish:~# ab -t 10 -c 100 -k http://127.0.0.1/wordpress/index.php
...
Requests per second:    169.80 [#/sec] (mean)

root@varnish:~# ab -t 10 -c 250 -k http://127.0.0.1/wordpress/index.php
...
Requests per second:    13030.18 [#/sec] (mean)

root@varnish:~# ab -t 10 -c 500 -k http://127.0.0.1/wordpress/index.php
...
Requests per second:    16449.18 [#/sec] (mean)
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3. Vistos los resultados, vamos a configurar un &lt;em&gt;proxy inverso - caché Varnish&lt;/em&gt; escuchando en el puerto 80, que se comunicará con el servidor web por el puerto 8080. Posteriormente, volveremos a realizar varias pruebas de rendimiento.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Instalamos el &lt;em&gt;software&lt;/em&gt; de &lt;em&gt;Varnish&lt;/em&gt; mediante el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
apt install varnish -y
&lt;/pre&gt;

&lt;p&gt;Una vez instalado, debemos tener en cuenta que, por defecto, &lt;em&gt;Varnish&lt;/em&gt; escucha las peticiones en el puerto 6081, y en el 6082 para la interfaz de administración. En nuestro caso, queremos modificar este comportamiento de manera que &lt;em&gt;Varnish&lt;/em&gt; escuche las peticiones en el puerto 80.&lt;/p&gt;

&lt;p&gt;Para cambiar esto, en primer lugar, nos dirigiremos a nuestro &lt;em&gt;virtualhost&lt;/em&gt; del servidor &lt;em&gt;Nginx&lt;/em&gt;, y en él, cambiaremos el puerto predeterminado (80) por el 8080. El resultado final de este &lt;em&gt;virtualhost&lt;/em&gt; sería el siguiente:&lt;/p&gt;

&lt;pre&gt;
server {
        listen 8080 default_server;
        listen [::]:8080 default_server;
...
&lt;/pre&gt;

&lt;p&gt;Obviamente, tras editar esto, debemos reiniciar nuestro servidor web para aplicar los nuevos cambios:&lt;/p&gt;

&lt;pre&gt;
systemctl restart nginx.service
&lt;/pre&gt;

&lt;p&gt;Hecho esto, aún nos quedaría la parte en que modificamos la configuración de &lt;em&gt;Varnish&lt;/em&gt; para que escuche las peticiones en el puerto 80 y las redirija al 8080 que es donde tenemos nuestro servidor web.&lt;/p&gt;

&lt;p&gt;En primer lugar, empezaremos por redirigir el tráfico al puerto 8080. Para hacer esto, nos dirigimos al fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/varnish/default.vcl&lt;/code&gt; y debemos asegurarnos de que el bloque &lt;strong&gt;backend_default&lt;/strong&gt; se encuentra con este aspecto:&lt;/p&gt;

&lt;pre&gt;
backend default {
    .host = &quot;127.0.0.1&quot;;
    .port = &quot;8080&quot;;
}
&lt;/pre&gt;

&lt;p&gt;Bien, &lt;em&gt;Varnish&lt;/em&gt; ya nos redirigirá el tráfico al puerto deseado, pero aún no está escuchando en el puerto 80, por lo que vamos a hacer que escuche en él. En el fichero &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/default/varnish&lt;/code&gt;, tenemos que modificar el bloque &lt;strong&gt;DAEMON_OPTS&lt;/strong&gt; y dejarlo como el siguiente:&lt;/p&gt;

&lt;pre&gt;
DAEMON_OPTS=&quot;-a :80 \
             -T localhost:6082 \
             -f /etc/varnish/default.vcl \
             -S /etc/varnish/secret \
             -s malloc,256m&quot;
&lt;/pre&gt;

&lt;p&gt;En este punto, tan solo nos faltaría indicar en el demonio &lt;em&gt;systemd&lt;/em&gt; que debe escuchar en el puerto 80. Este fichero se encuentra en la ruta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/lib/systemd/system/varnish.service&lt;/code&gt;, y en él debemos modificar la siguiente línea hasta que posea este aspecto:&lt;/p&gt;

&lt;pre&gt;
...
ExecStart=/usr/sbin/varnishd -j unix,user=vcache -F -a :80 -T localhost:6082 -f /etc/varnish/default.vc$
...
&lt;/pre&gt;

&lt;p&gt;Ya hemos terminado todas las modificaciones necesarias, por lo que tan sólo nos faltaría reiniciar los servicios:&lt;/p&gt;

&lt;pre&gt;
systemctl restart varnish
systemctl daemon-reload
&lt;/pre&gt;

&lt;p&gt;Por fin podemos realizar de nuevo las pruebas de funcionamiento y comparar los resultados con los anteriores. De nuevo, los servidores han sido reiniciados entre cada una de las pruebas:&lt;/p&gt;

&lt;pre&gt;
root@varnish:~# ab -t 10 -c 50 -k http://127.0.0.1/wordpress/index.php
...
Requests per second:    38760.20 [#/sec] (mean)
...

root@varnish:~# ab -t 10 -c 100 -k http://127.0.0.1/wordpress/index.php
...
Requests per second:    43572.91 [#/sec] (mean)
...

root@varnish:~# ab -t 10 -c 250 -k http://127.0.0.1/wordpress/index.php
...
Requests per second:    42457.51 [#/sec] (mean)
...

root@varnish:~# ab -t 10 -c 500 -k http://127.0.0.1/wordpress/index.php
...
Requests per second:    34078.54 [#/sec] (mean)
...
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar que los resultados son muy significativos y que la mejora de rendimiento es bastante abultada. Esto es debido a que nuestro &lt;em&gt;proxy inverso - caché&lt;/em&gt;, a la hora de redirigir el trafico, lo hace tan sólo una vez, ya que para las próximas, ya lo tiene en &lt;em&gt;caché&lt;/em&gt;, lo que hace que la respuesta sea mucho más rápida.&lt;/p&gt;

&lt;p&gt;Para demostrar que el &lt;em&gt;proxy Varnish&lt;/em&gt; tan sólo ha realizado una petición a nuestro servidor web, vamos a consultar los &lt;em&gt;logs&lt;/em&gt; de acceso de &lt;em&gt;Nginx&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
root@varnish:~# tail -f /var/log/nginx/access.log
127.0.0.1 - - [26/Feb/2021:19:22:36 +0000] &quot;GET /wordpress/index.php HTTP/1.1&quot; 301 5 &quot;-&quot; &quot;ApacheBench/2.3&quot;
&lt;/pre&gt;

&lt;p&gt;Como podemos apreciar tenemos una sola petición, lo que significa que habríamos terminado este pequeño ejercicio en el que se demuestra el aumento de rendimiento con &lt;em&gt;Varnish&lt;/em&gt;, por lo que este &lt;em&gt;post&lt;/em&gt; finalizaría aquí.&lt;/p&gt;</content><author><name></name></author><summary type="html">En este artículo vamos a ver como podemos aumentar el rendimiento de nuestro servidor web con Varnish.</summary></entry><entry><title type="html">Almacenamiento De Bases De Datos</title><link href="https://www.javierpzh.com/blog/almacenamiento-de-bases-de-datos" rel="alternate" type="text/html" title="Almacenamiento De Bases De Datos" /><published>2021-02-25T00:00:00+01:00</published><updated>2021-02-25T00:00:00+01:00</updated><id>https://www.javierpzh.com/blog/almacenamiento-de-bases-de-datos</id><content type="html" xml:base="https://www.javierpzh.com/blog/almacenamiento-de-bases-de-datos">&lt;h2 id=&quot;oracle&quot;&gt;Oracle&lt;/h2&gt;

&lt;h4 id=&quot;vamos-a-establecer-que-los-objetos-que-se-creen-en-el-ts1-tengan-un-tamaño-inicial-de-200k-y-que-cada-extensión-sea-del-doble-del-tamaño-que-la-anterior-el-número-máximo-de-extensiones-será-de-3&quot;&gt;Vamos a establecer que los objetos que se creen en el ‘TS1’ tengan un tamaño inicial de 200K, y que cada extensión sea del doble del tamaño que la anterior. El número máximo de extensiones será de 3.&lt;/h4&gt;

&lt;p&gt;Para ello, antes de nada, necesitaremos crear el propio &lt;em&gt;tablespace&lt;/em&gt;. En mi caso, lo crearé con un fichero, de 2 MB, y autoextensible:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; create tablespace TS1
  2  datafile 'ts1.dbf'
  3  size 2M
  4  autoextend on;

Tablespace creado.
&lt;/pre&gt;

&lt;p&gt;Una vez creado, vamos a establecer dicho &lt;em&gt;tablespace&lt;/em&gt; &lt;em&gt;offline&lt;/em&gt; para poder operar con él:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; alter tablespace TS1 offline;

Tablespace modificado.
&lt;/pre&gt;

&lt;p&gt;Modificamos el &lt;em&gt;tablespace TS1&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; ALTER TABLESPACE TS1
  2  DEFAULT STORAGE (
  3  INITIAL 200K
  4  NEXT 400K
  5  PCTINCREASE 100
  6  MINEXTENTS 1
  7  MAXEXTENTS 3);
ALTER TABLESPACE TS1
*
ERROR en lÝnea 1:
ORA-25143: la clßusula de almacenamiento por defecto no es compatible con la
polÝtica de asignaci¾n
&lt;/pre&gt;

&lt;p&gt;A la hora de realizar la sentencia &lt;em&gt;ALTER TABLE&lt;/em&gt; nos reporta un error debido a que el &lt;em&gt;tablespace&lt;/em&gt;, por defecto, está hecho en local, y no por diccionario, por lo que no podemos modificar las cláusulas de almacenamiento.&lt;/p&gt;

&lt;p&gt;Podemos observar que el &lt;em&gt;tablespace system&lt;/em&gt; está guardado en local.&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; SELECT tablespace_name, extent_management FROM dba_tablespaces where tablespace_name='SYSTEM';

TABLESPACE_NAME                EXTENT_MAN
------------------------------ ----------
SYSTEM                         LOCAL
&lt;/pre&gt;

&lt;p&gt;Bien, y ¿podríamos hacer que la gestión de extensiones fuera por diccionario?&lt;/p&gt;

&lt;p&gt;Pues desgraciadamente no. La gestión de extensiones se elige en la instalación de &lt;em&gt;Oracle&lt;/em&gt; y luego no puede modificarse. La gestión local proporciona un mejor rendimiento, pero ignora la cláusula &lt;em&gt;STORAGE&lt;/em&gt; de los objetos del &lt;em&gt;tablespace&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;vamos-a-crear-dos-tablas-en-el-tablespace-recién-creado-e-insertaremos-un-registro-en-cada-una-de-ellas-comprobaremos-el-espacio-libre-existente-en-el-tablespace-borraremos-una-de-las-tablas-y-comprobaremos-si-ha-aumentado-el-espacio-disponible-en-el-tablespace&quot;&gt;Vamos a crear dos tablas en el tablespace recién creado e insertaremos un registro en cada una de ellas. Comprobaremos el espacio libre existente en el tablespace. Borraremos una de las tablas y comprobaremos si ha aumentado el espacio disponible en el tablespace.&lt;/h4&gt;

&lt;p&gt;Primero vamos a establecer el &lt;em&gt;tablespace&lt;/em&gt; &lt;em&gt;online&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; alter tablespace TS1 online;

Tablespace modificado.
&lt;/pre&gt;

&lt;p&gt;Antes de nada, vamos a observar el espacio libre que posee ahora mismo dicho &lt;em&gt;tablespace&lt;/em&gt;, que actualmente se encuentra vacío:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; select tablespace_name, bytes from dba_free_space where tablespace_name='TS1';

TABLESPACE_NAME                     BYTES
------------------------------ ----------
TS1                               1048576
&lt;/pre&gt;

&lt;p&gt;Bien, ahora vamos a proceder a crear las dos tablas en el &lt;em&gt;tablespace&lt;/em&gt; &lt;strong&gt;TS1&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; create table Tabla1
  2  (
  3    Campo1 VARCHAR2(20)
  4  )
  5  tablespace TS1;

Tabla creada.

SQL&amp;gt; create table Tabla2
  2  (
  3  Campo2 VARCHAR2(20)
  4  )
  5  tablespace TS1;

Tabla creada.
&lt;/pre&gt;

&lt;p&gt;Una vez que las tablas han sido creadas, vamos a insertar un registro en cada una de ellas:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; insert into Tabla1 values('Registro1');

1 fila creada.

SQL&amp;gt; insert into Tabla2 values('Registro2');

1 fila creada.
&lt;/pre&gt;

&lt;p&gt;Una vez que los registros han sido insertados, vamos a observar de nuevo el tamaño disponible del &lt;em&gt;tablespace&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; select tablespace_name, bytes from dba_free_space where tablespace_name='TS1';

TABLESPACE_NAME                     BYTES
------------------------------ ----------
TS1                                917504
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar como lógicamente el espacio libre ha disminuido.&lt;/p&gt;

&lt;p&gt;Por último, vamos a probar a borrar una tabla de las almacenadas en dicho &lt;em&gt;tablespace&lt;/em&gt; y a observar si se libera espacio.&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; drop table Tabla2;

Tabla borrada.
&lt;/pre&gt;

&lt;p&gt;Ya hemos borrado una de las tablas, de forma que únicamente estaríamos almacenando en el &lt;em&gt;tablespace TS1&lt;/em&gt;, una tabla. Vamos a repetir la consulta anterior para ver cuanto espacio disponible tenemos:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; select tablespace_name, bytes from dba_free_space where tablespace_name='TS1';

TABLESPACE_NAME                     BYTES
------------------------------ ----------
TS1                                917504
TS1                                 65536
&lt;/pre&gt;

&lt;p&gt;Como podemos observar, nos aparece una nueva línea que indica 65536 bytes.&lt;/p&gt;

&lt;p&gt;Esto se debe a que en &lt;em&gt;Oracle&lt;/em&gt;, los &lt;em&gt;tablespaces&lt;/em&gt; se dividen en segmentos, y cada segmento es un objeto del &lt;em&gt;tablespace&lt;/em&gt;, por lo que esos &lt;em&gt;bytes&lt;/em&gt; son los que se han liberado tras eliminar la tabla &lt;em&gt;Tabla2&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;vamos-a-convertir-ts1-en-un-tablespace-de-sólo-lectura-intentaremos-insertar-registros-en-la-tabla-existente-qué-ocurre-intentaremos-borrar-la-tabla-qué-ocurre-por-qué-pasa-eso&quot;&gt;Vamos a convertir ‘TS1’ en un tablespace de sólo lectura. Intentaremos insertar registros en la tabla existente. ¿Qué ocurre? Intentaremos borrar la tabla. ¿Qué ocurre? ¿Por qué pasa eso?&lt;/h4&gt;

&lt;p&gt;Vamos a convertir el &lt;em&gt;tablespace TS1&lt;/em&gt; en un &lt;em&gt;tablespace&lt;/em&gt; de sólo lectura. Para ello ejecutamos el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; alter tablespace TS1 read only;

Tablespace modificado.
&lt;/pre&gt;

&lt;p&gt;Hecho esto, vamos a probar a insertar un registro en la &lt;em&gt;Tabla1&lt;/em&gt; almacenada en dicho &lt;em&gt;tablespace&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; insert into Tabla1 values('Registro2');
insert into Tabla1 values('Registro2')
            *
ERROR en lÝnea 1:
ORA-00372: el archivo 13 no se puede modificar en este momento
ORA-01110: archivo de datos 13:
'C:\USERS\SERVIDOR\DESKTOP\WINDOWS.X64_193000_DB_HOME\DATABASE\TS1.DBF'
&lt;/pre&gt;

&lt;p&gt;Obviamente, al establecer el &lt;em&gt;tablespace TS1&lt;/em&gt; como sólo lectura, no podemos hacer una inserción de datos en él, ya que esto supondría una escritura sobre lo que ya se encuentra almacenado en dicho &lt;em&gt;tablespace&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Para seguir comprobando este razonamiento, vamos a intentar borrar la tabla que se encuentra almacenada en él:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; drop table Tabla1;

Tabla borrada.
&lt;/pre&gt;

&lt;p&gt;¡Vaya! El razonamiento anterior parece que no es del todo cierto, pues la tabla sí ha sido borrada.&lt;/p&gt;

&lt;p&gt;¿Pero por qué pasa esto?&lt;/p&gt;

&lt;p&gt;Bien, esto se debe a que la orden ejecutada, envía la información al diccionario de datos, donde dicho &lt;em&gt;tablespace&lt;/em&gt; que lo gestiona, sí tiene permisos de escritura, por lo cual sí permite el borrado de la tabla.&lt;/p&gt;

&lt;h4 id=&quot;vamos-a-crear-un-espacio-de-tablas-ts2-con-dos-ficheros-en-rutas-diferentes-de-1m-cada-uno-y-no-autoextensibles-crearemos-en-el-tablespace-citado-una-tabla-con-una-cláusula-de-almacenamiento-insertaremos-registros-hasta-que-se-llene-el-tablespace-qué-ocurrirá&quot;&gt;Vamos a crear un espacio de tablas ‘TS2’ con dos ficheros en rutas diferentes de 1M cada uno y no autoextensibles. Crearemos en el tablespace citado una tabla con una cláusula de almacenamiento. Insertaremos registros hasta que se llene el tablespace. ¿Qué ocurrirá?&lt;/h4&gt;

&lt;p&gt;Vamos a crear el &lt;em&gt;tablespace&lt;/em&gt; con los dos ficheros y no autoextensibles:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; create tablespace TS2
  2  datafile 'ts2.dbf'
  3  size 1M,
  4  'ts2(2).dbf'
  5  size 1M
  6  autoextend off;

Tablespace creado.
&lt;/pre&gt;

&lt;p&gt;Una vez creado, vamos a crear una tabla en él con una cláusula de almacenamiento, en mi caso he elegido una &lt;em&gt;Initial&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; create table Tabla3
  2  (
  3  Campo1 VARCHAR2(100),
  4  Campo2 VARCHAR2(100),
  5  Campo3 VARCHAR2(100),
  6  Campo4 VARCHAR2(100)
  7  )
  8  storage
  9  (
 10  Initial 20K
 11  )
 12  tablespace TS2;

Tabla creada.
&lt;/pre&gt;

&lt;p&gt;En este punto, voy a insertar registros hasta que el espacio del &lt;em&gt;tablespace&lt;/em&gt; se agote.&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; insert into Tabla3 (Campo1,Campo2,Campo3,Campo4) values('Registro de prueba 1','Registro de prueba 2','Registro de prueba 3','Registro de prueba 4');

1 fila creada.

SQL&amp;gt; insert into Tabla3 (Campo1,Campo2,Campo3,Campo4) values('Registro de prueba 1','Registro de prueba 2','Registro de prueba 3','Registro de prueba 4');
insert into Tabla3 (Campo1,Campo2,Campo3,Campo4) values('Registro de prueba 1','Registro de prueba 2','Registro de prueba 3','Registro de prueba 4')
*
ERROR en lÝnea 1:
ORA-01653: no se ha podido ampliar la tabla SYSTEM.TABLA3 con 128 en el tablespace TS2
&lt;/pre&gt;

&lt;p&gt;Tras insertar una serie de registros, podemos ver como me ha devuelto un error. Este error se debe a que el espacio del &lt;em&gt;tablespace&lt;/em&gt; se ha agotado, y como al crear &lt;em&gt;TS2&lt;/em&gt; especificamos que no fuera autoextensible, no nos permitirá insertar más datos en dicho &lt;em&gt;tablespace&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;vamos-a-realizar-una-consulta-al-diccionario-de-datos-que-muestre-qué-índices-existen-para-objetos-pertenecientes-al-esquema-de-scott-y-sobre-qué-columnas-están-definidos-en-qué-fichero-o-ficheros-de-datos-se-encuentran-las-extensiones-de-sus-segmentos-correspondientes&quot;&gt;Vamos a realizar una consulta al diccionario de datos que muestre qué índices existen para objetos pertenecientes al esquema de SCOTT y sobre qué columnas están definidos. ¿En qué fichero o ficheros de datos se encuentran las extensiones de sus segmentos correspondientes?&lt;/h4&gt;

&lt;p&gt;Realizamos la siguiente consulta:&lt;/p&gt;

&lt;pre&gt;
SQL&amp;gt; SELECT columns.TABLE_NAME, columns.INDEX_NAME, columns.COLUMN_NAME, files.FILE_NAME
  2  FROM DBA_IND_COLUMNS columns, DBA_EXTENTS extents, DBA_DATA_FILES files
  3  WHERE columns.TABLE_NAME = extents.SEGMENT_NAME
  4  AND extents.FILE_ID = files.FILE_ID
  5  AND columns.TABLE_OWNER='SCOTT';

TABLE_NAME                     INDEX_NAME
------------------------------ ------------------------------
COLUMN_NAME
--------------------------------------------------------------------------------
FILE_NAME
--------------------------------------------------------------------------------
DEPT                           PK_DEPT
DEPTNO
C:\APP\JAVIER\ORADATA\ORCL\USERS01.DBF

EMP                            PK_EMP
EMPNO
C:\APP\JAVIER\ORADATA\ORCL\USERS01.DBF

TABLE_NAME                     INDEX_NAME
------------------------------ ------------------------------
COLUMN_NAME
--------------------------------------------------------------------------------
FILE_NAME
--------------------------------------------------------------------------------

TABLA_ARTICULOS                SYS_C0011484
CODIGO
C:\APP\JAVIER\ORADATA\ORCL\USERS01.DBF

&lt;/pre&gt;

&lt;p&gt;Podemos ver los resultados.&lt;/p&gt;

&lt;h2 id=&quot;postgresql&quot;&gt;PostgreSQL&lt;/h2&gt;

&lt;h4 id=&quot;existen-los-conceptos-de-segmento-y-de-extensión-en-postgresql-en-qué-consisten&quot;&gt;¿Existen los conceptos de segmento y de extensión en PostgreSQL, en qué consisten?&lt;/h4&gt;
&lt;h4 id=&quot;cuáles-son-las-diferencias-con-los-conceptos-correspondientes-de-oracle&quot;&gt;¿Cuáles son las diferencias con los conceptos correspondientes de Oracle?&lt;/h4&gt;

&lt;p&gt;En &lt;strong&gt;Oracle&lt;/strong&gt;, la organización del almacenamiento dentro de un &lt;em&gt;tablespace&lt;/em&gt;, se organiza en &lt;strong&gt;segmentos&lt;/strong&gt;, que a su vez, contienen una o varias &lt;strong&gt;extensiones&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Un &lt;em&gt;segmento&lt;/em&gt; es un grupo de &lt;em&gt;extensiones&lt;/em&gt; que forman un objeto de la base de datos, como por ejemplo una tabla o un índice.&lt;/p&gt;

&lt;p&gt;Cuando se crea un &lt;em&gt;segmento&lt;/em&gt; en un &lt;em&gt;tablespace&lt;/em&gt;, &lt;em&gt;Oracle&lt;/em&gt; asigna una o varias &lt;em&gt;extensiones&lt;/em&gt; en alguno de los archivos de datos del &lt;em&gt;tablespace&lt;/em&gt;. Cuando el espacio inicialmente asignado se agota, &lt;em&gt;Oracle&lt;/em&gt; asigna una nueva &lt;em&gt;extensión&lt;/em&gt; al &lt;em&gt;segmento&lt;/em&gt;, y así sucesivamente.&lt;/p&gt;

&lt;p&gt;Las &lt;em&gt;extensiones&lt;/em&gt; asignadas a un &lt;em&gt;segmento&lt;/em&gt; están en el &lt;em&gt;tablespace&lt;/em&gt; de creación del &lt;em&gt;segmento&lt;/em&gt;, aunque no tienen porque estar juntas, ni en el mismo archivo de datos (si el &lt;em&gt;tablespace&lt;/em&gt; tuviera varios archivos de datos).&lt;/p&gt;

&lt;p&gt;Cuando se elimina un &lt;em&gt;segmento&lt;/em&gt;, las &lt;em&gt;extensiones&lt;/em&gt; que ocupa se liberan y vuelven a quedar disponibles.&lt;/p&gt;

&lt;p&gt;Este gráfico resume lo explicado:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/javierpzh/webjavierpzh/master/assets/img/images/abd_almacenamiento_de_bases_de_datos/grafico.ej.postgresql.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Entendido lo que son los &lt;em&gt;segmentos&lt;/em&gt; y las &lt;em&gt;extensiones&lt;/em&gt; en &lt;em&gt;Oracle&lt;/em&gt;, vamos a ver su comportamiento en &lt;strong&gt;PostgreSQL&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;En &lt;em&gt;PostgreSQL&lt;/em&gt; estos conceptos no existen como en &lt;em&gt;Oracle&lt;/em&gt;, sino que se comportan de la siguiente manera.&lt;/p&gt;

&lt;p&gt;Cada &lt;em&gt;tablespace&lt;/em&gt; creado se asigna a un subdirectorio del directorio que hayamos definido como directorio de datos (&lt;em&gt;data_directory&lt;/em&gt;) en la instalación de &lt;em&gt;PostgreSQL&lt;/em&gt;. (Para consultar cuál es nuestro directorio de datos podemos emplear el siguiente comando: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SHOW data_directory;&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;En dicho directorio del &lt;em&gt;tablespace&lt;/em&gt; se crearán archivos distintos para cada uno de los &lt;em&gt;segmentos&lt;/em&gt;. Es decir, cuando se crea un &lt;em&gt;segmento&lt;/em&gt;, se crea un archivo de datos dentro del directorio asignado al &lt;em&gt;tablespace&lt;/em&gt;. A este archivo no se le puede indicar el tamaño ni el nombre, y no es compartido por otras tablas.&lt;/p&gt;

&lt;p&gt;Respecto a las &lt;em&gt;extensiones&lt;/em&gt;, no existe tal concepto en &lt;em&gt;PostgreSQL&lt;/em&gt; como lo conocemos en &lt;em&gt;Oracle&lt;/em&gt;. Pero sí existe este concepto como librerías o módulos que agregan funcionalidades específicas (se deben instalar con &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create extension&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;La única referencia al sistema de almacenamiento, es que la unidad mínima de almacenamiento se denomina &lt;em&gt;página&lt;/em&gt; o &lt;em&gt;bloque&lt;/em&gt;. Un &lt;em&gt;bloque&lt;/em&gt; en &lt;em&gt;PostgreSQL&lt;/em&gt; ocupa por defecto 8 &lt;em&gt;kilobytes&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;mysql&quot;&gt;MySQL&lt;/h2&gt;

&lt;h4 id=&quot;existe-el-concepto-de-espacio-de-tablas-en-mysql&quot;&gt;¿Existe el concepto de espacio de tablas en MySQL?&lt;/h4&gt;
&lt;h4 id=&quot;qué-diferencias-presentan-con-los-tablespaces-de-oracle&quot;&gt;¿Qué diferencias presentan con los tablespaces de Oracle?&lt;/h4&gt;

&lt;p&gt;La principal diferencia que presenta &lt;em&gt;MySQL&lt;/em&gt; en comparación con &lt;em&gt;Oracle&lt;/em&gt;, es que éste, sólo posee un tipo de motor de almacenamiento, y está pensado para una sola base de datos, al contrario que &lt;em&gt;MySQL&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;En &lt;em&gt;MySQL&lt;/em&gt; también disponemos de &lt;em&gt;tablespaces&lt;/em&gt;, aunque su comportamiento puede variar según el motor de base de datos que escojamos.&lt;/p&gt;

&lt;p&gt;Los espacios de tabla (&lt;em&gt;tablespaces&lt;/em&gt;) son unidades de almacenamiento lógicas de motores de base de datos relacionales como &lt;strong&gt;InnoDB&lt;/strong&gt;, que contienen todos los datos del sistema de base de datos. Cada uno de los espacios de tabla contiene como mínimo, un fichero de datos físico del sistema operativo, en el que se almacenan tanto tablas de bases de datos, como índices.&lt;/p&gt;

&lt;p&gt;Dentro de los motores de base de datos, me centraré en el más conocido, que es el llamado &lt;strong&gt;InnoDB&lt;/strong&gt;. Este motor nos permite controlar la lógica del almacenamiento físico y acceso a los datos. Sus principales ventajas son las siguientes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Soporte de transacciones&lt;/li&gt;
  &lt;li&gt;Bloqueo de registros&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Rollback&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Nos permite tener las características &lt;em&gt;ACID&lt;/em&gt;, garantizando la integridad de nuestras tablas&lt;/li&gt;
  &lt;li&gt;Requiere bastante espacio de disco y bastante RAM&lt;/li&gt;
  &lt;li&gt;Aumento de rendimiento a la hora de un uso elevado de sentencias &lt;em&gt;INSERT&lt;/em&gt; y &lt;em&gt;UPDATE&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La sintaxis para crear un &lt;em&gt;tablespace&lt;/em&gt; con &lt;em&gt;InnoDB&lt;/em&gt; es la siguiente:&lt;/p&gt;

&lt;pre&gt;
create tablespace {Nombre tablespace}
	add datafile '{Nombre de archivo}'
	use logfile group logfile_group
	[extent_size [=] extent_size]
	[initial_size [=] initial_size]
	[autoextend_size [=] autoextend_size]
	[max_size [=] max_size]
	[nodegroup [=] nodegroup_id]
	[wait]
	[comment [=] comment_text]
	[engine [=] engine_name]
&lt;/pre&gt;

&lt;p&gt;Aunque me haya centrado principalmente en &lt;em&gt;InnoDB&lt;/em&gt;, en &lt;em&gt;MySQL&lt;/em&gt;, disponemos de muchos otros motores de almacenamiento, como por ejemplo &lt;strong&gt;MyISAM&lt;/strong&gt;. Este motor de base de datos se utiliza para tablas que no requieran muchos espacio en disco ni mucha RAM. Sus principales ventajas son las siguientes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Gran velocidad a la hora de recuperar datos&lt;/li&gt;
  &lt;li&gt;Recomendable para aplicaciones en las que dominan las sentencias &lt;em&gt;SELECT&lt;/em&gt; ante los &lt;em&gt;INSERT/UPDATE&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Al no tener que hacer comprobaciones de la integridad referencial, ni bloquear las tablas para realizar las operaciones, nos proporciona una mayor velocidad&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mongodb&quot;&gt;MongoDB&lt;/h2&gt;

&lt;h4 id=&quot;existe-la-posibilidad-en-mongodb-de-decidir-en-qué-archivo-se-almacena-una-colección&quot;&gt;¿Existe la posibilidad en MongoDB de decidir en qué archivo se almacena una colección?&lt;/h4&gt;

&lt;p&gt;En primer lugar, vamos a ver donde guarda &lt;em&gt;MongoDB&lt;/em&gt; los archivos de la base de datos. Por defecto, se guardan en la ruta que viene establecida en su archivo de configuración llamado &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mongod.conf&lt;/code&gt;. En mi caso, al tener instalado &lt;em&gt;MongoDB&lt;/em&gt; sobre un sistema &lt;em&gt;Debian&lt;/em&gt;, dicho archivo se encuentra en la ruta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/mongod.conf&lt;/code&gt;. Si nos dirigimos a él, al principio nos encontraremos un bloque como el siguiente:&lt;/p&gt;

&lt;pre&gt;
# Where and how to store data.
storage:
  dbPath: /var/lib/mongodb
...
&lt;/pre&gt;

&lt;p&gt;Podemos apreciar como nos indica donde se están guardando los datos de nuestra base de datos, en mi caso, la ruta por defecto es &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/lib/mongodb&lt;/code&gt;. A continuación voy a mostrar una salida del contenido de dicha ruta para comprobar que mis documentos se estén almacenando en tal lugar:&lt;/p&gt;

&lt;pre&gt;
root@servidor:~# ls /var/lib/mongodb
collection-0-3377914449258320463.wt   index-1-3763332829671594932.wt   journal
collection-0-3763332829671594932.wt   index-1--575804202552084677.wt   _mdb_catalog.wt
collection-0--575804202552084677.wt   index-1--6595949044337281648.wt  mongod.lock
collection-0--6595949044337281648.wt  index-2--6595949044337281648.wt  sizeStorer.wt
collection-2-3763332829671594932.wt   index-3-3763332829671594932.wt   storage.bson
collection-4-3377914449258320463.wt   index-5-3377914449258320463.wt   WiredTiger
collection-4-3763332829671594932.wt   index-5-3763332829671594932.wt   WiredTigerHS.wt
collection-7-3763332829671594932.wt   index-6-3763332829671594932.wt   WiredTiger.lock
diagnostic.data			      index-8-3763332829671594932.wt   WiredTiger.turtle
index-1-3377914449258320463.wt	      index-9-3763332829671594932.wt   WiredTiger.wt
&lt;/pre&gt;

&lt;p&gt;Efectivamente aquí podemos encontrar los distintos documentos.&lt;/p&gt;

&lt;p&gt;Bien, ya sabríamos como localizar la ruta donde se están almacenando los datos de nuestra base de datos, pero, ¿y si quisiéramos indicar una nueva ruta para que &lt;em&gt;MongoDB&lt;/em&gt; almacene una determinada colección?&lt;/p&gt;

&lt;p&gt;Esto también es posible en dicho gestor no relacional, y podríamos hacerlo utilizando la herramienta &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mongod&lt;/code&gt; mediante el siguiente comando:&lt;/p&gt;

&lt;pre&gt;
mongod --dbpath {/ruta_a_almacenar} --fork --logpath {/ruta_a_almacenar/log}
&lt;/pre&gt;

&lt;p&gt;Es importante que dicha ruta exista previamente y posea los permisos adecuados para que &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mongod&lt;/code&gt; pueda leer y escribir en ella.&lt;/p&gt;</content><author><name></name></author><summary type="html">Oracle</summary></entry></feed>
<!DOCTYPE html>
<html lang="es">

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">


        <title>Introducción a Docker | Javier Pérez Hidalgo</title>

        <!-- Bootstrap Core CSS -->
        <link href="/theme/css/bootstrap.min.css" rel="stylesheet">

        <!-- Custom CSS -->
        <link href="/theme/css/clean-blog.min.css" rel="stylesheet">

        <!-- Code highlight color scheme -->
            <link href="/theme/css/code_blocks/darkly.css" rel="stylesheet">


        <!-- Custom Fonts -->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->



        <meta name="description" content="Almacenamiento Los contenedores son efímeros Los contenedores son efímeros, es decir, los ficheros, datos y configuraciones que creamos...">

        <meta name="author" content="Javier Pérez Hidalgo">

        <meta name="tags" content="Docker">

	                <meta property="og:locale" content="">
		<meta property="og:site_name" content="Javier Pérez Hidalgo">

	<meta property="og:type" content="article">
            <meta property="article:author" content="/author/javier-perez-hidalgo.html">
	<meta property="og:url" content="/introduccion-a-docker.html">
	<meta property="og:title" content="Introducción a Docker">
	<meta property="article:published_time" content="2021-02-15 00:00:00+01:00">
            <meta property="og:description" content="Almacenamiento Los contenedores son efímeros Los contenedores son efímeros, es decir, los ficheros, datos y configuraciones que creamos...">

            <meta property="og:image" content="theme/images/banner-aplicacionesweb.jpg">
</head>

<body class="article-introduccion-a-docker">

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
        <!--    <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>-->
                <a class="navbar-brand" href="/">Inicio</a>
                <a class="navbar-brand" href="/categories">Categorías</a>
                <a class="navbar-brand" href="/authors">Sobre mí</a>

            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">

                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
        <header class="intro-header" style="background-image: url('/theme/images/banner-aplicacionesweb.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>Introducción a Docker</h1>
                        <span class="meta">Publicado por
                                <a href="/author/javier-perez-hidalgo.html">Javier Pérez Hidalgo</a>
                             el lun 15 febrero 2021
                        </span>
                        
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
    <!-- Post Content -->
    <article>
        <hr>
<h2>Almacenamiento</h2>
<h4>Los contenedores son efímeros</h4>
<p><strong>Los contenedores son efímeros</strong>, es decir, los ficheros, datos y configuraciones que creamos en los contenedores sobreviven a las paradas de los mismos, pero, sin embargo, son destruidos si el contenedor es destruido.</p>
<p>Veamos un ejemplo:</p>
<pre>
$ docker run -d --name my-apache-app -p 8080:80 httpd:2.4
ac50cc24ef71ae0263be7794278600d5cc4f085b88cebbf97b7b268212f2a82f

$ docker exec my-apache-app bash -c 'echo "<\h1\>Hola<\/h1\>" > htdocs/index.html'

$ curl http://localhost:8080
<\h1\>Hola<\/h1\>

$ docker rm -f my-apache-app
my-apache-app

$ docker run -d --name my-apache-app -p 8080:80 httpd:2.4
bb94716205c780ec4a3a2695722fb35ac616ae4cea573308d9446208afb164dc

$ curl http://localhost:8080
<\html\><\body\><\h1\>It works!<\/h1\><\/body\><\/html\>
</pre>

<p>Vemos como al eliminar el contenedor, la información que habíamos guardado en el fichero <code>index.html</code> se pierde, y al crear un nuevo contenedor ese fichero tendrá el contenido original.</p>
<p><strong>NOTA: En la instrucción <code>docker exec</code> hemos ejecutado el comando con <em>bash</em> <code>-c</code> que nos permite ejecutar uno o más comandos en el contenedor de forma más compleja (por ejemplo, indicando ficheros dentro del contenedor).</strong></p>
<h4>Los datos en los contenedores</h4>
<p><img alt="." src="images/iaw_introducción_a_docker/docker.png"></p>
<p>Ante la situación anteriormente descrita, <em>Docker</em> nos proporciona varias soluciones para persistir los datos de los contenedores. En este <em>post</em> nos vamos a centrar en las dos que considero que son más importantes:</p>
<ul>
<li><strong>volúmenes docker</strong></li>
<li><strong>bind mount</strong></li>
<li><strong>tmpfs mounts</strong>: almacenan en memoria la información (no lo vamos a ver con detalle)</li>
</ul>
<h4>Volúmenes docker y bind mount</h4>
<ul>
<li>
<p><strong>Volúmenes docker:</strong> si elegimos conseguir la persistencia usando volúmenes, estamos haciendo que los datos de los contenedores que nosotros decidamos, se almacenen en una parte del sistema de ficheros que es gestionada por <em>Docker</em> y a la que, debido a sus permisos, sólo <em>Docker</em> tendrá acceso. En Linux se guardan en la ruta <code>/var/lib/docker/volumes</code>. Este tipo de volúmenes se suele usar en los siguiente casos:</p>
<ul>
<li>Para compartir datos entre contenedores. Simplemente tendrán que usar el mismo volumen.</li>
<li>Para copias de seguridad ya sea para que sean usadas posteriormente por otros contenedores o para mover esos volúmenes a otros <em>hosts</em>.</li>
<li>Cuando quiero almacenar los datos de mi contenedor no localmente, sino en un proveedor <em>cloud</em>.</li>
</ul>
</li>
<li>
<p><strong>Bind mounts:</strong> si elegimos conseguir la persistencia de los datos de los contenedores usando <em>bind mount</em>, lo que estamos haciendo es “mapear” (montar) una parte de nuestro sistema de ficheros, de la que normalmente tenemos el control, con una parte del sistema de ficheros del contenedor. De esta manera conseguimos:</p>
<ul>
<li>Compartir ficheros entre el <em>host</em> y los <em>containers</em>.</li>
<li>Que otras aplicaciones que no sean <em>Docker</em> tengan acceso a esos ficheros, ya sean código, ficheros, ...</li>
</ul>
</li>
</ul>
<h4>Gestionando volúmenes</h4>
<p>Algunos comando útiles para trabajar con volúmenes <em>Docker</em>:</p>
<ul>
<li><strong>docker volumen create:</strong> crea un volumen con el nombre indicado.</li>
<li><strong>docker volume rm:</strong> elimina el volumen indicado.</li>
<li><strong>docker volumen prune:</strong> para eliminar los volúmenes que no están siendo usados por ningún contenedor.</li>
<li><strong>docker volume ls:</strong> nos proporciona una lista de los volúmenes creados y algo de información adicional.</li>
<li><strong>docker volume inspect:</strong> nos dará una información mucho más detallada de el volumen que hayamos elegido.</li>
</ul>
<h4>Asociando almacenamiento a los contenedores</h4>
<p>Veamos como podemos usar los volúmenes y los <em>bind mounts</em> en los contenedores. Para cualquiera de los dos casos lo haremos mediante el uso de dos <em>flags</em> de la orden <em>docker run</em>:</p>
<ul>
<li>El <em>flag</em> <code>--volume</code> o <code>-v</code></li>
<li>El <em>flag</em> <code>--mount</code></li>
</ul>
<p>Es importante que tengamos en cuenta dos cosas importantes a la hora de realizar estas operaciones:</p>
<ul>
<li>Al usar tanto volúmenes como <em>bind mounts</em>, el contenido de lo que tenemos sobrescribirá la carpeta destino en el sistema de ficheros del contenedor en caso de que exista.</li>
<li>Si nuestra carpeta origen no existe y hacemos un <em>bind mount</em>, esa carpeta se creará pero lo que tendremos en el contenedor es una carpeta vacía.</li>
<li>Si usamos imágenes de <em>DockerHub</em>, debemos leer la información que cada imagen nos proporciona en su página, ya que esa información suele indicar cómo persistir los datos de esa imagen, ya sea con volúmenes o <em>bind mounts</em>, y cuáles son las carpetas importantes en caso de ser imágenes que contengan ciertos servicios (web, base de datos, ...).</li>
</ul>
<h4>Trabajando con volúmenes docker:</h4>
<ul>
<li><strong>Crea un volumen docker que se llame <code>miweb</code>.</strong></li>
</ul>
<p>Creamos el nuevo volumen:</p>
<pre>
javier@debian:~$ docker volume create miweb
miweb

javier@debian:~$ docker volume ls
DRIVER              VOLUME NAME
local               051b59979e0527c228be360c9b7568856a8cf37b16b9ce415f3e5fa48b812891
local               e1be424428521f02e06f73a92c2100b8cc42aaf813680bc3ee792c1353ae3abf
local               miweb
</pre>

<p>Listo.</p>
<ul>
<li><strong>Crea un contenedor desde la imagen <code>php:7.4-apache</code> donde montes en el directorio <code>/var/www/html</code>, (que sabemos que es el <em>document root</em> del servidor que nos ofrece esa imagen) el volumen docker que has creado.</strong></li>
</ul>
<p>Creamos el contenedor:</p>
<pre>
javier@debian:~$ docker pull php:7.4-apache
7.4-apache: Pulling from library/php
a076a628af6f: Already exists
02bab8795938: Already exists
657d9d2c68b9: Already exists
f47b5ee58e91: Already exists
2b62153f094c: Already exists
60b09083723b: Already exists
1701d4d0a478: Already exists
bae0c4dc63ea: Already exists
a1c05958a901: Already exists
5964d339be93: Already exists
1319bb6aacaa: Already exists
71860efe761d: Already exists
c5a84dbdd6a5: Already exists
Digest: sha256:584d2109fa4f3f0cf25358828254dc5668882167634384ad68537a3069d31652
Status: Downloaded newer image for php:7.4-apache

javier@debian:~$ docker run -d --name pruebavolumendocker -v miweb:/var/www/html -p 8080:80 php:7.4-apache
9b350c4f505b085d9633f8f46bb3a200266d4d09785c6311adae82daf1834403
</pre>

<p>Listo.</p>
<ul>
<li><strong>Utiliza el comando <code>docker cp</code> para copiar un fichero <code>info.php</code> en el directorio <code>/var/www/html</code>.</strong></li>
</ul>
<p>Copiamos el archivo <code>info.php</code>:</p>
<pre>
javier@debian:~$ docker cp info.php pruebavolumendocker:/var/www/html
</pre>

<p>Listo.</p>
<ul>
<li><strong>Accede al contenedor desde el navegador para ver la información ofrecida por el fichero <code>info.php</code>.</strong></li>
</ul>
<p>Nos dirigimos a la dirección <code>http://localhost:8080/info.php</code>:</p>
<p><img alt="." src="images/iaw_introducción_a_docker/info.php.png"></p>
<p>Efectivamente podemos visualizar el fichero <code>info.php</code>.</p>
<ul>
<li><strong>Borra el contenedor.</strong></li>
</ul>
<p>Eliminamos el contenedor:</p>
<pre>
javier@debian:~$ docker rm -f pruebavolumendocker
pruebavolumendocker
</pre>

<p>Listo.</p>
<ul>
<li><strong>Crea un nuevo contenedor y monta el mismo volumen como en el ejercicio anterior.</strong></li>
</ul>
<p>Creamos el contenedor:</p>
<pre>
javier@debian:~$ docker run -d --name pruebavolumendocker2 -v miweb:/var/www/html -p 8080:80 php:7.4-apache
4fe9ed47558cbc4e44c73c2d4507228828bf003048c137491df434ec6e3ca58c
</pre>

<p>Listo.</p>
<ul>
<li><strong>Accede al contenedor desde el navegador para ver la información ofrecida por el fichero <code>info.php</code>. ¿Seguía existiendo ese fichero?</strong></li>
</ul>
<p>Podemos ver que sí, ya que estamos utilizando el mismo volumen.</p>
<p><img alt="." src="images/iaw_introducción_a_docker/info.php2.png"></p>
<h4>Trabajando con bind mount:</h4>
<ul>
<li><strong>Crea un directorio en tu <em>host</em> y dentro crea un fichero <code>index.html</code>.</strong></li>
</ul>
<p>Creamos el directorio y el fichero:</p>
<pre>
javier@debian:~$ mkdir pruebadocker

javier@debian:~$ nano pruebadocker/index.html
</pre>

<p>Listo.</p>
<ul>
<li><strong>Crea un contenedor desde la imagen <code>php:7.4-apache</code> donde montes en el directorio <code>/var/www/html</code> el directorio que has creado por medio de bind mount.</strong></li>
</ul>
<p>Creamos el contenedor:</p>
<pre>
javier@debian:~$ docker run -d --name bindmount -v /home/javier/pruebadocker:/var/www/html -p 8080:80 php:7.4-apache
6796f397cf0f9c1331778dc917caff72885bf3e594272d46e1fa65f3b58c686f
</pre>

<p>Listo.</p>
<ul>
<li><strong>Accede al contenedor desde el navegador para ver la información ofrecida por el fichero <code>index.html</code>.</strong></li>
</ul>
<p>Nos dirigimos a la dirección <code>http://localhost:8080</code>:</p>
<p><img alt="." src="images/iaw_introducción_a_docker/bindmount1.png"></p>
<p>Podemos visualizar la información.</p>
<ul>
<li><strong>Modifica el contenido del fichero <code>index.html</code> en tu <em>host</em> y comprueba que al refrescar la página ofrecida por el contenedor, el contenido ha cambiado.</strong></li>
</ul>
<p>Modificamos el contenido del fichero <code>index.html</code>:</p>
<pre>
javier@debian:~$ nano pruebadocker/index.html
</pre>

<p>Nos dirigimos a la dirección <code>http://localhost:8080</code>:</p>
<p><img alt="." src="images/iaw_introducción_a_docker/bindmount2.png"></p>
<p>Efectivamente ha cambiado el contenido.</p>
<ul>
<li><strong>Borra el contenedor</strong></li>
</ul>
<p>Eliminamos el contenedor:</p>
<pre>
javier@debian:~$ docker rm -f bindmount
bindmount
</pre>

<p>Listo.</p>
<ul>
<li><strong>Crea un nuevo contenedor y monta el mismo directorio como en el ejercicio anterior.</strong></li>
</ul>
<p>Creamos el contenedor:</p>
<pre>
javier@debian:~$ docker run -d --name bindmount2 -v /home/javier/pruebadocker:/var/www/html -p 8080:80 php:7.4-apache
5a1d596d751ae93fb1acc99f32f830573e89652cfb5d3a4900cfc9c835ea2fdb
</pre>

<p>Listo.</p>
<ul>
<li><strong>Accede al contenedor desde el navegador para ver la información ofrecida por el fichero <code>index.html</code>. ¿Se sigue viendo el mismo contenido?</strong></li>
</ul>
<p>Al igual que en el ejercicio anterior, podemos ver que sí, ya que estamos utilizando el mismo volumen.</p>
<p><img alt="." src="images/iaw_introducción_a_docker/bindmount2.png"></p>
<h4>Trabajando con contenedores con almacenamiento persistente</h4>
<ul>
<li><strong>Crea un contenedor desde la imagen <em>Nextcloud</em> (usando <em>sqlite</em>) configurando el almacenamiento como nos muestra la documentación de la imagen en <em>Docker Hub</em> (pero utilizando bind mount). Sube algún fichero.</strong></li>
</ul>
<p>Creamos el contenedor:</p>
<pre>
javier@debian:~$ mkdir nextcloud

javier@debian:~$ docker run -d --name Nextcloud -v /home/javier/nextcloud:/var/www/html -p 8080:80 nextcloud
1fd90edb9161d28a68c58799ddeea2c58ce0acec3e85663997baae9987709274
</pre>

<p>Nos dirigimos a la dirección <code>http://localhost:8080</code>:</p>
<p><img alt="." src="images/iaw_introducción_a_docker/nextcloud.png"></p>
<p>Lo instalamos con una base de datos <strong>sqlite</strong> y una vez lo tengamos instalado, subimos cualquier fichero. En mi caso he subido el fichero llamado <strong>logojp.jpg</strong>.</p>
<p><img alt="." src="images/iaw_introducción_a_docker/nextcloud2.png"></p>
<p>Listo.</p>
<ul>
<li><strong>Elimina el contenedor.</strong></li>
</ul>
<p>Eliminamos el contenedor:</p>
<pre>
javier@debian:~$ docker rm -f Nextcloud
Nextcloud
</pre>

<p>Listo.</p>
<ul>
<li><strong>Crea un contenedor nuevo con la misma configuración de volúmenes. Comprueba que la información que teníamos (ficheros, usuaurio, …), sigue existiendo.</strong></li>
</ul>
<p>Creamos el nuevo contenedor llamado <strong>Nextcloud2</strong>:</p>
<pre>
javier@debian:~$ docker run -d --name Nextcloud2 -v /home/javier/nextcloud:/var/www/html -p 8080:80 nextcloud
b102fd06e36cba2e26db09414359892e3ad403a64715f7e4311cad460b2d7684
</pre>

<p>Nos dirigimos a la dirección <code>http://localhost:8080</code>:</p>
<p><img alt="." src="images/iaw_introducción_a_docker/nextcloud3.png"></p>
<p>Podemos ver como esta vez no nos pide instalar la aplicación, sino que directamente nos pide que iniciemos sesión. Iniciamos sesión con el usuario creado anteriormente y visualizamos los archivos:</p>
<p><img alt="." src="images/iaw_introducción_a_docker/nextcloud4.png"></p>
<p>Efectivamente se encuentra el logo que hemos subido en el anterior contenedor, por lo que no hemos perdido la información al eliminar el contenedor.</p>
<ul>
<li><strong>Comprueba el contenido de directorio que se ha creado en el <em>host</em>.</strong></li>
</ul>
<p>Visualizamos el contenido del directorio <code>/home/javier/nextcloud</code>:</p>
<pre>
javier@debian:~/nextcloud$ ls
3rdparty  config       core         data        lib           ocs           remote.php  status.php
apps      console.php  cron.php     index.html  occ           ocs-provider  resources   themes
AUTHORS   COPYING      custom_apps  index.php   ocm-provider  public.php    robots.txt  version.php
</pre>

<p>Podemos ver como efectivamente se encuentran todos los datos de la web.</p>
<h2>Redes</h2>
<h4>Introducción a las redes en docker</h4>
<p>Aunque hasta ahora no lo hemos tenido en cuenta, cada vez que creamos un contenedor, esté se conecta a una red virtual, y<em>Docker</em> hace una configuración del sistema (usando interfaces puente e <em>iptables</em>) para que la máquina tenga una IP interna, tenga acceso al exterior, podamos mapear (DNAT) puertos, ...).</p>
<pre>
$ docker run -it --rm debian bash -c "ip a"
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
28: eth0@if29: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
</pre>

<p><strong>NOTA:</strong> Hemos usado la opción <code>--rm</code> para que, cuando el proceso termine de ejecutarse, el contenedor se elimine.</p>
<p>Observamos que el contenedor tiene una IP en la red <code>172.17.0.0/16</code>. Además podemos comprobar que se ha creado un <em>bridge</em> en el <em>host</em>, al que se conectan los contenedores:</p>
<pre>
$ ip a
...
5: docker0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:be:71:11:9e brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:beff:fe71:119e/64 scope link
       valid_lft forever preferred_lft forever
...
</pre>

<p>Además podemos comprobar que se han creado distintas cadenas en el cortafuegos para gestionar la comunicación de los contenedores. Podemos ejecutar: <code>iptables -L -n</code> y <code>iptables -L -n - t nat</code> y verificarlo.</p>
<h4>Tipos de redes en Docker</h4>
<p>Cuando instalamos <em>Docker</em> tenemos las siguientes redes predefinidas:</p>
<pre>
$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
ec77cfd20583        bridge              bridge              local
69bb21378df5        host                host                local
089cc966eaeb        none                null                local
</pre>

<p>Por defecto los contenedores que creamos se conectan a la red de tipo <em>bridge</em> llamada <strong>bridge</strong> (por defecto el direccionamiento de esta red es <code>172.17.0.0/16</code>). Los contenedores conectados a esta red que quieren exponer algún puerto al exterior tienen que usar la opción <code>-p</code> para mapear puertos.</p>
<p>Este tipo de red nos va a permitir:</p>
<ul>
<li>Aislar los distintos contenedores que tengamos en distintas subredes <em>Docker</em>, de tal manera que desde cada una de las subredes solo podremos acceder a los equipos de esa misma subred.</li>
<li>Aislar los contenedores del acceso exterior.</li>
<li>Publicar servicios que tengamos en los contenedores mediante redirecciones que <em>Docker</em> implementará con las pertinentes reglas de <em>iptables</em>.</li>
</ul>
<p><img alt="." src="images/iaw_introducción_a_docker/redesdocker.png"></p>
<p>Si conectamos un contenedor a la red <em>host</em>, el contenedor estaría en la misma red que el <em>host</em> (por lo tanto toma direccionamiento del servidor <em>DHCP</em> de nuestra red). Además los puerto son accesibles directamente desde el <em>host</em>. Por ejemplo:</p>
<pre>
$ docker run -d --name mi_servidor --network host josedom24/aplicacionweb:v1

$ docker ps
CONTAINER ID        IMAGE                        COMMAND                  CREATED             STATUS              PORTS               NAMES
135c742af1ff        josedom24/aplicacionweb:v1   "/usr/sbin/apache2ct…"   3 seconds ago       Up 2 seconds                                  mi_servidor
</pre>

<p>Si probamos a acceder directamente al puerto 80 del servidor, podremos ver la página web.</p>
<p>La red <em>none</em> no configurará ninguna IP para el contenedor y no tiene acceso a la red externa ni a otros contenedores. Tiene la dirección <em>loopback</em> y se puede usar para ejecutar trabajos por lotes.</p>
<h4>Gestionando las redes en Docker</h4>
<p>Tenemos que hacer una diferenciación entre dos tipos de redes <strong>bridged</strong>:</p>
<ul>
<li>La red creada por defecto por <em>Docker</em> para que funcionen todos los contenedores.</li>
<li>Y las redes <em>bridged</em> definidas por el usuario.</li>
</ul>
<p>Esta red <em>bridged</em>, que es la usada por defecto por los contenedores, se diferencia en varios aspectos de las redes <em>bridged</em> que creamos nosotros. Estos aspectos son los siguientes:</p>
<ul>
<li>Las redes que nosotros definimos proporcionan resolución DNS entre los contenedores, cosa que la red por defecto no hace, a no ser que usemos opciones que ya se consideran <em>deprectated</em> (<code>--link</code>).</li>
<li>Se pueden conectar en caliente a los contenedores redes <em>bridged</em> definidas por el usuario. Si uso la red por defecto tengo que parar previamente el contenedor.</li>
<li>Nos permite gestionar de manera más segura el aislamiento de los contenedores, ya que si no indico una red al arrancar un contenedor, éste se incluye en la red por defecto, donde pueden convivir servicios que no tengan nada que ver.</li>
<li>Tenemos más control sobre la configuración de las redes si las definimos nosotros. Los contenedores de la red por defecto comparten todos la misma configuración de red (MTU, reglas <em>iptables</em>, ...).</li>
<li>Los contenedores dentro de la red <em>bridge</em> comparten todos ciertas variables de entorno, lo que puede provocar ciertos conflictos.</li>
</ul>
<p>En definitiva, es importante que nuestro contenedores en producción, se estén ejecutando sobre una red definida por el usuario.</p>
<p>Para gestionar las redes creadas por el usuario:</p>
<ul>
<li><strong>docker network ls:</strong> listado de las redes</li>
<li><strong>docker network create:</strong> creación de redes. Ejemplos:<ul>
<li><code>docker network create red1</code></li>
<li><code>docker network create -d bridge --subnet 172.24.0.0./16 --gateway 172.24.0.1 red2</code></li>
</ul>
</li>
<li><strong>docker network rm/prune:</strong> borra redes. Teniendo en cuenta que se no puede borrar una red que tenga contenedores que la estén usando, primero deberíamos borrar los contenedores, o desconectar la red de ese contenedor.</li>
<li><strong>docker network inspect:</strong> nos da información de la red</li>
</ul>
<p><strong>NOTA:</strong> Cada red <em>Docker</em> que creemos, creará un puente de red específico. Podemos ver con <code>ip a</code>:</p>
<p><img alt="." src="images/iaw_introducción_a_docker/redesdocker2.png"></p>
<h4>Asociación de redes a los contenedores</h4>
<p>Imaginemos que hemos creado dos redes definidas por el usuario:</p>
<pre>
$ docker network create --subnet 172.28.0.0/16 --gateway 172.28.0.1 red1
$ docker network create red2
</pre>

<p>Vamos a trabajar en un primer momento con la <em>red1</em>. Vamos a crear dos contenedores conectados a dicha red:</p>
<pre>
$ docker run -d --name my-apache-app --network red1 -p 8080:80 httpd:2.4
</pre>

<p>Lo primero que vamos a comprobar es la resolución DNS:</p>
<pre>
$ docker run -it --name contenedor1 --network red1 debian bash
root@98ab5a0c2f0c:/# apt update && apt install dnsutils -y
...
root@98ab5a0c2f0c:/# dig my-apache-app
...
;; ANSWER SECTION:
my-apache-app.      600 IN  A   172.28.0.2
...
;; SERVER: 127.0.0.11#53(127.0.0.11)
...
</pre>

<p>Ahora podemos probar como podemos conectar un contenedor a una red. Para ello, usaremos <code>docker network connect</code> y para desconectarla usaremos <code>docker network disconnect</code>.</p>
<pre>
$ docker network connect red2 contenedor1

$ docker start contenedor1
contenedor1

$ docker attach contenedor1
root@98ab5a0c2f0c:/# ip a
...
46: eth0@if47: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    ...
    inet 172.28.0.4/16 brd 172.28.255.255 scope global eth0
...
48: eth1@if49: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
...    
    inet 172.18.0.3/16 brd 172.18.255.255 scope global eth1
...
</pre>

<p>Tanto al crear un contenedor con el <em>flag</em> <code>--network</code>, como con la instrucción <code>docker network connect</code>, podemos usar algunos otros <em>flags</em>:</p>
<ul>
<li><code>--dns</code>: para establecer unos servidores DNS predeterminados</li>
<li><code>--ip6</code>: para establecer la dirección de red ipv6</li>
<li><code>--hostname</code> o <code>-h</code>: para establecer el nombre de <em>host</em> del contenedor. Si no lo establezco será el ID del mismo.</li>
</ul>
<h4>Instalación de WordPress</h4>
<p>Para la instalación de WordPress necesitamos dos contenedores: la base de datos (imagen <em>mariadb</em>) y el servidor web con la aplicación (imagen <em>wordpress</em>). Los dos contenedores tienen que estar en la misma red y deben tener acceso por nombres (resolución DNS), ya que en un principio no sabemos que IP va a poseer cada contenedor. Por lo tanto vamos a crear los contenedores en la misma red:</p>
<pre>
docker network create red_wp
</pre>

<p>Siguiendo la documentación de la imagen <em>mariadb</em> y la imagen <em>wordpress</em> podemos ejecutar los siguientes comandos para crear los dos contenedores:</p>
<pre>
docker run -d --name servidor_mysql \
           --network red_wp \
           -v /opt/mysql_wp:/var/lib/mysql \
           -e MYSQL_DATABASE=bd_wp \
           -e MYSQL_USER=user_wp \
           -e MYSQL_PASSWORD=asdasd \
           -e MYSQL_ROOT_PASSWORD=asdasd \
           mariadb

...

docker run -d --name servidor_wp \
             --network red_wp \
             -v /opt/wordpress:/var/www/html/wp-content \
             -e WORDPRESS_DB_HOST=servidor_mysql \
             -e WORDPRESS_DB_USER=user_wp \
             -e WORDPRESS_DB_PASSWORD=asdasd \
             -e WORDPRESS_DB_NAME=bd_wp \
             -p 80:80 \
             wordpress

...

javier@debian:~$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                NAMES
454c7149baba        wordpress           "docker-entrypoint.s…"   8 seconds ago        Up 7 seconds        0.0.0.0:80->80/tcp   servidor_wp
1923a8dc9f48        mariadb             "docker-entrypoint.s…"   About a minute ago   Up About a minute   3306/tcp             servidor_mysql
</pre>

<p>Algunas observaciones:</p>
<ul>
<li>
<p>El contenedor <em>servidor_mysql</em> ejecuta un <em>script</em> <code>docker-entrypoint.sh</code> que es el encargado, a partir de las variables de entorno, de configurar la base de datos: crea un usuario, crea la base de datos, cambia la contraseña del usuario <em>root</em>, ... y termina ejecutando el servidor <em>mariadb</em>.</p>
</li>
<li>
<p>Los creadores de la imagen <em>mariadb</em>, han tenido en cuenta que el contenedor, tiene que permitir la conexión desde otra máquina, por lo que, en su configuración, se encuentra comentado el parámetro <code>bind-address</code>.</p>
</li>
<li>
<p>Del mismo modo, el contenedor <em>servidor_wp</em> ejecuta un <em>script</em> <code>docker-entrypoint.sh</code>, que entre otras cosas, a partir de las variables de entorno, ha creado el fichero <code>wp-config.php</code> de <em>WordPress</em>, por lo que durante la instalación no nos pedirá las credenciales de la base de datos.</p>
</li>
<li>
<p>Si nos fijamos, la variable de entorno <code>WORDPRESS_DB_HOST</code> la hemos inicializado al nombre del servidor de base de datos. Como ambos contenedores están conectados a la misma red definida por el usuario, el contenedor <em>WordPress</em> al intentar acceder al nombre <em>servidor_mysql</em>, estará accediendo al contenedor de la base de datos.</p>
</li>
<li>
<p>El servicio al que vamos a acceder desde el exterior es al servidor web, es por lo que hemos mapeado los puertos con la opción <code>-p</code>. Sin embargo, en el contenedor de la base de datos no es necesario mapear los puertos porque no vamos a acceder a ella desde el exterior. Eso sí, el contenedor <em>servidor_wp</em>, sí puede acceder al puerto 3306 del <em>servidor_mysql</em> sin problemas, ya que están conectados a la misma red.</p>
</li>
</ul>
<p>Para terminar, vamos a ver si realmente las configuraciones que hemos realizado mediante parámetros a la hora de crear los contenedores se han llevado a cabo.</p>
<p>Primeramente, vamos a comprobar en el fichero <code>wp-config.php</code> del contenedor de <em>WordPress</em>, que los parámetros de conexión a la base de datos son los mismos que los indicados en las variables de entorno.</p>
<pre>
javier@debian:~$ docker exec servidor_wp cat wp-config.php
...

// ** MySQL settings - You can get this info from your web host ** //
/** The name of the database for WordPress */
define( 'DB_NAME', 'bd_wp');

/** MySQL database username */
define( 'DB_USER', 'user_wp');

/** MySQL database password */
define( 'DB_PASSWORD', 'asdasd');

/** MySQL hostname */
define( 'DB_HOST', 'servidor_mysql');

...
</pre>

<p>Bien, vemos que sí.</p>
<p>Ahora vamos a comprobar que los contenedores posean conexión entre sí mediante resolución de nombres, para ello, vamos a intentar realizar un <em>ping</em> desde el contenedor <em>servidor_wp</em> usando el nombre <em>servidor_mysql</em> (tendremos que instalar el paquete <code>iputils-ping</code> en el contenedor).</p>
<pre>
javier@debian:~$ docker exec -it servidor_wp /bin/bash

root@454c7149baba:/var/www/html# apt update
...

root@454c7149baba:/var/www/html# apt install iputils-ping
...

root@454c7149baba:/var/www/html# ping servidor_mysql
PING servidor_mysql (172.18.0.2) 56(84) bytes of data.
64 bytes from servidor_mysql.red_wp (172.18.0.2): icmp_seq=1 ttl=64 time=0.127 ms
64 bytes from servidor_mysql.red_wp (172.18.0.2): icmp_seq=2 ttl=64 time=0.093 ms
64 bytes from servidor_mysql.red_wp (172.18.0.2): icmp_seq=3 ttl=64 time=0.094 ms
^C
--- servidor_mysql ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 22ms
rtt min/avg/max/mdev = 0.093/0.104/0.127/0.019 ms
</pre>

<p>Efectivamente el <em>ping</em> se ha realizado correctamente.</p>
<p>Por último, vamos a comprobar que en el fichero <code>/etc/mysql/mariadb.conf.d/50-server.cnf</code> del contenedor con la base de datos, se encuentre comentado el parámetro <code>bind-address</code> como he indicado anteriormente.</p>
<pre>
javier@debian:~$ docker exec servidor_mysql cat /etc/mysql/mariadb.conf.d/50-server.cnf
...

# Instead of skip-networking the default is now to listen only on
# localhost which is more compatible and is not less secure.
#bind-address            = 127.0.0.1

...
</pre>

<p>En este caso la respuesta vuelve a ser afirmativa, por lo que acabamos de comprobar que todas las configuraciones se han llevado a cabo de la manera esperada.</p>
<p>.</p>
    </article>

        <div class="tags">
            <p><strong><a href="/tags">tags:</a></strong> <a href="/tag/docker.html">Docker</a></p>
        </div>

    <hr>

            </div>
        </div>
    </div>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                            <li>
                                <a href="https://www.instagram.com/javierpzh/">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-instagram fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                            <li>
                                <a href="https://twitter.com/jperezhid_">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                            <li>
                                <a href="https://github.com/javierpzh">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                            <li>
                                <a href="https://www.facebook.com/javier.perezhidalgo.904">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                            <li>
                                <a href="mailto:javierperezhidalgo01@gmail.com">
                                    <span class="fa-stack fa-lg">
                                        <i class="fa fa-circle fa-stack-2x"></i>
                                        <i class="fa fa-envelope-square fa-stack-1x fa-inverse"></i>
                                    </span>
                                </a>
                            </li>
                    </ul>
<p class="copyright text-muted">
    Blog creado por <a href="http://www.instagram.com/javierpzh/">Javier Pérez Hidalgo</a>,
    con la utilización de <a href="https://blog.getpelican.com/">Pelican</a>. <br />        &copy;  Javier Pérez Hidalgo
</p>                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="/theme/js/jquery.min.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="/theme/js/bootstrap.min.js"></script>

        <!-- Custom Theme JavaScript -->
        <script src="/theme/js/clean-blog.min.js"></script>

</body>

</html>